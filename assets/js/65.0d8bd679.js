(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{393:function(r,t,e){"use strict";e.r(t);var a=e(12),o=Object(a.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h2",{attrs:{id:"一、顺序消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、顺序消费"}},[r._v("#")]),r._v(" 一、顺序消费")]),r._v(" "),t("h3",{attrs:{id:"kafka是如何消费消息的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka是如何消费消息的"}},[r._v("#")]),r._v(" Kafka是如何消费消息的")]),r._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6906843890607718407",target:"_blank",rel:"noopener noreferrer"}},[r._v("Kafka消费线程模型"),t("OutboundLink")],1)])]),r._v(" "),t("p",[t("strong",[r._v("Kafka的topic、partition、consumer的关系")])]),r._v(" "),t("ul",[t("li",[t("p",[t("code",[r._v("topic：partition")]),r._v(" - "),t("code",[r._v("1：n")]),r._v("【Kafka中一个topic对应多个partition】")])]),r._v(" "),t("li",[t("p",[t("code",[r._v("partition：consumer")]),r._v(" - "),t("code",[r._v("n：1")]),r._v("【一个partition只能被一个consumer消费，一个consumer可以消费多个partition，consumer采用的是单线程拉取消息，每次默认拉取500条到本地，保证消息的有序性，但是单线程导致消息的吞吐量较低】")])])]),r._v(" "),t("h3",{attrs:{id:"如何保证消息有序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息有序"}},[r._v("#")]),r._v(" 如何保证消息有序")]),r._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6962323755959844894",target:"_blank",rel:"noopener noreferrer"}},[r._v("如何确保消息有序性"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("消息有序由以下两方面控制：")]),r._v(" "),t("ul",[t("li",[r._v("生产者发送的消息有序")]),r._v(" "),t("li",[r._v("Kafka分配到partition的消息有序："),t("strong",[r._v("通过partitionKey进行分配")])]),r._v(" "),t("li",[r._v("消费者消费有序：Kafka的partition由同个consumer消费，并且consumer默认采用单线程进行消息拉取和消息，所以本质上是有序的")])]),r._v(" "),t("h3",{attrs:{id:"如何保证有序的同时提高消息吞吐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证有序的同时提高消息吞吐"}},[r._v("#")]),r._v(" 如何保证有序的同时提高消息吞吐")]),r._v(" "),t("p",[r._v("Kafka consumer默认采用单线程进行消息处理，如果对消息吞吐有更高的要求，可以在接收到消息后再根据业务需要再次进行哈希分组，将同个partition中的消息进行分组，并采用多线程分别对每个分组进行消息，这样可以提高消息的消费速度。")]),r._v(" "),t("h3",{attrs:{id:"kafka如何处理脑裂问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何处理脑裂问题"}},[r._v("#")]),r._v(" Kafka如何处理脑裂问题")]),r._v(" "),t("p",[r._v("Kafka中有唯一的Controller Broker进行Broker集群、Topic、分区管理，而当出现网络波动的时候，网络会被划分为两段，这时候zookeeper认为Controller挂了，会发起重新选举，此时会出现连个Controller同时存在的情况，他们可能发出具有冲突的指令，导致数据不一致。")]),r._v(" "),t("p",[r._v("Kafka是通过使用"),t("strong",[r._v("epoch number")]),r._v("（纪元编号，也称为隔离令牌）来解决脑裂问题。epoch number只是单调递增的数字，第一次选出Controller时，epoch number值为1，如果再次选出新的Controller，则epoch number将为2，依次单调递增。每个新选出的controller通过Zookeeper 的条件递增操作获得一个全新的、数值更大的epoch number 。其他Broker 在知道当前epoch number 后，如果收到由controller发出的包含较旧(较小)epoch number的消息，就会忽略它们，即Broker根据最大的epoch number来区分当前最新的controller。")])])}),[],!1,null,null,null);t.default=o.exports}}]);