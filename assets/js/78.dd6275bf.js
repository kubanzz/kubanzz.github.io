(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{409:function(t,e,s){"use strict";s.r(e);var v=s(12),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"一条redis命令的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一条redis命令的执行过程"}},[t._v("#")]),t._v(" 一条Redis命令的执行过程")]),t._v(" "),e("ul",[e("li",[t._v("参考："),e("a",{attrs:{href:"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/01%20Redis%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redis的执行过程"),e("OutboundLink")],1)])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122545.png",alt:"image.png"}})]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("连接建立")])])]),t._v(" "),e("p",[t._v("Redis包括客户端与服务端，客户端发送相关执行，服务端负责接收、解析并执行。通常Redis客户端和服务端都在不同的服务器上，Redis基于Socket进行网络通信，采用IO多路复用模型进行Socket连接管理。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("I/O 多路复用")]),t._v("：Redis 使用的是 I/O 多路复用功能来监听多 Socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122546.png",alt:"IO多路复用.png"}})])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[t._v("客户端发送命令：封装RESP协议")])])]),t._v(" "),e("p",[t._v("用户发送命令，客户端会将命令封装成RESP协议（Redis的通信协议），接着通过Socket进行发送。通过协议服务端和客户端之间可以快速理解通信内容。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("Socket 小知识")]),t._v("：每个 Socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。")])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[e("strong",[t._v("服务端接收命令：解析RESP协议")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("数据大小验证：服务器会先去输入缓冲中读取数据，如果数据量大于1G则关闭客户端连接。")])]),t._v(" "),e("li",[e("p",[t._v("协议解析：数据大小验证通过后，解析协议并且提取出指令存放在Client对象中（服务端为每个连接创建一个Client对象）")])])])]),t._v(" "),e("li",[e("p",[t._v("执行前的验证准备")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("用户权限校验")]),t._v("：未通过身份验证的用户只能执行AUTH(授权) 命令")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("集群相关校验")]),t._v("：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("目标节点重定向：如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；")])]),t._v(" "),e("li",[e("p",[t._v("从节点状态效验：当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；")])]),t._v(" "),e("li",[e("p",[t._v("只读从节点验证：当此服务器为只读从节点时，只接受 master 的写命令；")])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("内存校验")]),t._v("：如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作（引出Redis的缓存清除机制及缓存淘汰算法）；")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("持久化检测")]),t._v("：检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("事物检验")]),t._v("：如果执行的是事务命令，则开启事务把命令放入等待队列；")])])])]),t._v(" "),e("li",[e("p",[t._v("执行最终命令，调用 redisCommand 中的 proc 函数执行命令。")])]),t._v(" "),e("li",[e("p",[t._v("执行完后的相关记录和统计")]),t._v(" "),e("ul",[e("li",[t._v("检查慢查询是否开启，如果开启会记录慢查询日志；")]),t._v(" "),e("li",[t._v("检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；")]),t._v(" "),e("li",[t._v("检查持久化功能是否开启，如果开启则会记录持久化信息；")]),t._v(" "),e("li",[t._v("如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。")])])]),t._v(" "),e("li",[e("p",[t._v("返回结果给客户端")])])]),t._v(" "),e("h4",{attrs:{id:"redis中的key有时间限制-你觉得是怎么实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis中的key有时间限制-你觉得是怎么实现的"}},[t._v("#")]),t._v(" Redis中的key有时间限制，你觉得是怎么实现的？")]),t._v(" "),e("p",[t._v("Redis中的定时策略可以根据用户定制的时间保证键值对过期失效，底层采用字典表实现，Redis维护了一个"),e("strong",[t._v("过期字典表")]),t._v("，key为用户的key，value即为过期时间。当用户请求键值的时候，流程如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images3bf71ae0-5de7-11ea-9e57-957b6467a3fc.png",alt:"内存过期策略-过期键判断流程.png"}})]),t._v(" "),e("blockquote",[e("p",[t._v("Redis的过期策略：")]),t._v(" "),e("p",[t._v("由于Redis是单线程的框架，如果直接对所有过期键值进行清除，会导致服务一段时间无法提供服务，为了避免这种情况发生，redis提供了多种过期策略，主要以下三种，Redis默认采用第二+第三种。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定时全量删除：定时扫描并删除所有过期键值，可以快速释放内存，但是数量量大时会导致服务卡顿。")])]),t._v(" "),e("li",[e("p",[t._v("惰性删除：用户访问键值时再检查是否过期，过期则删除。")])]),t._v(" "),e("li",[e("p",[t._v("定时随机删除：定时随机检查部分键值是否过期，过期则删除，Redis中默认每10秒扫描一次，并且扫描策略如下，为了防止死循环，规定了扫描时间不超过25ms。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesc511d450-5de7-11ea-a9fa-c1c510366b3a.png",alt:"内存过期策略-执行流程2.png"}})])])])]),t._v(" "),e("h4",{attrs:{id:"keys命令和scan命令的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keys命令和scan命令的区别"}},[t._v("#")]),t._v(" keys命令和scan命令的区别")]),t._v(" "),e("p",[t._v("keys命令时间复杂度是O(n)，大数据量下会导致服务卡顿，而scan命令是分批次扫描的，不会阻塞线程，并且可以通过limit控制返回的数据量，缺点是可能会有数据一致性问题，因为是分批次读取。")])])}),[],!1,null,null,null);e.default=_.exports}}]);