(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{404:function(e,s,t){"use strict";t.r(s);var r=t(12),a=Object(r.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"一、主从模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、主从模式"}},[e._v("#")]),e._v(" 一、主从模式")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220901194207312.png",alt:"image-20220901194207312"}})]),e._v(" "),s("blockquote",[s("p",[e._v("主从模式是一种“读写分离”思想的实现。Redis单机大概能支撑几万的qps，而主从模式可以大大提高其读并发性能，主从模式通常是一主多从，主节点负责写操作和将数据复制到其他从节点，从节点负责读操作，本质上就是读写分离。主从模式下的Redis有以下特点：")]),e._v(" "),s("ul",[s("li",[e._v("高并发（读写分离）")]),e._v(" "),s("li",[e._v("高可用（主从切换）")]),e._v(" "),s("li",[e._v("高可靠（从备份数据）")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/imagesredis-master-slave.png",alt:"Redis-master-slave"}})]),e._v(" "),s("h3",{attrs:{id:"_1-1-数据同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-数据同步"}},[e._v("#")]),e._v(" 1.1 数据同步")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication.png",alt:"Redis-master-slave-replication"}})]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("全量复制")]),e._v("：当有新的从服务器连接时，为了保障多个数据库的一致性，主服务器会执行一次 "),s("code",[e._v("bgsave")]),e._v(" 命令生成一个 RDB 文件，然后再以 Socket 的方式发送给从服务器，从服务器收到 RDB 文件之后再把所有的数据加载到自己的程序中，就完成了一次全量的数据同步。")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("增量复制")]),e._v("：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("2.8之前：从服务器掉线重连后，主服务器都会进行一次完整的数据同步，如果掉线时间比较短，那么这种方式是非常不划算的。")])]),e._v(" "),s("li",[s("p",[e._v("2.8之后：当从服务器掉线后，主服务器会把离线后的写入命令，存储在一个特定大小的队列中，队列可以保证先进先出的顺序，当从服务器重写恢复上线之后，主服务会判断离线这段时间内的命令是否还在队列中，如果在就直接把队列中的数据发送给从服务器，这样就避免了完整同步的资源浪费。")]),e._v(" "),s("blockquote",[s("p",[e._v("存储离线命令的队列大小默认是 1MB，可以修改队列大小的配置项 repl-backlog-size。")])])])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("无盘同步")]),e._v("：当新的从节点加入时，主服务器会通过bgsave在本地生成RDB文件发送给从服务器，从服务器会先将RDB文件持久化到磁盘再读取，由于磁盘操作非常慢，为了解决这一问题，在2.8.18后增加了无盘复制功能，其特点是RDB文件不需要存入磁盘，而是由子线程生成数据内容通过socket直接发送到从服务器，这样主服务器可以避免磁盘写入与读取的过程，提高同步性能。")]),e._v(" "),s("blockquote",[s("p",[e._v("无盘复制默认是开闭的，需要通过配置"),s("code",[e._v("repl-diskless-sync")]),e._v("为yes开启")])])])]),e._v(" "),s("p",[s("strong",[e._v("完整流程")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication-detail.png",alt:"Redis-master-slave-replication-detail"}})]),e._v(" "),s("p",[s("strong",[e._v("常用命令")])]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("replicaof host port")]),e._v("：配置从节点")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("replicaof no one")]),e._v("：关闭从节点")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("role")]),e._v("：查看当前节点角色")])])]),e._v(" "),s("h2",{attrs:{id:"二、哨兵模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、哨兵模式"}},[e._v("#")]),e._v(" 二、哨兵模式")]),e._v(" "),s("blockquote",[s("p",[e._v("哨兵模式是一种自动容灾技术，可以避免手动切换服务器带来的弊端。Redis的实现方式是搭建一个sentinel集群，通过每秒一次ping命令的频率监听当前的主从模式的节点（默认超过30秒则认为下线），假如当前的sentinel节点有五个，quorum配置为3，那么当超过3个sential节点监测到主节点下线（主观认为），则客观认为主节点掉线，此时会启动故障转移。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main//images/91c09780-8574-11ea-a330-69dc969564d3-20220813125936520.png",alt:"哨兵模式-多哨兵.png"}})])]),e._v(" "),s("h3",{attrs:{id:"_2-1-自动发现机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-自动发现机制"}},[e._v("#")]),e._v(" 2.1 自动发现机制")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.cn/post/7112434646851584013",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis发布订阅"),s("OutboundLink")],1)])]),e._v(" "),s("p",[e._v("哨兵互相之间的发现，是通过 Redis 的 "),s("code",[e._v("pub/sub")]),e._v("（发布订阅，在redis种"),s("code",[e._v("pubsub_channels")]),e._v("是字典数据结构，key为channel即频道，value为list即订阅的客户端） 系统实现的，每个哨兵都会往 "),s("code",[e._v("__sentinel__:hello")]),e._v(" 这个 channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220816142203876.png",alt:"image-20220816142203876"}})]),e._v(" "),s("p",[s("strong",[e._v("配置传播")])]),e._v(" "),s("p",[e._v("哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后通过发布订阅模式同步给其他的哨兵。其他的哨兵会根据配置信息的版本号，更新最新版本的master配置信息。")]),e._v(" "),s("h3",{attrs:{id:"_2-2-故障转移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-故障转移"}},[e._v("#")]),e._v(" 2.2 故障转移")]),e._v(" "),s("p",[s("strong",[e._v("主从节点竞选")])]),e._v(" "),s("p",[e._v("故障转移即剔除掉线的主节点，从从节点中竞选主节点，竞选过程主要参照以下两个指标：")]),e._v(" "),s("ul",[s("li",[e._v("优先级：即节点的权重，可以通过"),s("code",[e._v("replica-priority")]),e._v("配置，值越小则优先级越高。")]),e._v(" "),s("li",[e._v("偏移量：即从节点数据同步情况，偏移量越大则说明数据同步度更高，优先级也越高。")])]),e._v(" "),s("p",[e._v("故障转移过程重点有以下步骤：")]),e._v(" "),s("ul",[s("li",[e._v("从节点排除\n"),s("ul",[s("li",[e._v("排除掉线的从节点")]),e._v(" "),s("li",[e._v("排除长时间没有跟主几点通信的从节点")]),e._v(" "),s("li",[e._v("排除优先级为0的从节点")])])]),e._v(" "),s("li",[e._v("主节点竞选\n"),s("ul",[s("li",[e._v("优先级高的从节点优先")]),e._v(" "),s("li",[e._v("优先级一样，则偏移量高的从节点优先")]),e._v(" "),s("li",[e._v("优先级和偏移量一样，则选择 Redis 运行时随机生成 ID 最小那个为新的主服务器")])])]),e._v(" "),s("li",[e._v("旧的主节点恢复：会作为新的从节点存在，并且清空数据，同步新的主节点的数据")])]),e._v(" "),s("p",[s("strong",[e._v("主备切换导致数据丢失")])]),e._v(" "),s("ul",[s("li",[e._v("异步复制导致数据丢失（宕机）")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/async-replication-data-lose-case.png",alt:"async-replication-data-lose-case"}})]),e._v(" "),s("ul",[s("li",[e._v("脑裂导致的数据丢失（网络问题）")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-cluster-split-brain.png",alt:"Redis-cluster-split-brain"}})]),e._v(" "),s("p",[s("strong",[e._v("数据丢失的解决方案")])]),e._v(" "),s("p",[e._v("下面配置表示：至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。这个配置可以保证主节点超过十秒的数据至少被从节点同步过了，否则主节点拒绝接收写入命令。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 超过十秒的主数据\nmin-slaves-max-lag 10\n// 至少被同步到一台从服务器上\nmin-slaves-to-write 1\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("这个配置可以将上述的两个问题导致的数据丢失都控制在10秒内，也就是保证丢失的数据是可控的。")]),e._v(" "),s("p",[s("strong",[e._v("Sentinel集群搭建")])]),e._v(" "),s("ol",[s("li",[s("p",[e._v("配置"),s("code",[e._v("sentinel.conf")]),e._v("文件，如监听的master ip、端口和密码")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("sentinel monitor mymaster 127.0.0.1 6379 1\nsentinel auth-pass mymaster pwd654321\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])]),e._v(" "),s("li",[s("p",[e._v("启动sentinel")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 通过以下命令可以启动sentinel，当多个sentinel监听同个master时会相互识别，形成sentinel\n./src/redis-sentinel sentinel.conf\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])])]),e._v(" "),s("p",[s("strong",[e._v("常用命令")])]),e._v(" "),s("ul",[s("li",[e._v("添加新的sentinel节点到集群："),s("code",[e._v("sentinel monitor master-name ip port quorum")])]),e._v(" "),s("li",[e._v("移除sentinel节点："),s("code",[e._v("sentinel remove mymaster")])]),e._v(" "),s("li",[e._v("修改quorum；"),s("code",[e._v("sentinel set master-name quorum n")])]),e._v(" "),s("li",[e._v("查看某主节点的信息："),s("code",[e._v("sentinel master master-name")]),e._v("：")]),e._v(" "),s("li",[e._v("通过主节点名查看其ip和端口号："),s("code",[e._v("sentinel get-master-addr-by-name master-name")])]),e._v(" "),s("li",[e._v("查看某从节点的信息：\n"),s("ul",[s("li",[s("code",[e._v("sentinel slaves slave-name")])]),e._v(" "),s("li",[s("code",[e._v("sentinel replicas slave-name")])])])]),e._v(" "),s("li",[e._v("强制故障转移："),s("code",[e._v("sentinel failover master-name")])])]),e._v(" "),s("h2",{attrs:{id:"三、集群模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、集群模式"}},[e._v("#")]),e._v(" 三、集群模式")]),e._v(" "),s("blockquote",[s("p",[e._v("Redis Cluster是3.0后推出的去中心化的集群方案。其通过将数据分为16384个槽分布到不同的服务器上，来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能，主要是针对"),s("strong",[e._v("海量数据+高并发+高可用")]),e._v("的场景。其特点是")]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("高读写性能")]),e._v("：主节点存在多个，可以多路写入，从节点提供读服务，读写分离。")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("高可用")]),e._v("：部分master不可用时，还是可以继续工作")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main//images/b74ff8b0-8579-11ea-ab1b-af991e0896fe-20220813145034902.png",alt:"image.png"}})])]),e._v(" "),s("h3",{attrs:{id:"_3-1-分布式寻址算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-分布式寻址算法"}},[e._v("#")]),e._v(" 3.1 分布式寻址算法")]),e._v(" "),s("p",[s("strong",[e._v("Hash算法")])]),e._v(" "),s("p",[e._v("来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致"),s("strong",[e._v("大部分的请求过来，全部无法拿到有效的缓存")]),e._v("，导致大量的流量涌入数据库。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimageshash.png",alt:""}})]),e._v(" "),s("p",[s("strong",[e._v("一致性 hash 算法")])]),e._v(" "),s("ol",[s("li",[e._v("将整个hash值空间虚拟成一个环，将master节点进行hash计算其在环上的位置")]),e._v(" "),s("li",[e._v("来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环"),s("strong",[e._v("顺时针“行走”")]),e._v("，遇到的第一个 master 节点就是 key 所在位置")]),e._v(" "),s("li",[e._v("如果一个节点挂了，那么只会影响这个节点上的部分数据。")])]),e._v(" "),s("p",[e._v("一致性hash算法在节点比较少的时候，容易因为节点分布不均匀而造成"),s("strong",[e._v("缓存热点")]),e._v("的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesconsistent-hashing-algorithm.png",alt:"consistent-hashing-algorithm"}})]),e._v(" "),s("p",[s("strong",[e._v("hash slot算法（槽位定位）")])]),e._v(" "),s("p",[e._v("Redis 集群总共的槽位数是 16384 个，每一个主节点负责维护一部分槽以及槽所映射的键值数据，Redis 集群默认会"),s("strong",[e._v("对要存储的 key 值使用 CRC16 算法进行 hash 得到一个整数值")]),e._v("，然后用这个整数值对 16384 进行取模来得到具体槽位，公式为：")]),e._v(" "),s("p",[s("code",[e._v("slot = CRC16(key) % 16383")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imageshash-slot.png",alt:"hash-slot"}})]),e._v(" "),s("h3",{attrs:{id:"_3-2-节点通信机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-节点通信机制"}},[e._v("#")]),e._v(" 3.2 节点通信机制")]),e._v(" "),s("blockquote",[s("p",[e._v("集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。"),s("strong",[e._v("集中式")]),e._v("是将集群元数据（节点信息、故障等等）集中存储在某个节点上。如Kafka中的zookeeper。")])]),e._v(" "),s("p",[s("strong",[e._v("集中式")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imageszookeeper-centralized-storage.png",alt:"zookeeper-centralized-storage"}})]),e._v(" "),s("p",[s("strong",[e._v("gossip 协议")])]),e._v(" "),s("p",[e._v("节点间通过开启10000+当前端口号的端口，用于内部的节点间通信，通过PING、PONG命令监测节点存活以及集群元数据交换，通过MEET命令添加新节点进入集群，当某个节点发现故障节点后，向其他节点发送FAIL命令通知其他节点进行检测和故障确定。")]),e._v(" "),s("ul",[s("li",[e._v("ping命令深入解析：\n"),s("ul",[s("li",[e._v("每个节点会周期性的选择5个最久没有通信的其它节点。如果发现某个节点通信延时达到了 "),s("code",[e._v("cluster_node_timeout / 2")]),e._v(" ，那么立即发送 ping。")]),e._v(" "),s("li",[e._v("每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 "),s("code",[e._v("3")]),e._v(" 个其它节点的信息，最多包含 "),s("code",[e._v("总节点数减 2")]),e._v(" 个其它节点的信息。")])])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesredis-gossip.png",alt:"Redis-gossip"}})]),e._v(" "),s("h3",{attrs:{id:"_3-3-故障发现转移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-故障发现转移"}},[e._v("#")]),e._v(" 3.3 故障发现转移")]),e._v(" "),s("p",[s("strong",[e._v("故障发现")]),e._v("：疑似下线 + 确定下线")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("正常情况下集群中节点会定期向其他节点发送PING确认其是否在线，如果规定时间内没有收到PONG，该节点会将其标记为疑似下线并向集群广播")])]),e._v(" "),s("li",[s("p",[e._v("其他节点收到广播后会向该节点发送PING，如果超过半数标记为疑似下线，则标记为确认下线并向集群广播")])]),e._v(" "),s("li",[s("p",[e._v("其他节点收到下线广播后，会立即对该节点进行主从切换（故障转移）")])])]),e._v(" "),s("p",[s("strong",[e._v("故障转移")])]),e._v(" "),s("ul",[s("li",[e._v("选择节点：从下线的主节点中选择一个从节点（根据新主节点选举原则）")]),e._v(" "),s("li",[e._v("切换模式：从节点执行"),s("code",[e._v("SLAVEOF NO ONE")]),e._v("命令，切换为主节点模式，保留原来同步的数据")]),e._v(" "),s("li",[e._v("重派槽点：新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己")]),e._v(" "),s("li",[e._v("通知集群：新的主节点向集群广播一条 PONG 消息，通知其他节点自己已经切换为主节点并且接管了槽位")]),e._v(" "),s("li",[e._v("正常处理：新的主节点开始处理相关的命令请求，此故障转移过程完成。")])]),e._v(" "),s("p",[s("strong",[e._v("新主节点选举")])]),e._v(" "),s("ul",[s("li",[e._v("每个主节点都有一票")]),e._v(" "),s("li",[e._v("当从节点发现自己正在复制的主节点确认下线之后，就会向集群广播一条消息，要求所有有投票权的主节点给自己投票")]),e._v(" "),s("li",[e._v("每个主节点会向第一个要求投票的从节点投票")]),e._v(" "),s("li",[e._v("从节点获票数超过主节点数的1/2，则选举成功，从节点晋升为主节点")])]),e._v(" "),s("p",[s("strong",[e._v("负载均衡")])]),e._v(" "),s("p",[e._v("在 Redis 集群负载不均衡的情况下，我们可以使用 rebalance 命令重新分配各个节点负责的槽数量，从而使得各个节点的负载压力趋于平衡，从而提高 Redis 集群的整体运行效率。")]),e._v(" "),s("p",[s("code",[e._v("redis-cli --cluster rebalance 127.0.0.1:30007")])]),e._v(" "),s("h2",{attrs:{id:"四、集群搭建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、集群搭建"}},[e._v("#")]),e._v(" 四、集群搭建")]),e._v(" "),s("h3",{attrs:{id:"_4-1-主从模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-主从模式"}},[e._v("#")]),e._v(" 4.1 主从模式")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://redis.io/topics/replication",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),s("OutboundLink")],1)])]),e._v(" "),s("h4",{attrs:{id:"搭建过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#搭建过程"}},[e._v("#")]),e._v(" 搭建过程")]),e._v(" "),s("ol",[s("li",[e._v("修改replica（从者redis）的"),s("code",[e._v("redis.conf")]),e._v("配置文件（有密码还需要配置replica连接master的密码）")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("# 设置master的IP及端口\nreplicaof [masterip] [port]\n\n# replica需要关闭集群的启动模式，否则会报异常\ncluster-enable no\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p"),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("重启replica的redis")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("进入redis的src目录下，执行"),s("code",[e._v("./redis-cli -a [password] -h [ip] -p [port] shutdown")]),e._v("关闭redis")])]),e._v(" "),s("li",[s("p",[e._v("使用"),s("code",[e._v("./redis-server ../redis.conf")]),e._v("命令重启redis服务器")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images53335008-4e3a3c00-3935-11e9-9242-a54805b0a827.png",alt:"image"}})]),e._v(" "),s("h3",{attrs:{id:"_4-2-集群模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-集群模式"}},[e._v("#")]),e._v(" 4.2 集群模式")]),e._v(" "),s("h4",{attrs:{id:"搭建过程-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#搭建过程-2"}},[e._v("#")]),e._v(" 搭建过程")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://redis.io/topics/cluster-tutorial",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis官方文档"),s("OutboundLink")],1),e._v("：（建议跟着文档走）")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.zybuluo.com/phper/note/195558",target:"_blank",rel:"noopener noreferrer"}},[e._v("大佬博客"),s("OutboundLink")],1)])]),e._v(" "),s("ol",[s("li",[s("p",[e._v("redis集群搭建前提，修改"),s("code",[e._v("redis.conf")]),e._v("配置文件，找到以下配置信息并做如下图修改：\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/52361189-a12c7c00-2a78-11e9-9048-4586d4a5783b.png",alt:"image"}})])]),e._v(" "),s("li",[s("p",[e._v("redis集群至少需要开启"),s("strong",[e._v("六个redis节点")]),e._v("，复制六个redis文件夹，在配置文件"),s("code",[e._v("redis.conf")]),e._v("中修改不同的端口号，分别进入src目录，执行命令"),s("code",[e._v("./redis.server ../redis.conf")]),e._v("，带配置文件启动redis。")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images52359928-d4b9d700-2a75-11e9-9579-2dbea872bab0.png",alt:"image"}})]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("p",[e._v("在阿里云服务器（个人使用的服务器）中开启端口号，如"),s("code",[e._v("6379/6384")]),e._v("（6379-6384），开启后还需要开启集群总线端口"),s("code",[e._v("16379/16384")]),e._v(" （16379-16384）,若未开启，在使用公网Ip进行集群搭建的时候会报错。\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images52360870-f3b96880-2a77-11e9-94ce-00c28f96b689.png",alt:"image"}})])]),e._v(" "),s("li",[s("p",[e._v("进入其中一个redis的src文件夹中，执行命令"),s("code",[e._v("./redis-cli -a password --cluster create xxx.xx.xxx.xx:6379 xxx.xx.xxx.xx:6380 xxx.xx.xxx.xx:6381 xxx.xx.xxx.xx:6382 xxx.xx.xxx.xx:6383 xxx.xx.xxx.xx:6384 --cluster-replicas 1")]),e._v("创建集群，出现提示信息，输入"),s("code",[e._v("yes")]),e._v("后没有报异常则创建成功（如果已经创建过集群，需要先将每个redis的src目录下的"),s("code",[e._v("nodes.conf")]),e._v("删除，否则会有异常）。")])]),e._v(" "),s("li",[s("p",[e._v("创建成功后，可在redis的src目录下执行命令"),s("code",[e._v("./redis-cli -a password --cluster fix xxx.xx.xxx.xx:6379")]),e._v("进行检查。(下图表示创建成功)\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images52361803-0df44600-2a7a-11e9-8ad9-fb75bda8c15a.png",alt:"image"}})])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("如果是重新创建集群")]),e._v("，即使删除"),s("code",[e._v("nodes.conf")]),e._v("文件后可能创建的集群所有的slot没有被覆盖，需要在其中一个redis的src目录下执行命令"),s("code",[e._v("./redis-cli -a password --cluster fix xxx.xx.xxx.xx:6379")]),e._v("进行修复。")])])]),e._v(" "),s("p"),e._v(" "),s("h4",{attrs:{id:"异常与解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常与解决"}},[e._v("#")]),e._v(" 异常与解决")]),e._v(" "),s("p",[s("strong",[e._v("SpringBoot使用redis集群出现的异常")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("SpringBoot连接redis：")]),e._v(" "),s("ul",[s("li",[e._v("https://blog.csdn.net/lx1309244704/article/details/80696235")]),e._v(" "),s("li",[e._v("https://www.jianshu.com/p/b75e0d45b5e2")])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常1")]),e._v("：在SpringBoot进行Redsi集群连接的时候报"),s("code",[e._v("ERR This instance has cluster support disabled")])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：Redis配置文件没有开启集群模式，在redis.conf中找到"),s("code",[e._v("cluster-enabled yes")]),e._v("并将其注释去掉。https://blog.csdn.net/z960339491/article/details/80521851")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常2")]),e._v("：SpringBoot2.x连接redis集群时出现"),s("code",[e._v("CLUSTERDOWN The cluster is down")]),e._v("或者"),s("code",[e._v("Node .. is not empty.Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.")]),e._v("，一般出现在创建过集群然后重新创建的时候报的异常")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：需要删除redis的src目录下的"),s("code",[e._v("nodes.conf")]),e._v("文件，然后重新创建集群。")])])]),e._v(" "),s("p"),e._v(" "),s("p",[s("strong",[e._v("Linux服务器搭建redis集群时出现的异常")])]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("异常1")]),e._v("：使用SpringBoot2.x（lettuce redis客户端）整合redis，报异常："),s("code",[e._v("can not connect to 127.0.0.1：6379...")]),e._v("，连接不上集群")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：在进行集群创建的时候，使用"),s("code",[e._v("./redis-cli -a password --cluster create xxx.xx.xxx.xx:6379 xxx.xx.xxx.xx:6380 xxx.xx.xxx.xx:6381 xxx.xx.xxx.xx:6382 xxx.xx.xxx.xx:6383 xxx.xx.xxx.xx:6384 --cluster-replicas 1")]),e._v("进行创建的时候，需要用其"),s("code",[e._v("公网IP")]),e._v("进行创建")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常2")]),e._v("：进行redis集群创建的时候（公网IP创建），报"),s("code",[e._v("Waiting for the cluster to join ...")])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：开放其集群通讯端口，如集群使用的是6379-6384，则还需要再开放16379-16384端口，在阿里云防火墙进行开放，否则会一直无法创建--https://blog.csdn.net/Truong/article/details/52531103")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常3")]),e._v("：使用"),s("code",[e._v("redis-cli --cluster check 127.0.0.1:6379")]),e._v("进行集群检查后，检查到"),s("code",[e._v("[ERR] Not all 16384 slots are covered by nodes.")]),e._v("（可能出现在集群有所更换之后）")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：在redis的src目录下运行"),s("code",[e._v("./redis-cli -a password --cluster fix 172.168.63.201:7001")]),e._v("--https://blog.csdn.net/vtopqx/article/details/50235891 （redis5.0后使用redis-cli --cluster   check 127.0.0.1:6379等）")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常4")]),e._v("：配置从节点redis的"),s("code",[e._v("redis.conf")]),e._v("文件的"),s("code",[e._v("replicaof")]),e._v("指令后创建集群，报"),s("code",[e._v("replicaof directive not allowed in cluster mode")]),e._v("异常")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("解决")]),e._v("：如果是创建集群的话，需要注释掉"),s("code",[e._v("replicaof")]),e._v("的配置（本人为replica配置处配置了redis密码，这似乎使得主从复制成功了）")])])]),e._v(" "),s("p"),e._v(" "),s("p",[s("strong",[e._v("参考文献")])]),e._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/ivictor/p/9768010.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis集群相关指令-1"),s("OutboundLink")],1)])]),e._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis集群相关指令-2"),s("OutboundLink")],1)])]),e._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://russellluo.com/2018/07/redis-replication-demystified.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("redis集群详解"),s("OutboundLink")],1)])])]),e._v(" "),s("h2",{attrs:{id:"五、参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、参考"}},[e._v("#")]),e._v(" 五、参考")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/40%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考一"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=a.exports}}]);