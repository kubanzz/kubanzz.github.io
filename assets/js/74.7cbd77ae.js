(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{402:function(s,t,e){"use strict";e.r(t);var a=e(12),n=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"为什么redis这么快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么redis这么快"}},[s._v("#")]),s._v(" 为什么Redis这么快")]),s._v(" "),t("h2",{attrs:{id:"一条redis命令的执行过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一条redis命令的执行过程"}},[s._v("#")]),s._v(" 一条Redis命令的执行过程")]),s._v(" "),t("ul",[t("li",[s._v("参考："),t("a",{attrs:{href:"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/01%20Redis%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.md",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis的执行过程"),t("OutboundLink")],1)])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122545.png",alt:"image.png"}})]),s._v(" "),t("ol",[t("li",[s._v("连接建立")])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis包括客户端与服务端，客户端发送相关执行，服务端负责接收、解析并执行。通常Redis客户端和服务端都在不同的服务器上，Redis基于Socket进行网络通信，采用IO多路复用模型进行Socket连接管理。")])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("I/O 多路复用")]),s._v("：Redis 使用的是 I/O 多路复用功能来监听多 Socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122546.png",alt:"IO多路复用.png"}})])]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[s._v("客户端发送命令：封装RESP协议")])]),s._v(" "),t("blockquote",[t("p",[s._v("用户发送命令，客户端会将命令封装成RESP协议（Redis的通信协议），接着通过Socket进行发送。通过协议服务端和客户端之间可以快速理解通信内容。")])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("Socket 小知识")]),s._v("：每个 Socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。")])]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[s._v("服务端接收命令：解析RESP协议")])]),s._v(" "),t("blockquote",[t("p",[s._v("数据大小验证：服务器会先去输入缓冲中读取数据，如果数据量大于1G则关闭客户端连接。")]),s._v(" "),t("p",[s._v("协议解析：数据大小验证通过后，解析协议并且提取出指令存放在Client对象中（服务端为每个连接创建一个Client对象）")])]),s._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[s._v("执行前的验证准备")])]),s._v(" "),t("blockquote",[t("ol",[t("li",[t("p",[t("strong",[s._v("用户权限校验")]),s._v("：未通过身份验证的用户只能执行AUTH(授权) 命令")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("集群相关校验")]),s._v("：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("目标节点重定向：如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；")])]),s._v(" "),t("li",[t("p",[s._v("从节点状态效验：当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；")])]),s._v(" "),t("li",[t("p",[s._v("只读从节点验证：当此服务器为只读从节点时，只接受 master 的写命令；")])])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("内存校验")]),s._v("：如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作（引出Redis的缓存清除机制及缓存淘汰算法）；")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("持久化检测")]),s._v("：检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("事物检验")]),s._v("：如果执行的是事务命令，则开启事务把命令放入等待队列；")])])])]),s._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[s._v("执行最终命令，调用 redisCommand 中的 proc 函数执行命令。")]),s._v(" "),t("li",[s._v("执行完后的相关记录和统计")])]),s._v(" "),t("blockquote",[t("ol",[t("li",[s._v("检查慢查询是否开启，如果开启会记录慢查询日志；")]),s._v(" "),t("li",[s._v("检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；")]),s._v(" "),t("li",[s._v("检查持久化功能是否开启，如果开启则会记录持久化信息；")]),s._v(" "),t("li",[s._v("如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。")])])]),s._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[s._v("返回结果给客户端")])]),s._v(" "),t("h4",{attrs:{id:"redis的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的应用场景"}},[s._v("#")]),s._v(" Redis的应用场景？")]),s._v(" "),t("p",[t("strong",[s._v("已用")])]),s._v(" "),t("ul",[t("li",[s._v("缓存热点数据，缓解数据库压力：统计信息、基础用户信息、基础设施信息\n"),t("ul",[t("li",[s._v("缓存击穿场景如何处理？")])])]),s._v(" "),t("li",[s._v("幂等性处理（引出Kafka）\n"),t("ul",[t("li",[s._v("四种解决幂等方案："),t("a",{attrs:{href:"https://juejin.cn/post/6906290538761158670",target:"_blank",rel:"noopener noreferrer"}},[s._v("链接"),t("OutboundLink")],1)]),s._v(" "),t("li",[s._v("卡口车辆驶入，会出现重复消费的问题吗？会有的\n"),t("ul",[t("li",[s._v("比如卡口对同一辆车可能会传多份照片")]),s._v(" "),t("li",[s._v("Kafka是auto commit机制\n"),t("ul",[t("li",[s._v("如果消费者还没来得及commit就重启，重启后会从kafka拉取未过更新的offset，则会造成重复消费。")]),s._v(" "),t("li",[s._v("如果commit了，但是MQ宕机导致接收不到，则重启后会重复消费")])])])])])])]),s._v(" "),t("li",[s._v("*bitmap统计设备是否在线，减少数据库压力")])]),s._v(" "),t("p",[t("strong",[s._v("其他")])]),s._v(" "),t("ul",[t("li",[s._v("简单消息队列：使用Redis自身的发布/订阅模式或者List来实现简单的消息队列，实现异步操作。")]),s._v(" "),t("li",[s._v("分布式锁：利用redis的原子性命令setnx")]),s._v(" "),t("li",[s._v("好友关系：利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。")])]),s._v(" "),t("h4",{attrs:{id:"redis应用到了哪些数据结构-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis应用到了哪些数据结构-缓存"}},[s._v("#")]),s._v(" *Redis应用到了哪些数据结构（缓存）？")]),s._v(" "),t("ul",[t("li",[s._v("已用：\n"),t("ul",[t("li",[s._v("String（缓存统计数据，提高读性能）")])])])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis的String数据结构称为"),t("strong",[s._v("SDS对象")]),s._v("，包括了整形和字符串，底层采用"),t("strong",[s._v("int、emstr、raw")]),s._v("三种数据结构分别对不同长度的字符串申请相应的存储类型，从而有效的节约了空间。")]),s._v(" "),t("ul",[t("li",[s._v("int：整型数据")]),s._v(" "),t("li",[s._v("emstr：字符串并且长度小于44字节")]),s._v(" "),t("li",[s._v("raw：字符串并且长度大于44字节（即SDS对象大于64byte）")])])]),s._v(" "),t("blockquote",[t("p",[s._v("为什么是44字节而不是64？")]),s._v(" "),t("p",[s._v("因为Redis中每个对象都会包含一个redisObject 对象头，该对象头结构如下：")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 总共占用16bytes")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("typedef")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("redisObject")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" type"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 4 bit，对象的数据类型")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" encoding"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 4 bit，对象的数据编码")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" lru"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("LRU_BITS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 3 个字节，最近最少使用信息，内存回收时会用到")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" refcount"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 4 个字节，引用计数器")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("ptr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 8 个字节，对象指针，指向具体的内容")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" robj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("除了redisObject对象头外，SDS对象还包含自己的数据结构，包括已使用长度、总长度等属性，减完用于存储数据的内存就剩下44bytes。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220807225006177.png",alt:"image-20220807225006177"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("常用场景：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("页面数据缓存：减少数据库操作，提供性能")])]),s._v(" "),t("li",[t("p",[s._v("数字计算与统计：原子性操作")])]),s._v(" "),t("li",[t("p",[s._v("共享数据：如Session共享")])]),s._v(" "),t("li",[t("p",[s._v("分布式锁：原子性set")])])])]),s._v(" "),t("blockquote",[t("p",[s._v("常用的指令：")]),s._v(" "),t("ul",[t("li",[s._v("set k1 1000  val1")]),s._v(" "),t("li",[s._v("incrby k3 5：对k3的值+5")]),s._v(" "),t("li",[s._v("incr k1：对k1对值自增")])])]),s._v(" "),t("ul",[t("li",[s._v("字典-底层基于哈希实现（服务区的map作为缓存）\n"),t("ul",[t("li",[s._v("参考："),t("a",{attrs:{href:"https://juejin.cn/post/6987016272143712263",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考一"),t("OutboundLink")],1)])])])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis中的字典底层采用哈希表实现")]),s._v(" "),t("ul",[t("li",[s._v("ht：包含两个哈希表h0和h1，h1只有在rehash的时候被分配空间使用。\n"),t("ul",[t("li",[s._v("dicht：\n"),t("ul",[t("li",[s._v("table：哈希表包含key和value，底层采用"),t("strong",[s._v("数组+链表")]),s._v("的方式进行存储，数组用于哈希索引查找元素存储，链表用于解决哈希冲突问题。")]),s._v(" "),t("li",[s._v("size：当前的哈希表中的大小")]),s._v(" "),t("li",[s._v("sizemask：用于哈希计算下标索引")]),s._v(" "),t("li",[s._v("used：当前的元素大小")])])])])]),s._v(" "),t("li",[s._v("rehashidx：记录当前rehash的下标，-1表示没有开启rehash，其他表示正在rehash")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesba21aa268514476dac59388ea1fb7089~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp",alt:"img"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("常用场景：")]),s._v(" "),t("ul",[t("li",[s._v("存储用户信息")]),s._v(" "),t("li",[s._v("存储用户购物车信息")]),s._v(" "),t("li",[s._v("存储服务区的基础信息")])])]),s._v(" "),t("blockquote",[t("p",[s._v("渐进式扩容：")]),s._v(" "),t("p",[s._v("由于Redis是采用单线程进行任务处理的，如果同时大数据量的字典的rehash，会导致服务很长时间无法提供服务，为了避免这种情况的发生，Redis采用渐进式rehash的方式。当需要进行扩容操作时，为h1分配内存空间，并且将字典的rehashidx置为0，增量式的将h0的元素rehash到h1，每完成一个rehashidx+1，直到所有元素都被rehash到h1中。在此过程中，get操作会在h0和h1之间进行查找，put操作会直接put到h1，当完成h0的rehash后，将h0指向h1，将h1置为null。该思想类似于写时复制的思想，例如Java中的CopyOnWriteArrayList。")])]),s._v(" "),t("ul",[t("li",[s._v("List（卡口基本数据）")])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis中的List结构是一个有序链表，底层采用**ziplist（压缩列表）"),t("strong",[s._v("和")]),s._v("quicklist（快速列表）**实现，当元素比较少的时候，采用ziplist存储，ziplist会开辟一块连续的内存块，减少元素前后指针带来的内存消耗。如果元素比较多，则采用将ziplist转化为qickklist并采用双向链表存储，而qucklistNode本质上就是一个ziplist。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-31230.png",alt:"列表类型使用-quicklist结构图.png"}})]),s._v(" "),t("p",[s._v("ziplist：")]),s._v(" "),t("ul",[t("li",[s._v("zlbytes：压缩列表字节长度，占 4 字节")]),s._v(" "),t("li",[s._v("zllen：压缩列表的元素个数")]),s._v(" "),t("li",[s._v("entryX：压缩列表存储的所有元素，可以是字节数组或者是整数")]),s._v(" "),t("li",[s._v("zlend：压缩列表的结尾，占 1 字节")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-031231.png",alt:"列表类型使用-压缩列表结构图.png"}})]),s._v(" "),t("p",[s._v("quicklist添加元素的过程：")]),s._v(" "),t("p",[s._v("我的理解是，会先判断当前是否为ziplist存储，如果是就在头节点插入，否则创建新的quicklistNode插入。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-031232.png",alt:"列表类型使用-插入流程图.png"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("常用场景：")]),s._v(" "),t("ul",[t("li",[s._v("消息队列：lpush、rpop可以实现左进右出")]),s._v(" "),t("li",[s._v("文章列表：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。")])])]),s._v(" "),t("blockquote",[t("p",[s._v("常用指令：")]),s._v(" "),t("ul",[t("li",[s._v("查找指定区间元素：lrange key start stop（-1代表到结尾）")]),s._v(" "),t("li",[s._v("从链表左边添加元素：lpush key value1")]),s._v(" "),t("li",[s._v("从链表右边取出元素：rpop key")])])]),s._v(" "),t("p",[s._v("Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。特点是可表达内容少，但是占用空间极低，可以用于统计用户是否在线，设备是否在线等。")]),s._v(" "),t("ul",[t("li",[s._v("未用：\n"),t("ul",[t("li",[s._v("SortedSet：有序Set。内部维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。\n"),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6983810713055658015#heading-13",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考一"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/14%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考二"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844903446475177998#heading-8",target:"_blank",rel:"noopener noreferrer"}},[s._v("*参考三"),t("OutboundLink")],1)])])])])])]),s._v(" "),t("blockquote",[t("p",[s._v("SortedSet是一个有序集合，其存储元素相当于由两个值组成的，一个是集合的元素值，一个是排序值。有序集合"),t("strong",[s._v("ZSet")]),s._v("底层采用 "),t("strong",[s._v("ziplist（压缩链表）"),t("strong",[s._v("或")]),s._v("字典（哈希）")]),s._v("+ "),t("strong",[s._v("zskiplist (跳跃表)")]),s._v(" 组成的。元素数量小于128并且长度都小于64字节，则采用压缩链表，否则采用字典+跳跃表。与Java中的HashMap的链表转红黑树的思想类似，n值比较小时以时间换空间，因为时间可控，n大于某个阈值，则采用空间换时间策略。")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("压缩链表："),t("a",{attrs:{href:"https://juejin.cn/post/6844903438510194695",target:"_blank",rel:"noopener noreferrer"}},[s._v("ziplist"),t("OutboundLink")],1),s._v("是一个经过特殊编码的双向链表，它的设计目标就是为了节约内存，但是查找需要顺序查找，即时间复杂度为O(n)。")])]),s._v(" "),t("li",[t("p",[s._v("字典表：key-vale对应obj-score，查找某元素的排序的时候，可以先通过字典表查找到score，再通过跳表查询对应的元素。")])]),s._v(" "),t("li",[t("p",[s._v("跳表：zskiplist包含头指针和尾指针zskiplistNode，分别指向元素头节点和尾节点，并且包含length和level属性。")]),s._v(" "),t("ul",[t("li",[s._v("length属性：元素个数")]),s._v(" "),t("li",[s._v("level属性：该跳表最大的层数")]),s._v(" "),t("li",[s._v("zskiplistNode：即元素，zskiplistNode包含object、score及level数组，每个元素生成的时候会根据Redis提供的算法随机生成level，level即元素的层数（比如7即代表该元素在1-7层），各个层数通过指针形成单向链表。在Redis中level的最大长度为32，")])]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// level随机生成算法如下，从概率学上，其保证了产生越高的层数概率越低，保证平均时间为log(n)")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("MaxLevel")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("32")]),s._v("\np "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.25")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("randomLevel")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    level "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// random()返回一个[0...1)的随机数")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("random")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" p and level "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("MaxLevel")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v("\n        level "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" level "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" level\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])])])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesb9c4c86dd4b74d0fbfc2619e6d319f74~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp",alt:"image-20210705150306846"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images9b97ffa5afac0f5f3ba7.png~tplv-t2oaga2asx-zoom-crop-mark%3A3024%3A3024%3A3024%3A1702.awebp",alt:"Redis 为什么用跳表而不用平衡树？"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("常用的应用场景：")]),s._v(" "),t("ul",[t("li",[s._v("学生成绩排名")]),s._v(" "),t("li",[s._v("粉丝列表，根据关注的先后时间排序")])])]),s._v(" "),t("blockquote",[t("p",[s._v("常用的指令有：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("添加元素："),t("code",[s._v("zadd key 5 redis 10 java")])])]),s._v(" "),t("li",[t("p",[s._v("查找区间元素："),t("code",[s._v("zrange key minscore maxscore")])])]),s._v(" "),t("li",[t("p",[s._v("查找元素排序（索引）："),t("code",[s._v("zrank key redis")])])]),s._v(" "),t("li",[t("p",[s._v("查找元素分数："),t("code",[s._v("zscore key redis")])])])])]),s._v(" "),t("blockquote",[t("p",[s._v("skiplist（跳表）的实现原理：")]),s._v(" "),t("p",[s._v("跳表是一种可以进行二分查找的有序链表，底层实现是在原有的"),t("strong",[s._v("有序链表")]),s._v("上面增加了"),t("strong",[s._v("多级索引")]),s._v("，通过索引来实现快速查找，其查找、插入、删除的时间复杂度都为log(n)，因为需要维护索引。跳表的特点是效率高、实现简单。查找过程是"),t("strong",[s._v("从上层索引往下查找，每次都找到最后一个小于查找值的元素，然后往下级索引查找，直到找到元素")]),s._v("。在Redis中，有序集合中对socre进行排序存储，涉及到对有序列表的查询，故采用跳表。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimages2020-02-28-031228.png",alt:"有序集合-跳跃表.png"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis为什么用skiplist而不用平衡树？（来自Redis的作者）")]),s._v(" "),t("ol",[t("li",[s._v("内存占用上跳表更可控，可以通过设置maxlevel控制索引层数。")]),s._v(" "),t("li",[s._v("性能上跳表拥有跟其他平衡树类差不多的性能。")]),s._v(" "),t("li",[s._v("实现难度上跳表逻辑及实现更加简单。")])])]),s._v(" "),t("ul",[t("li",[s._v("Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。")])]),s._v(" "),t("blockquote",[t("p",[s._v("Set是一个无序集合，其存储的元素都是唯一的，不会有重复元素。Set底层采用"),t("strong",[s._v("intset (整数集合)")]),s._v(" 或 "),t("strong",[s._v("字段表 (普通哈希表)")]),s._v(" 进行存储，"),t("strong",[s._v("只有在元素都为整数，并且元素数量小于512的时候使用intset")]),s._v("，其他的采用HashTable（key为值，value为null）。")])]),s._v(" "),t("blockquote",[t("p",[s._v("常见的应用场景有：")]),s._v(" "),t("ul",[t("li",[s._v("用户标签：可以基于"),t("code",[s._v("sunion")]),s._v("指令获取用户间的共同爱好")]),s._v(" "),t("li",[s._v("抽奖系统：set可以存储不重复的人员，通过"),t("code",[s._v("spop key nums")]),s._v("可以随机抽取并移除三名人员，"),t("code",[s._v("srandmember key nums")]),s._v("则是随机抽取三人，但是不移除。")])])]),s._v(" "),t("blockquote",[t("p",[s._v("常用的指令有：")]),s._v(" "),t("ul",[t("li",[s._v("交集："),t("code",[s._v("sinter")])]),s._v(" "),t("li",[s._v("并集："),t("code",[s._v("sunion")])]),s._v(" "),t("li",[s._v("错集："),t("code",[s._v("sdiff")])])])]),s._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://blog.csdn.net/ldw201510803006/article/details/123515390",target:"_blank",rel:"noopener noreferrer"}},[s._v("insert和hashtable的区别"),t("OutboundLink")],1),s._v("：inset底层采用有序整数存储，时间复杂度上查找元素为logn（二分查找），增加和删除为On（需要移动元素），而hashtable都是O1，时间上hashtable快于inset，而空间上inset优于hashtable（key-value存储，value为null），所以inset是一种时间换空间的结构。")])]),s._v(" "),t("h4",{attrs:{id:"redis的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的原理"}},[s._v("#")]),s._v(" Redis的原理")]),s._v(" "),t("ol",[t("li",[s._v("Redis中的key有时间限制，你觉得是怎么实现的？")])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis中的定时策略可以根据用户定制的时间保证键值对过期失效，底层采用字典表实现，Redis维护了一个"),t("strong",[s._v("过期字典表")]),s._v("，key为用户的key，value即为过期时间。当用户请求键值的时候，流程如下：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images3bf71ae0-5de7-11ea-9e57-957b6467a3fc.png",alt:"内存过期策略-过期键判断流程.png"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis的过期策略：")]),s._v(" "),t("p",[s._v("由于Redis是单线程的框架，如果直接对所有过期键值进行清除，会导致服务一段时间无法提供服务，为了避免这种情况发生，redis提供了多种过期策略，主要以下三种，Redis默认采用第二+第三种。")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("定时全量删除：定时扫描并删除所有过期键值，可以快速释放内存，但是数量量大时会导致服务卡顿。")])]),s._v(" "),t("li",[t("p",[s._v("惰性删除：用户访问键值时再检查是否过期，过期则删除。")])]),s._v(" "),t("li",[t("p",[s._v("定时随机删除：定时随机检查部分键值是否过期，过期则删除，Redis中默认每10秒扫描一次，并且扫描策略如下，为了防止死循环，规定了扫描时间不超过25ms。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesc511d450-5de7-11ea-a9fa-c1c510366b3a.png",alt:"内存过期策略-执行流程2.png"}})])])])]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[s._v("Redis的持久化原理")])]),s._v(" "),t("blockquote",[t("p",[s._v("由于Redis在内存中做数据操作，为了保证服务器重启时数据不丢失，Redis提供了两种持久化机制（Redis的持久化过程都是通过fork新的线程异步执行），分别为AOF（appendonly.aof）和RDB（dump.rdb），两者的区别如下：")]),s._v(" "),t("ul",[t("li",[s._v("文件格式不同：AOF存储的是键值操作的命令，以文件追加的方式添加到AOF文件中，所以文件会比较大。而RDB存储的是某时刻的内存快照，将当前数据以二进制文件存储并写入磁盘，相对文件比较小。\n"),t("ul",[t("li",[s._v("AOF文件恢复速度比较慢，但是可读性好，容易修复，而且增量的方式更加轻量。")]),s._v(" "),t("li",[s._v("RDB文件则恢复速度快，但是每次都需要持久化整块内存快照，所以在数据量较大而且CPU性能不佳时会导致服务停顿。")])])]),s._v(" "),t("li",[s._v("持久化时间不同：AOF默认每秒将命令追加到AOF文件中，即使服务重启也只会丢失一秒内的操作，而RDB由于是对内存快照的复制，不能像AOF那样进行增量增加，所以通常是隔一段时间进行持久化存储，这就导致RDB模式下容易丢失某段时间内的数据。")]),s._v(" "),t("li",[s._v("恢复程度不同：如果不小心调用了flushall命令，由于AOF是文件追加方式，可以通过删除flushall命令还原，而RDB是基于内存快照，会导致所有数据被清空。")])]),s._v(" "),t("p",[s._v("AOF和RDB除了自动触发外，也可以通过手动触发：")]),s._v(" "),t("ul",[t("li",[s._v("save：同步持久化，阻塞主线程")]),s._v(" "),t("li",[s._v("bgsave：异步持久化，通过fork命令创建子线程，而fork也会消耗一定的内存")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122534.png",alt:"image.png"}})])]),s._v(" "),t("blockquote",[t("p",[s._v("AOF重写机制")]),s._v(" "),t("p",[s._v("由于AOF以文件追加方式添加到AOF文档，为了解决文档过大的问题，Redis提供了文件重写功能，当达到一定的文件大小（默认为60M），则重写当前文件，并把当前数据的最少操作命令保存到新文件上，从而减少文件大小。")])]),s._v(" "),t("blockquote",[t("p",[s._v("AOF和RDB混合持久化")]),s._v(" "),t("p",[s._v("由于AOF和RDB各有弊端，AOF文件过大时会影响启动速度，RDB会有一段时间的数据丢失，为了同时能用到AOF和RDB的优点，Redis4.0后新增了混合持久化的方式，在混合持久化的模式下，AOF在重写时会把Redis的持久化数据，以RDB的格式进行存储，并且将接下来的持久化以AOF格式追加到文件末尾。开头为RDB文件，使得Redis能够快速启动，同时又结合了AOF的优点，避免了大量数据丢失的风险。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122549.png",alt:"image.png"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122601.png",alt:"image.png"}})])]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[s._v("Redis的存储原理")]),s._v(" "),t("ol",[t("li",[s._v("新增节点哈希槽会如何变化？")])]),s._v(" "),t("blockquote",[t("p",[s._v("新增节点后需要重新分配槽点，这个需要进行手动分配，我们可以通过reshard命令指定分配多少个槽点到某个节点，redis会从其他节点中分配对应的槽点到新节点。删除节点也一样，删除前需要将槽点reshard到其他节点上再进行删除。")]),s._v(" "),t("p",[s._v("添加新节点：")]),s._v(" "),t("ul",[t("li",[s._v("添加主节点，添加从节点")]),s._v(" "),t("li",[s._v("从其他节点分配槽点到新增节点（source 其他节点-all，to 新节点的ID，cluster node命令获取ID）")])]),s._v(" "),t("p",[s._v("删除节点：")]),s._v(" "),t("ul",[t("li",[s._v("删除从节点")]),s._v(" "),t("li",[s._v("将槽点迁移到其他节点（source 要删除的节点，to 另外节点或者all）")]),s._v(" "),t("li",[s._v("删除主节点")])])]),s._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[s._v("哈希槽是如何存储的？")])]),s._v(" "),t("blockquote",[t("p",[s._v("个人认为哈希槽是以字典方式存储的，key为master节点id，value为对应槽点的set集合，当客户端请求某个节点上的数据，该节点会计算槽点并查看是否为自己管理的，不是则查找自己的元数据中目标槽对应的节点Id，包装在MOVE命令中并返回，客户端重新发送。")])])])]),s._v(" "),t("h4",{attrs:{id:"redis的集群模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的集群模式"}},[s._v("#")]),s._v(" Redis的集群模式")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/40%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89.md",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考一"),t("OutboundLink")],1)])]),s._v(" "),t("p",[t("strong",[s._v("主从模式")])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("主从模式")])]),s._v(" "),t("p",[s._v("主从模式是一种“读写分离”思想的实现。Redis单机大概能支撑几万的qps，而主从模式可以大大提高其读并发性能，主从模式通常是一主多从，主节点负责写操作和将数据复制到其他从节点，从节点负责读操作，本质上就是读写分离。主从模式下的Redis有以下特点：")]),s._v(" "),t("ul",[t("li",[s._v("高并发（读写分离）")]),s._v(" "),t("li",[s._v("高可用（主从切换）")]),s._v(" "),t("li",[s._v("高可靠（从备份数据）")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main//images/imagesredis-master-slave.png",alt:"Redis-master-slave"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("数据同步")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication.png",alt:"Redis-master-slave-replication"}})]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("全量复制")]),s._v("：当有新的从服务器连接时，为了保障多个数据库的一致性，主服务器会执行一次 "),t("code",[s._v("bgsave")]),s._v(" 命令生成一个 RDB 文件，然后再以 Socket 的方式发送给从服务器，从服务器收到 RDB 文件之后再把所有的数据加载到自己的程序中，就完成了一次全量的数据同步。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("增量复制")]),s._v("：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("2.8之前：从服务器掉线重连后，主服务器都会进行一次完整的数据同步，如果掉线时间比较短，那么这种方式是非常不划算的。")])]),s._v(" "),t("li",[t("p",[s._v("2.8之后：当从服务器掉线后，主服务器会把离线后的写入命令，存储在一个特定大小的队列中，队列可以保证先进先出的顺序，当从服务器重写恢复上线之后，主服务会判断离线这段时间内的命令是否还在队列中，如果在就直接把队列中的数据发送给从服务器，这样就避免了完整同步的资源浪费。")]),s._v(" "),t("blockquote",[t("p",[s._v("存储离线命令的队列大小默认是 1MB，可以修改队列大小的配置项 repl-backlog-size。")])])])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("无盘同步")]),s._v("：当新的从节点加入时，主服务器会通过bgsave在本地生成RDB文件发送给从服务器，从服务器会先将RDB文件持久化到磁盘再读取，由于磁盘操作非常慢，为了解决这一问题，在2.8.18后增加了无盘复制功能，其特点是RDB文件不需要存入磁盘，而是由子线程生成数据内容通过socket直接发送到从服务器，这样主服务器可以避免磁盘写入与读取的过程，提高同步性能。")]),s._v(" "),t("blockquote",[t("p",[s._v("无盘复制默认是开闭的，需要通过配置"),t("code",[s._v("repl-diskless-sync")]),s._v("为yes开启")])])])]),s._v(" "),t("p",[t("strong",[s._v("完整流程")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication-detail.png",alt:"Redis-master-slave-replication-detail"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("常用命令")])]),s._v(" "),t("ul",[t("li",[t("p",[t("code",[s._v("replicaof host port")]),s._v("：配置从节点")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("replicaof no one")]),s._v("：关闭从节点")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("role")]),s._v("：查看当前节点角色")])])])]),s._v(" "),t("p",[t("strong",[s._v("哨兵模式")])]),s._v(" "),t("blockquote",[t("p",[s._v("哨兵模式是一种自动容灾技术，可以避免手动切换服务器带来的弊端。Redis的实现方式是搭建一个sentinel集群，通过每秒一次ping命令的频率监听当前的主从模式的节点（默认超过30秒则认为下线），假如当前的sentinel节点有五个，quorum配置为3，那么当超过3个sential节点监测到主节点下线（主观认为），则客观认为主节点掉线，此时会启动故障转移。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main//images/91c09780-8574-11ea-a330-69dc969564d3-20220813125936520.png",alt:"哨兵模式-多哨兵.png"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("Sentinel集群搭建")])]),s._v(" "),t("ol",[t("li",[t("p",[s._v("配置"),t("code",[s._v("sentinel.conf")]),s._v("文件，如监听的master ip、端口和密码")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("sentinel monitor mymaster 127.0.0.1 6379 1\nsentinel auth-pass mymaster pwd654321\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("启动sentinel")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 通过以下命令可以启动sentinel，当多个sentinel监听同个master时会相互识别，形成sentinel\n./src/redis-sentinel sentinel.conf\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])])])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("主从节点竞选")])]),s._v(" "),t("p",[s._v("故障转移即剔除掉线的主节点，从从节点中竞选主节点，竞选过程主要参照以下两个指标：")]),s._v(" "),t("ul",[t("li",[s._v("优先级：即节点的权重，可以通过"),t("code",[s._v("replica-priority")]),s._v("配置，值越小则优先级越高。")]),s._v(" "),t("li",[s._v("偏移量：即从节点数据同步情况，偏移量越大则说明数据同步度更高，优先级也越高。")])]),s._v(" "),t("p",[s._v("故障转移过程重点有以下步骤：")]),s._v(" "),t("ul",[t("li",[s._v("从节点排除\n"),t("ul",[t("li",[s._v("排除掉线的从节点")]),s._v(" "),t("li",[s._v("排除长时间没有跟主几点通信的从节点")]),s._v(" "),t("li",[s._v("排除优先级为0的从节点")])])]),s._v(" "),t("li",[s._v("主节点竞选\n"),t("ul",[t("li",[s._v("优先级高的从节点优先")]),s._v(" "),t("li",[s._v("优先级一样，则偏移量高的从节点优先")]),s._v(" "),t("li",[s._v("优先级和偏移量一样，则选择 Redis 运行时随机生成 ID 最小那个为新的主服务器")])])]),s._v(" "),t("li",[s._v("旧的主节点恢复：会作为新的从节点存在，并且清空数据，同步新的主节点的数据")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("主备切换导致数据丢失")])]),s._v(" "),t("ul",[t("li",[s._v("异步复制导致数据丢失（宕机）")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/async-replication-data-lose-case.png",alt:"async-replication-data-lose-case"}})]),s._v(" "),t("ul",[t("li",[s._v("脑裂导致的数据丢失（网络问题）")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/redis-cluster-split-brain.png",alt:"Redis-cluster-split-brain"}})]),s._v(" "),t("p",[t("strong",[s._v("数据丢失的解决方案")])]),s._v(" "),t("p",[s._v("下面配置表示：至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。这个配置可以保证主节点超过十秒的数据至少被从节点同步过了，否则主节点拒绝接收写入命令。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 超过十秒的主数据\nmin-slaves-max-lag 10\n// 至少被同步到一台从服务器上\nmin-slaves-to-write 1\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("这个配置可以将上述的两个问题导致的数据丢失都控制在10秒内，也就是保证丢失的数据是可控的。")])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("哨兵集群的自动发现机制")])]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/7112434646851584013",target:"_blank",rel:"noopener noreferrer"}},[s._v("redis发布订阅"),t("OutboundLink")],1)])]),s._v(" "),t("p",[s._v("哨兵互相之间的发现，是通过 Redis 的 "),t("code",[s._v("pub/sub")]),s._v("（发布订阅，在redis种"),t("code",[s._v("pubsub_channels")]),s._v("是字典数据结构，key为channel即频道，value为list即订阅的客户端） 系统实现的，每个哨兵都会往 "),t("code",[s._v("__sentinel__:hello")]),s._v(" 这个 channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220816142203876.png",alt:"image-20220816142203876"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("配置传播")])]),s._v(" "),t("p",[s._v("哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后通过发布订阅模式同步给其他的哨兵。其他的哨兵会根据配置信息的版本号，更新最新版本的master配置信息。")])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("常用命令")])]),s._v(" "),t("ul",[t("li",[s._v("添加新的sentinel节点到集群："),t("code",[s._v("sentinel monitor master-name ip port quorum")])]),s._v(" "),t("li",[s._v("移除sentinel节点："),t("code",[s._v("sentinel remove mymaster")])]),s._v(" "),t("li",[s._v("修改quorum；"),t("code",[s._v("sentinel set master-name quorum n")])]),s._v(" "),t("li",[s._v("查看某主节点的信息："),t("code",[s._v("sentinel master master-name")]),s._v("：")]),s._v(" "),t("li",[s._v("通过主节点名查看其ip和端口号："),t("code",[s._v("sentinel get-master-addr-by-name master-name")])]),s._v(" "),t("li",[s._v("查看某从节点的信息：\n"),t("ul",[t("li",[t("code",[s._v("sentinel slaves slave-name")])]),s._v(" "),t("li",[t("code",[s._v("sentinel replicas slave-name")])])])]),s._v(" "),t("li",[s._v("强制故障转移："),t("code",[s._v("sentinel failover master-name")])])])]),s._v(" "),t("p",[t("strong",[s._v("集群模式")])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis Cluster是3.0后推出的去中心化的集群方案。其通过将数据分为16384个槽分布到不同的服务器上，来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能，主要是针对"),t("strong",[s._v("海量数据+高并发+高可用")]),s._v("的场景。其特点是")]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("高读写性能")]),s._v("：主节点存在多个，可以多路写入，从节点提供读服务，读写分离。")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("高可用")]),s._v("：部分master不可用时，还是可以继续工作")])])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main//images/b74ff8b0-8579-11ea-ab1b-af991e0896fe-20220813145034902.png",alt:"image.png"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("分布式寻址算法")])]),s._v(" "),t("p",[t("strong",[s._v("Hash算法")])]),s._v(" "),t("blockquote",[t("p",[s._v("来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致"),t("strong",[s._v("大部分的请求过来，全部无法拿到有效的缓存")]),s._v("，导致大量的流量涌入数据库。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimageshash.png",alt:""}})])]),s._v(" "),t("p",[t("strong",[s._v("一致性 hash 算法")])]),s._v(" "),t("blockquote",[t("ol",[t("li",[s._v("将整个hash值空间虚拟成一个环，将master节点进行hash计算其在环上的位置")]),s._v(" "),t("li",[s._v("来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环"),t("strong",[s._v("顺时针“行走”")]),s._v("，遇到的第一个 master 节点就是 key 所在位置")]),s._v(" "),t("li",[s._v("如果一个节点挂了，那么只会影响这个节点上的部分数据。")])]),s._v(" "),t("p",[s._v("一致性hash算法在节点比较少的时候，容易因为节点分布不均匀而造成"),t("strong",[s._v("缓存热点")]),s._v("的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesconsistent-hashing-algorithm.png",alt:"consistent-hashing-algorithm"}})])]),s._v(" "),t("p",[t("strong",[s._v("hash slot算法（槽位定位）")])]),s._v(" "),t("blockquote",[t("p",[s._v("Redis 集群总共的槽位数是 16384 个，每一个主节点负责维护一部分槽以及槽所映射的键值数据，Redis 集群默认会"),t("strong",[s._v("对要存储的 key 值使用 CRC16 算法进行 hash 得到一个整数值")]),s._v("，然后用这个整数值对 16384 进行取模来得到具体槽位，公式为：")]),s._v(" "),t("p",[t("code",[s._v("slot = CRC16(key) % 16383")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imageshash-slot.png",alt:"hash-slot"}})])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("节点内部通信机制")])]),s._v(" "),t("p",[s._v("集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。"),t("strong",[s._v("集中式")]),s._v("是将集群元数据（节点信息、故障等等）集中存储在某个节点上。如Kafka中的zookeeper。")]),s._v(" "),t("p",[t("strong",[s._v("集中式")]),s._v("：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imageszookeeper-centralized-storage.png",alt:"zookeeper-centralized-storage"}})]),s._v(" "),t("p",[t("strong",[s._v("gossip 协议")]),s._v("：")]),s._v(" "),t("p",[s._v("节点间通过开启10000+当前端口号的端口，用于内部的节点间通信，通过PING、PONG命令监测节点存活以及集群元数据交换，通过MEET命令添加新节点进入集群，当某个节点发现故障节点后，向其他节点发送FAIL命令通知其他节点进行检测和故障确定。")]),s._v(" "),t("ul",[t("li",[s._v("ping命令深入解析：\n"),t("ul",[t("li",[s._v("每个节点会周期性的选择5个最久没有通信的其它节点。如果发现某个节点通信延时达到了 "),t("code",[s._v("cluster_node_timeout / 2")]),s._v(" ，那么立即发送 ping。")]),s._v(" "),t("li",[s._v("每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 "),t("code",[s._v("3")]),s._v(" 个其它节点的信息，最多包含 "),t("code",[s._v("总节点数减 2")]),s._v(" 个其它节点的信息。")])])])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesredis-gossip.png",alt:"Redis-gossip"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("负载均衡")])]),s._v(" "),t("p",[s._v("在 Redis 集群负载不均衡的情况下，我们可以使用 rebalance 命令重新分配各个节点负责的槽数量，从而使得各个节点的负载压力趋于平衡，从而提高 Redis 集群的整体运行效率。")]),s._v(" "),t("p",[t("code",[s._v("redis-cli --cluster rebalance 127.0.0.1:30007")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("故障发现")]),s._v("：疑似下线 + 确定下线")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("正常情况下集群中节点会定期向其他节点发送PING确认其是否在线，如果规定时间内没有收到PONG，该节点会将其标记为疑似下线并向集群广播")])]),s._v(" "),t("li",[t("p",[s._v("其他节点收到广播后会向该节点发送PING，如果超过半数标记为疑似下线，则标记为确认下线并向集群广播")])]),s._v(" "),t("li",[t("p",[s._v("其他节点收到下线广播后，会立即对该节点进行主从切换（故障转移）")])])]),s._v(" "),t("p",[t("strong",[s._v("故障转移")])]),s._v(" "),t("ul",[t("li",[s._v("选择节点：从下线的主节点中选择一个从节点（根据新主节点选举原则）")]),s._v(" "),t("li",[s._v("切换模式：从节点执行"),t("code",[s._v("SLAVEOF NO ONE")]),s._v("命令，切换为主节点模式，保留原来同步的数据")]),s._v(" "),t("li",[s._v("重派槽点：新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己")]),s._v(" "),t("li",[s._v("通知集群：新的主节点向集群广播一条 PONG 消息，通知其他节点自己已经切换为主节点并且接管了槽位")]),s._v(" "),t("li",[s._v("正常处理：新的主节点开始处理相关的命令请求，此故障转移过程完成。")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("新主节点选举")])]),s._v(" "),t("ul",[t("li",[s._v("每个主节点都有一票")]),s._v(" "),t("li",[s._v("当从节点发现自己正在复制的主节点确认下线之后，就会向集群广播一条消息，要求所有有投票权的主节点给自己投票")]),s._v(" "),t("li",[s._v("每个主节点会向第一个要求投票的从节点投票")]),s._v(" "),t("li",[s._v("从节点获票数超过主节点数的1/2，则选举成功，从节点晋升为主节点")])])]),s._v(" "),t("p",[t("strong",[s._v("Redis的管道作用")])]),s._v(" "),t("ul",[t("li",[s._v("参考："),t("a",{attrs:{href:"https://juejin.cn/post/7089081484958679077#heading-5",target:"_blank",rel:"noopener noreferrer"}},[s._v("链接*"),t("OutboundLink")],1)])]),s._v(" "),t("blockquote",[t("p",[s._v("管道技术本质上就是一种批处理技术。由于客户端与服务端通过socket进行连接，当短时间内大量命令产生的时候，如果采用普通的传输方式进行请求，命令间需要同步调用、请求的往返需要时间，并且客户端和服务端需要多次进行IO的的用户态到内核台的切换，会造成大量的网络资源浪费，而管道技术就是将所有命令都整合起来一次性发给服务端，再一次性响应给客户端，从而大大提升redis的响应速度。管道虽然提升了响应速度，但是仍然需要注意管道传输的数据大小，redis的输入缓冲区默认的最大是1G，超过会被断开连接。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220809001446974.png",alt:"image-20220809001446974"}})])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("pipeline和原生批量命令（mget、mset）的区别")])]),s._v(" "),t("ul",[t("li",[s._v("原生命令具有原子性（跟setnx原子性命令类似），pipeline不具备原子性（中间命令出错仍然会继续执行）。")]),s._v(" "),t("li",[s._v("原生命令是一个命令对应多个键值对，而pipeline是多条命令。")]),s._v(" "),t("li",[s._v("原生命令是服务端实现，而pipeline是服务端和客户端共同完成。（pipeline需要在客户端缓冲区中组装多条指令）")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("pipeline和事务的区别")])]),s._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://juejin.cn/post/7125820336104275982",target:"_blank",rel:"noopener noreferrer"}},[s._v("*Redis的事物"),t("OutboundLink")],1)])]),s._v(" "),t("li",[t("p",[s._v("事物关注的是ACID，而pipeline关注的是RTT的减少")])]),s._v(" "),t("li",[t("p",[s._v("Redis的事物通过Multi、Exec命令控制，先Multi开启事物，此过程的命令会被存储在队列中，然后在通过exec提交事物")]),s._v(" "),t("ul",[t("li",[s._v("原子性：不保证，执行过程有命令出错，仍然会继续执行，但是如果是在执行前检测到命令有误，则会回滚事物")]),s._v(" "),t("li",[s._v("隔离性：保证，Redis的事物有CAS（check and set）机制，通过watch机制监控相关key数据是否被修改，修改则关闭事物")]),s._v(" "),t("li",[s._v("持久性：不保证，没来得及被持久化的数据，仍然会丢失")])])])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("pipeline的优缺点")])]),s._v(" "),t("ul",[t("li",[s._v("优点：批量操作，减少传输IO及系统切换开销")]),s._v(" "),t("li",[s._v("缺点：\n"),t("ul",[t("li",[s._v("不能保证原子性，部分指令可能执行失败，并且其他指令会继续执行。")]),s._v(" "),t("li",[s._v("只能作用在一个节点上，暂时不支持集群。")])])])]),s._v(" "),t("p",[t("strong",[s._v("适用场景")])]),s._v(" "),t("ul",[t("li",[s._v("pipeline适用于指令间没有依赖关系的情况，并且对可靠性要求不高的场景。因为其不能保证所有命令都正常执行。")]),s._v(" "),t("li",[s._v("例如用户群发短信，这时候就可以用pipeline，因为群发消息实时性要求不高，并且即使部分失败，后续有补偿机制即可。")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("pipeline用法")])]),s._v(" "),t("ol",[t("li",[s._v("redistemplate")])]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Long")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("List")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" redisTemplate"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("executePipelined")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("RedisCallback")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Long")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Nullable")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Override")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Long")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("doInRedis")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("RedisConnection")]),s._v(" connection"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("DataAccessException")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    connection"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("openPipeline")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" key "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"123"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n      connection"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("zCount")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getBytes")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Integer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("MAX_VALUE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("ol",{attrs:{start:"2"}},[t("li",[s._v("Jedis")])]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Jedis")]),s._v(" jedis "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Jedis")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"127.0.0.1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 获取 Pipeline 对象")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pipeline")]),s._v(" pipe "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" jedis"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("pipelined")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 设置多个 Redis 命令")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  pipe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"key"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"val"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 执行命令并返回结果")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" res "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" pipe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("syncAndReturnAll")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" res"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 打印结果")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br")])])]),s._v(" "),t("blockquote",[t("p",[t("strong",[s._v("keys命令和scan命令的区别")])]),s._v(" "),t("p",[s._v("keys命令时间复杂度是O(n)，大数据量下会导致服务卡顿，而scan命令是分批次扫描的，不会阻塞线程，并且可以通过limit控制返回的数据量，缺点是可能会有数据一致性问题，因为是分批次读取。")])]),s._v(" "),t("h4",{attrs:{id:"如何保证缓存与数据库的双写一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证缓存与数据库的双写一致性"}},[s._v("#")]),s._v(" 如何保证缓存与数据库的双写一致性？")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844903941646319623",target:"_blank",rel:"noopener noreferrer"}},[s._v("*一致性问题"),t("OutboundLink")],1)])]),s._v(" "),t("blockquote",[t("p",[s._v("数据更新的时候涉及到redis和数据库的更新，那么根据更新的先后顺序，分为以下几种：")]),s._v(" "),t("ol",[t("li",[s._v("先更新缓存后更新数据库：不可取，存在数据丢失问题")]),s._v(" "),t("li",[s._v("先更新数据库后更新缓存：不可取，存在顺序问题，例如A，B顺序更新数据库，但是缓存更新可能是B，A，导致旧数据被保存")]),s._v(" "),t("li",[s._v("先删除缓存，再更新数据库：不可取，存在顺序问题，例如删除缓存后，还没更新数据，这时候有请求获取数据并且写入缓存，导致旧数据被存在缓存中")]),s._v(" "),t("li",[s._v("先更新数据库，再删除缓存：可取，数据存在短暂的不一致问题，但是大数据量下存在缓存击穿问题，可以采用加锁的方式，保证在没缓存的情况下只有少量请求进入数据库查找并缓存到redis中")])])]),s._v(" "),t("h4",{attrs:{id:"redis-的并发竞争问题是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-的并发竞争问题是什么"}},[s._v("#")]),s._v(" Redis 的并发竞争问题是什么")]),s._v(" "),t("blockquote",[t("ol",[t("li",[s._v("顺序问题：本来的请求是A-B，但是更新redis的时候是B-A，解决：\n"),t("ol",[t("li",[s._v("可以通过添加当前请求的版本号或者时间戳，如果写入的时候发现版本号低则丢弃。")]),s._v(" "),t("li",[s._v("添加消息队列，保证串行化处理")])])]),s._v(" "),t("li",[s._v("并发写入问题：先读后修改，再写入，这样存在数据覆盖问题，解决：\n"),t("ol",[t("li",[s._v("添加分布式锁（redis、zookeeper），保证不发生并发修改问题")]),s._v(" "),t("li",[s._v("避免先读后写，例如如果是数据算术操作，可以直接使用Redis的原子性命令自增。")])])])]),s._v(" "),t("p",[s._v("两个是处理不一样的问题，只实现其中一个另外一个都会都问题，比如A-B请求取更新缓存，然后顺序颠倒了，这样即使加锁了也会导致旧数据的覆盖。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);