(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{467:function(t,a,s){"use strict";s.r(a);var _=s(12),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、进程的定义及特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、进程的定义及特征"}},[t._v("#")]),t._v(" 一、进程的定义及特征")]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("定义：")])]),t._v(" "),a("blockquote",[a("p",[t._v("多道程序设计技术的引入，实现了"),a("strong",[t._v("资源的共享")]),t._v("和程序的"),a("strong",[t._v("并发执行")]),t._v("。为了描述并发执行的特点，引入了进程的概念。"),a("strong",[t._v("进程是可高并发执行的程序在一个数据集合上运行的过程")]),t._v("，具有"),a("strong",[t._v("动态性")]),t._v("、"),a("strong",[t._v("并发行")]),t._v("、"),a("strong",[t._v("独立性")]),t._v("、"),a("strong",[t._v("异步性")]),t._v("、和"),a("strong",[t._v("结构特征")]),t._v("。进程管理包括"),a("strong",[t._v("进程控制")]),t._v("、"),a("strong",[t._v("进程同步")]),t._v("、"),a("strong",[t._v("进程通信")]),t._v("和"),a("strong",[t._v("进程调度")]),t._v("。\n同一数据的不同操作之间、不同数据的同一操作之间存在着前趋关系。但"),a("strong",[t._v("不同数据的不同操作之间可考虑并发执行")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("特征：")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("动态性")]),t._v("——是进程最基本的特性。进程有一定的生命期，由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤消而消亡。而程序是一组有序指令的集合，是静态实体。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("并发性")]),t._v("——多个进程在一段时间间隔内同时运行。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("独立性")]),t._v("——进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的"),a("strong",[t._v("基本单位")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("异步性")]),t._v("——进程按各自独立的、不可预知的速度向前推进。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("结构特征")]),t._v("——进程实体由"),a("strong",[t._v("程序段")]),t._v("、"),a("strong",[t._v("数据段")]),t._v("和"),a("strong",[t._v("进程控制块PCB")]),t._v("组成。")])])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("进程控制块：")]),t._v("\n  进程控制块是进程实体的一部分，它记录了操作系统所需的、用于描述进程情况及控制进程运行所需的所有信息。\n  进程控制块的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能和其他进程并发执行的进程。\n  PCB是进程存在的"),a("strong",[t._v("唯一标志")]),t._v("。创建新进程时建立一个PCB，结束进程时回收PCB。\n  PCB经常被系统访问，应该"),a("strong",[t._v("常驻内存")]),t._v("。\n"),a("strong",[t._v("PCB的内容：")]),t._v("\n  进程标识符信息——外部标识符、内部标识符（唯一整数）。\n  处理机状态信息\n  进程调度信息——进程的状态、优先级等。\n  进程控制信息——程序和数据地址、同步机制、资源清单等。\n"),a("strong",[t._v("PCB的组织方式：")]),t._v(" "),a("strong",[t._v("链表方式")]),t._v("——相同状态的PCB，链接成一个队列。\n  "),a("strong",[t._v("索引方式")]),t._v("——建立索引表")])]),t._v(" "),a("p"),t._v(" "),a("h2",{attrs:{id:"二、进程的控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、进程的控制"}},[t._v("#")]),t._v(" 二、进程的控制")]),t._v(" "),a("h3",{attrs:{id:"_1-操作系统的内核"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作系统的内核"}},[t._v("#")]),t._v(" 1. 操作系统的内核")]),t._v(" "),a("h4",{attrs:{id:"本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本质"}},[t._v("#")]),t._v(" 本质")]),t._v(" "),a("ul",[a("li",[t._v("内核是计算机硬件的"),a("strong",[t._v("第一层扩充软件")]),t._v("，由与硬件紧密相关的模块以及运行频率较高的模块组成，常驻内存，以"),a("strong",[t._v("提高OS的运行效率")]),t._v("。")])]),t._v(" "),a("h4",{attrs:{id:"支撑功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#支撑功能"}},[t._v("#")]),t._v(" 支撑功能")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("中断处理")]),t._v("：是内核中最基本的功能，它是整个操作系统赖以活动的基础。内核只对中断进行“有限的处理”，然后转由有关进程继续处理。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("时钟管理")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("原语操作")]),t._v("：原语本身是由若干条指令构成，用于完成一定功能的一个过程。原语是一个不可分割的原子操作。")])])]),t._v(" "),a("h4",{attrs:{id:"资源管理功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源管理功能"}},[t._v("#")]),t._v(" 资源管理功能")]),t._v(" "),a("ul",[a("li",[t._v("进程管理、存储器管理和设备管理。")])]),t._v(" "),a("p"),t._v(" "),a("h3",{attrs:{id:"_2-进程的创建、终止、阻塞和唤醒"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程的创建、终止、阻塞和唤醒"}},[t._v("#")]),t._v(" 2. 进程的创建、终止、阻塞和唤醒")]),t._v(" "),a("h4",{attrs:{id:"进程的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的创建"}},[t._v("#")]),t._v(" 进程的创建")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("进程图")]),t._v("——是描述进程家族关系的有向树。有向边表示了进程的创建关系，及父子关系（并不能说明前趋关系），子进程可以继承父进程所拥有的资源，父进程撤销时必须同时撤销所有子进程。")])]),t._v(" "),a("h4",{attrs:{id:"引起创建进程的事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引起创建进程的事件"}},[t._v("#")]),t._v(" 引起创建进程的事件")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/38284818/51093796-19897f80-17e2-11e9-8268-2dabef94f84f.png",alt:"image"}})]),t._v(" "),a("h4",{attrs:{id:"进程的创建-创建原语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的创建-创建原语"}},[t._v("#")]),t._v(" 进程的创建——创建原语")]),t._v(" "),a("ul",[a("li",[t._v("申请空白PCB、为进程分配资源、初始化PCB、插入就绪队列")])]),t._v(" "),a("h4",{attrs:{id:"进程的阻塞与唤醒"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的阻塞与唤醒"}},[t._v("#")]),t._v(" 进程的阻塞与唤醒")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("原因")]),t._v("——请求系统服务、启动某种操作、新数据未到达、无新工作")]),t._v(" "),a("li",[a("strong",[t._v("阻塞")]),t._v("——当出现上述时间，进程无法继续执行，进程通过阻塞原语"),a("strong",[t._v("block")]),t._v("把自己阻塞，是进程自身的一种主动行为。")]),t._v(" "),a("li",[a("strong",[t._v("唤醒")]),t._v("——当阻塞事件结束，由发现者进程调用唤醒原语将阻塞进程的唤醒，是一种被动行为。")])]),t._v(" "),a("h4",{attrs:{id:"进程的终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的终止"}},[t._v("#")]),t._v(" 进程的终止")]),t._v(" "),a("ul",[a("li",[t._v("正常结束、异常结束、外界干预")])]),t._v(" "),a("p"),t._v(" "),a("h2",{attrs:{id:"三、进程间的通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、进程间的通信"}},[t._v("#")]),t._v(" 三、进程间的通信")]),t._v(" "),a("h4",{attrs:{id:"进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程通信"}},[t._v("#")]),t._v(" 进程通信")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("共享存储器系统：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("基于共享数据结构的通信方式")])]),t._v(" "),a("li",[a("p",[t._v("基于共享存储区的通信方式")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("消息传递系统：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("直接通信方式：进程间直接进行数据交互")])]),t._v(" "),a("li",[a("p",[t._v("间接通信方式：进程间通过实体进行数据交互")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("管道通信：")])]),t._v(" "),a("ul",[a("li",[t._v("共享文件的通信方式")])])])]),t._v(" "),a("h4",{attrs:{id:"竞争条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#竞争条件"}},[t._v("#")]),t._v(" 竞争条件")]),t._v(" "),a("ul",[a("li",[t._v("两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。")])]),t._v(" "),a("h4",{attrs:{id:"三个需要处理的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个需要处理的问题"}},[t._v("#")]),t._v(" 三个需要处理的问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51094820-35455380-17eb-11e9-88a5-4bcd78171d03.png",alt:"image"}})]),t._v(" "),a("h4",{attrs:{id:"如何避免竞争条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免竞争条件"}},[t._v("#")]),t._v(" 如何避免竞争条件")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51095091-29f32780-17ed-11e9-9bbc-98172a4aada3.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("h4",{attrs:{id:"临界区避免竞争条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#临界区避免竞争条件"}},[t._v("#")]),t._v(" 临界区避免竞争条件")]),t._v(" "),a("blockquote",[a("p",[t._v("把"),a("strong",[t._v("对共享资源进行访问的程序片段")]),t._v("称作临界区域(critical region)或临界区(critical section)")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51095177-c7e6f200-17ed-11e9-8d25-5a6725f56cdc.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("h4",{attrs:{id:"实现互斥访问-三种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现互斥访问-三种"}},[t._v("#")]),t._v(" 实现互斥访问（三种）")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("睡眠和唤醒实现互斥")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("信号量实现互斥")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("忙等待的互斥：（五种）")])]),t._v(" "),a("ul",[a("li",[a("strong",[a("em",[t._v("屏蔽中断")])]),t._v("（Disabling interrupts）：每个进程在刚刚进入临界区后立即屏蔽所有中断（包括时钟中断），并在离开前再打开所有中断。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51096456-8d825280-17f7-11e9-85c1-90a1d1aeef03.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[a("strong",[a("em",[t._v("锁变量")])]),t._v("（Lock variables）：违反了条件1")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51097407-c671f580-17fe-11e9-83ef-7e8f174b41ef.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[a("strong",[a("em",[t._v("严格轮换法")])]),t._v("（Strict alternation）：违反了条件3")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/38284818/51096492-c28ea500-17f7-11e9-8a34-2a3df922e073.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[a("strong",[a("em",[t._v("P解法")])]),t._v("（Peterson’s solution）：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/38284818/51097358-7135e400-17fe-11e9-8431-1659e9d62a68.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[a("strong",[a("em",[t._v("TSL指令")])]),t._v("：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/38284818/51097379-99254780-17fe-11e9-9f5c-f953996697d9.png",alt:"image"}})])])]),t._v(" "),a("h4",{attrs:{id:"忙等待的互斥的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#忙等待的互斥的缺点"}},[t._v("#")]),t._v(" 忙等待的互斥的缺点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("忙等待，浪费CPU")])]),t._v(" "),a("li",[a("p",[t._v("优先级反转问题：H进程优先级高占用着CPU，L进程优先级低且处于临界区中，因获取不到CPU无法从临界区出来。")])])]),t._v(" "),a("p"),t._v(" "),a("h2",{attrs:{id:"四、生产者与消费者的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、生产者与消费者的问题"}},[t._v("#")]),t._v(" 四、生产者与消费者的问题")]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("题目需求：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51100507-633d8e80-1811-11e9-83ce-41e7e576ed84.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("睡眠和唤醒进行互斥的实现：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51100523-75b7c800-1811-11e9-809e-ee82e7c13563.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("存在严重的竞争条件：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51100549-93852d00-1811-11e9-93e7-1a154568c2cd.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("信号量的定义：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51101234-c41a9600-1814-11e9-8aee-50ef48cad88a.png",alt:"image"}})]),t._v(" "),a("p"),t._v(" "),a("p",[a("strong",[t._v("使用信号量进行互斥的实现：（解决丢失的wakeup() ）")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images51101290-06dc6e00-1815-11e9-9a56-f6bde29f43b5.png",alt:"image"}})])])}),[],!1,null,null,null);a.default=v.exports}}]);