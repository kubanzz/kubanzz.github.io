(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{390:function(t,e,r){"use strict";r.r(e);var a=r(12),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、一条消息经过kafka的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、一条消息经过kafka的过程"}},[t._v("#")]),t._v(" 一、一条消息经过Kafka的过程")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220904140111454.png",alt:"image-20220904140111454"}})]),t._v(" "),e("blockquote",[e("p",[t._v("Kafka本质上是一个消息队列，最简单的消息发送过程为：生产者 -> Kafka -> 消费者，而针对不同的应用场景，可以配置不同的发送策略、分区策略、消费策略等。这里主要以Kafka默认配置下的发送过程进行分析。")])]),t._v(" "),e("p",[e("strong",[t._v("生产者端")]),t._v("：")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("消息压缩")]),t._v("：生产者生成消息并对消息进行压缩（通过"),e("code",[t._v("compression.type")]),t._v("参数配置，支持GZIP、Snappy 和 LZ4，2.1.0后支持Facebook开源的Zstandard压缩算法。）")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220904163226688.png",alt:"image-20220904163226688"}})])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("批量发送")]),t._v("：生产者会将多条消息存放在cache中，达到一定数量再进行批量发送到指定Topic，减少RTT时间。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("发送策略")]),t._v("：Kafka默认采用简单消息发送，不保证消息不丢失")])])]),t._v(" "),e("p",[e("strong",[t._v("Kafka")]),t._v("：")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[e("strong",[t._v("Broker定位")]),t._v("：消息到达Kafka后，需要到Zookeeper查找对应Topic的Partition所在的Broker地址。")]),t._v(" "),e("li",[e("strong",[t._v("分区策略")]),t._v("：Kafka默认采用顺序轮询的策略，接收到生产者的消息后，将消息顺序分配到查到的partition（Leader）所在的Broker，并以磁盘顺序写入的方式将消息持久化到文件。")]),t._v(" "),e("li",[e("strong",[t._v("主从备份")]),t._v("：Leader节点将消息同步到Flower节点进行备份")])]),t._v(" "),e("p",[e("strong",[t._v("消息者端")]),t._v("：")]),t._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[t._v("（"),e("strong",[t._v("分区平衡")]),t._v("）：消费者以组的方式存在，消费同一个Topic的消费者被归为一组，每个消费者可以消费一到多个Partition，每个Partition至少被一个消费者消费。当有新的消费者加入时，会触发Reblance，将Partition对应的消费者进行重新分配。理想情况下，"),e("strong",[t._v("消费者组中的实例数量应该等于Partition数量")]),t._v("。")])]),t._v(" "),e("blockquote",[e("p",[t._v("Reblance的三个条件")]),t._v(" "),e("ul",[e("li",[t._v("消费者组实例变化")]),t._v(" "),e("li",[t._v("订阅的主题变化")]),t._v(" "),e("li",[t._v("主题下的分区变化")])]),t._v(" "),e("p",[t._v("由于Reblance会导致STW，所以应该尽可能避免Reblance的发生。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2976713957cd4cc8cc796aa64222611b.png",alt:"img"}})]),t._v(" "),e("ol",{attrs:{start:"8"}},[e("li",[e("strong",[t._v("Poll消息")]),t._v("：Kafka默认采用“拉”的方式，即消费者批量拉取消息进行消费，并且将offset（位移）进行提交。")])]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("offset的存储")])]),t._v(" "),e("p",[t._v("早期的Offset统一存放在Zookeeper中，但是后面实践证明这种做法是不合适的，因为Zookeeper不适合做频繁的写操作，而Offset的写操作是很频繁的，后来Offset以内部主题的方式进行存储，即存放在默认主题"),e("code",[t._v("__consumer_offsets")]),t._v("中。该"),e("strong",[t._v("内部主题在第一个Consumer启动的时候就自动创建，该主题的默认分区数是 50，副本数是 3")]),t._v("。"),e("code",[t._v("__consumer_offsets")]),t._v("主题存在以下内容：")]),t._v(" "),e("ul",[e("li",[t._v("Consumer group组元数据消息")]),t._v(" "),e("li",[t._v("Consumer group位移消息")]),t._v(" "),e("li",[t._v("Consumer group删除消息（delete mark）：消费组无实例存活，并且对应的offset都被删除，则发送删除该组的消息")])]),t._v(" "),e("p",[e("strong",[t._v("offset的数据结构")])]),t._v(" "),e("p",[t._v("Offset是相对于消费者组而言的，用于记录当前消费者组对应Topic下的Partition消费的位置，数据结构可以简单的理解为KV结构，即类似"),e("code",[t._v("Map<三元组, 位移>")]),t._v("，三元组为："),e("code",[t._v("<groupId + topic + 分区号>")]),t._v("，每个消费者组都有对应这样类似数据结构的Map。")])]),t._v(" "),e("ol",{attrs:{start:"9"}},[e("li",[e("strong",[t._v("offset提交策略")]),t._v("：Kafka默认采用自动提交策略，即消费者端会定时提交对应分区端Offset（Kafka集成的大数据框架都是默认关闭的，例如Spark、Flink等），而自动提交会导致offset主题有大量消息，为了进行清除，Kafka提供了专门的后台线程（"),e("strong",[t._v("log cleaner")]),t._v("）定期清除过期的offset消息，可以认为是进行了"),e("strong",[t._v("压缩整理")]),t._v("，跟Redis的AOF重新写入类似。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images86a44073aa60ac33e0833e6a9bfd9ae7.jpeg",alt:"img"}})]),t._v(" "),e("ol",{attrs:{start:"10"}},[e("li",[t._v("（"),e("strong",[t._v("并发消费")]),t._v("）：为了提高吞吐量，可以在消费者端自行创建多个queue，并将消息根据key进行哈希取模处理，分配到不同的queue下利用多线程并行处理。")])]),t._v(" "),e("h2",{attrs:{id:"二、基础架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、基础架构"}},[t._v("#")]),t._v(" 二、基础架构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimagesimage-20220904135628667.png",alt:"image-20220904135628667"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220904221828049.png",alt:"image-20220904221828049"}})]),t._v(" "),e("h2",{attrs:{id:"三、核心组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、核心组件"}},[t._v("#")]),t._v(" 三、核心组件")]),t._v(" "),e("h3",{attrs:{id:"zookeeper"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[t._v("#")]),t._v(" Zookeeper")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://bgbiao.top/post/kafka%E5%9C%A8zookeeper%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/",target:"_blank",rel:"noopener noreferrer"}},[t._v("*参考"),e("OutboundLink")],1)])]),t._v(" "),e("blockquote",[e("p",[t._v("Zookeeper是一个分布式协调框架，底层采用树状结构存储，类似于Linux的目录结构，其中每个节点称为ZNode（分为临时节点和持久节点两类）。其特点就是树状存储及watches功能，client可以通过watches可以监听某个znode，当该节点变化时会通知到对应的client。Zookeeper的应用场景通常有以下几种：")]),t._v(" "),e("ul",[e("li",[t._v("集中式元数据管理（KV存储，基于其树型结构）")]),t._v(" "),e("li",[t._v("分布式锁（分布式同步服务，通过其原子性发号器）")]),t._v(" "),e("li",[t._v("分布式选举（ZAB协议）")])]),t._v(" "),e("p",[t._v("在Kafka中，Zookeeper主要有以下功能：")]),t._v(" "),e("ul",[e("li",[t._v("元数据存储\n"),e("ul",[e("li",[t._v("Broker节点信息（注册、注销、属性变更，内容包括ip，端口等）")]),t._v(" "),e("li",[t._v("Topic信息（Topic对应的Partition分区）")]),t._v(" "),e("li",[e("s",[t._v("Partition分区的offset信息")]),t._v("（早期版本存储，后来迁移到了Kafka内部主题）")])])]),t._v(" "),e("li",[t._v("Controller选举\n"),e("ul",[e("li",[t._v("存储当前Controller信息（Controller Broker id，当前的Controller年龄epoch（用于防止脑裂））")])])])])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("brokers目录")])])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 表示当前集群有3个节点\n[zk: 127.0.0.1:2181(CONNECTED) 6] ls /kafka/brokers/ids\n[1, 2, 3]\n\n# broker详情\n[zk: 127.0.0.1:2181(CONNECTED) 10] get  /kafka/brokers/ids/1\n{"listener_security_protocol_map":{"PLAINTEXT":"PLAINTEXT"},"endpoints":["PLAINTEXT://10.0.0.1:9092"],"jmx_port":9999,"host":"10.0.0.1","timestamp":"1588925944886","port":9092,"version":4}\n\n# topic详情(Topic对应的Partition信息)\n[zk: 127.0.0.1:2181(CONNECTED) 11] get  /kafka/brokers/topics/__consumer_offsets\n{"version":2,"partitions":{"1":[2,1,3],"0":[3,2,1],"2":[1,2,3],"adding_replicas":{},"removing_replicas":{}}\n\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("ul",[e("li",[e("strong",[t._v("controller目录")])])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 可以看到当前broker-1为集群的controller节点\n[zk: 127.0.0.1:2181(CONNECTED) 30] get  /kafka/controller\n{"version":1,"brokerid":1,"timestamp":"1588833869354"}\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("ul",[e("li",[e("strong",[t._v("controller_epoch 目录结构")])])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 可以看到controller的年龄是2，说明controller经历过2次变更了\n[zk: 127.0.0.1:2181(CONNECTED) 32] get  /kafka/controller_epoch\n2\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimages007S8ZIlly1gg0a21u6coj31am0u0tlf.jpg",alt:"kafka在zookeeper中的存储结构"}})]),t._v(" "),e("h3",{attrs:{id:"broker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[t._v("#")]),t._v(" Broker")]),t._v(" "),e("blockquote",[e("p",[t._v("Broker对应到具体的物理机，可以认为每台物理机即为一个Broker，一个Broker可以存放多个Partition。")])]),t._v(" "),e("h3",{attrs:{id:"topic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" Topic")]),t._v(" "),e("blockquote",[e("p",[t._v("Topic即主题，通常会对应到我们业务数据，Topic可以认为是一种业务数据的抽象，表示该Topic存放的是什么类型的消息。")])]),t._v(" "),e("h3",{attrs:{id:"partition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partition"}},[t._v("#")]),t._v(" Partition")]),t._v(" "),e("blockquote",[e("p",[t._v("Partition即分区，在磁盘上就体现为一个"),e("strong",[t._v("目录")]),t._v("。一个Topic下可以有多个Partition，不同partition可以被存储在不同的Broker，Partition又分为Leader和Follower，Leader用于对外提供写入和读取操作，Follower用于备份（通常Follower通常分布在不同的Broker上）。Kafka就是利用Partition提高其吞吐量，因为Partition可以被消费者并行消费，大大提高消费性能。")])]),t._v(" "),e("h3",{attrs:{id:"controller"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#controller"}},[t._v("#")]),t._v(" Controller")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://jiamaoxiang.top/2020/07/06/Kafka%E7%9A%84Controller-Broker%E6%98%AF%E4%BB%80%E4%B9%88/",target:"_blank",rel:"noopener noreferrer"}},[t._v("*参考"),e("OutboundLink")],1)])]),t._v(" "),e("blockquote",[e("p",[t._v("Controller是kafka中一个特殊的Broker，一个集群中只有一个，它的特点是需要做其他额外的工作：")]),t._v(" "),e("ul",[e("li",[t._v("集群Broker管理（新增 Broker、Broker 主动关闭、Broker 故障)")]),t._v(" "),e("li",[t._v("主题管理：创建、删除主题，增加分区并分配leader分区")]),t._v(" "),e("li",[t._v("分区管理：\n"),e("ul",[e("li",[t._v("ISR（"),e("strong",[t._v("in-sync replica")]),t._v("，同步副本列表）管理")]),t._v(" "),e("li",[t._v("Leader选举")]),t._v(" "),e("li",[t._v("分区重分配（Reblance）")])])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);