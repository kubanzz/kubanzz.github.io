(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{345:function(t,e,a){"use strict";a.r(e);var r=a(12),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言-concurrent包的层次结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言-concurrent包的层次结构"}},[t._v("#")]),t._v(" 前言：Concurrent包的层次结构")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("java.util.concurrent")]),t._v("包下提供了大量针对并发编程的高性能、实用的工具类，其目录结构图如下：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images0061iV1igy1gakyd35arej30b70b80sy.jpg",alt:"undefined"}})]),t._v(" "),e("blockquote",[e("p",[t._v("JUC包中包含了两个子包，分别是"),e("code",[t._v("atomic")]),t._v("（原子类）包和"),e("code",[t._v("lock")]),t._v("（可重入锁）包（"),e("strong",[t._v("AQS就在lock包中")]),t._v("），其他还包括阻塞队列、"),e("code",[t._v("executors")]),t._v("等，底层主要利用"),e("strong",[t._v("CAS")]),t._v("和"),e("strong",[t._v("volatile读写")]),t._v("实现，下面是"),e("code",[t._v("current")]),t._v("包的整体技术及功能实现图：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images0061iV1igy1gakyhoj7aej30mu0dc0ss.jpg",alt:"undefined"}})]),t._v(" "),e("p"),t._v(" "),e("h2",{attrs:{id:"一、aqs简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、aqs简介"}},[t._v("#")]),t._v(" 一、AQS简介")]),t._v(" "),e("blockquote",[e("p",[t._v("同步器（AQS）是用来"),e("strong",[t._v("构建锁和其他同步组件")]),t._v("的基础框架，负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，主要依赖一个int成员变量来表示"),e("strong",[t._v("同步状态")]),t._v("以及通过一个"),e("code",[t._v("FIFO")]),t._v("队列构成"),e("strong",[t._v("等待队列")]),t._v("。它的子类必须"),e("strong",[t._v("重写AQS的几个protected修饰的用来改变同步状态的方法")]),t._v("，其他方法主要实现了排队和阻塞机制。状态的更新使用"),e("code",[t._v("getState")]),t._v("，"),e("code",[t._v("setState")]),t._v("以及"),e("code",[t._v("compareAndSetState")]),t._v("这三个方法。")])]),t._v(" "),e("blockquote",[e("p",[t._v("同步器"),e("strong",[t._v("子类被推荐定义为自定义同步组件的静态内部类")]),t._v("，同步器提供了"),e("strong",[t._v("独占式")]),t._v("和"),e("strong",[t._v("共享式")]),t._v("获取同步状态的方法，可以方便不同类型的同步组件的使用，但是同步器本身没有实现任何同步接口，它定义了同步状态的获取和释放的逻辑，将同步状态的具体实现和释放交由自定义同步组件者实现，这是设计模式中的"),e("strong",[t._v("模板方法设计模式")]),t._v("。")])]),t._v(" "),e("p"),t._v(" "),e("h2",{attrs:{id:"二、aqs的模板方法设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、aqs的模板方法设计模式"}},[t._v("#")]),t._v(" 二、AQS的模板方法设计模式")]),t._v(" "),e("blockquote",[e("p",[t._v("AQS的设计是使用模板方法设计模式，将同步状态逻辑封装在AQS（如"),e("code",[t._v("acquire")]),t._v("和"),e("code",[t._v("release")]),t._v("）中，将同步状态的具体实现由开发者实现（如"),e("code",[t._v("tryAcquire")]),t._v("和"),e("code",[t._v("tryRelease")]),t._v("），开发者可以自主实现同步资源的获取，如采用公平或者非公平方式获取，下面简单举个例子")])]),t._v(" "),e("h4",{attrs:{id:"aqs中的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs中的方法"}},[t._v("#")]),t._v(" AQS中的方法")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 由开发者实现\nprotected boolean tryAcquire(int arg) {\n        throw new UnsupportedOperationException();\n}\n\n// AQS封装的执行逻辑，调用开发者实现的方法\npublic final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n }\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("h4",{attrs:{id:"reentrantlock中nonfairsync-继承aqs-重写的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock中nonfairsync-继承aqs-重写的方法"}},[t._v("#")]),t._v(" ReentrantLock中NonfairSync（继承AQS）重写的方法")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("protected final boolean tryAcquire(int acquires) {\n\t// 继承者重写了tryAcquire，提供了具体实现（省略）\n    return nonfairTryAcquire(acquires);\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h4",{attrs:{id:"aqs中可重写的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs中可重写的方法"}},[t._v("#")]),t._v(" AQS中可重写的方法")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images0061iV1igy1gakmixncwbj30s60btwf3.jpg",alt:"undefined"}})]),t._v(" "),e("h4",{attrs:{id:"aqs提供的模板方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs提供的模板方法"}},[t._v("#")]),t._v(" AQS提供的模板方法")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images0061iV1igy1gakmlh8gxtj30s80gxgn1.jpg",alt:"undefined"}})]),t._v(" "),e("p"),t._v(" "),e("h2",{attrs:{id:"三、aqs的构成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、aqs的构成"}},[t._v("#")]),t._v(" 三、AQS的构成")]),t._v(" "),e("ul",[e("li",[t._v("下图为AQS的核心构成，AQS提供了"),e("strong",[t._v("共享式锁")]),t._v("和"),e("strong",[t._v("独享式锁")]),t._v("接口，并且封装了下面实线方框的相关接口，虚线方框则是由开发者（锁开发者）具体实现的方法，比如锁的获取是否公平（公平式抢占和非公平式抢占）等。\n"),e("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images0061iV1igy1gakmtk1ml6j30ma0b574w.jpg",alt:"image.png"}})])]),t._v(" "),e("h4",{attrs:{id:"同步方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步方式"}},[t._v("#")]),t._v(" 同步方式")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("独占式锁")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("void acquire(int arg)")]),t._v("：独占式获取同步状态，如果获取失败则插入同步队列进行等待；")]),t._v(" "),e("li",[e("code",[t._v("void acquireInterruptibly(int arg)")]),t._v("：与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；")]),t._v(" "),e("li",[e("code",[t._v("boolean tryAcquireNanos(int arg, long nanosTimeout)")]),t._v("：在"),e("code",[t._v("acquireInterruptibly")]),t._v("基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;")]),t._v(" "),e("li",[e("code",[t._v("boolean release(int arg)")]),t._v("：释放同步状态，该方法会唤醒在同步队列中的下一个节点")])])]),t._v(" "),e("li",[e("strong",[t._v("共享式锁")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("void acquireShared(int arg)")]),t._v("：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；")]),t._v(" "),e("li",[e("code",[t._v("void acquireSharedInterruptibly(int arg)")]),t._v("：在"),e("code",[t._v("acquireShared")]),t._v("方法基础上增加了能响应中断的功能；")]),t._v(" "),e("li",[e("code",[t._v("boolean tryAcquireSharedNanos(int arg, long nanosTimeout)")]),t._v("：在"),e("code",[t._v("acquireSharedInterruptibly")]),t._v("基础上增加了超时等待的功能；")]),t._v(" "),e("li",[e("code",[t._v("boolean releaseShared(int arg)")]),t._v("：共享式释放同步状态，共享锁被多个线程读时锁会被多个线程占有")])])])]),t._v(" "),e("h4",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("同步队列（Node结点：head、tail）")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("volatile int waitStatus")]),t._v("：节点状态")]),t._v(" "),e("li",[e("code",[t._v("volatile Node prev")]),t._v("：当前节点/线程的前驱节点")]),t._v(" "),e("li",[e("code",[t._v("volatile Node next")]),t._v("：当前节点/线程的后继节点")]),t._v(" "),e("li",[e("code",[t._v("volatile Thread thread")]),t._v("：加入同步队列的线程引用")]),t._v(" "),e("li",[e("code",[t._v("Node nextWaiter")]),t._v("：等待队列中的下一个节点")]),t._v(" "),e("li",[e("strong",[t._v("节点状态")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("int CANCELLED = 1")]),t._v("：节点从同步队列中取消")]),t._v(" "),e("li",[e("code",[t._v("int SIGNAL = -1")]),t._v("：后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；")]),t._v(" "),e("li",[e("code",[t._v("int CONDITION = -2")]),t._v("：当前节点进入等待队列中")]),t._v(" "),e("li",[e("code",[t._v("int PROPAGATE = -3")]),t._v("：表示下一次共享式同步状态获取将会无条件传播下去")]),t._v(" "),e("li",[e("code",[t._v("int INITIAL = 0")]),t._v("：初始状态")])])])])]),t._v(" "),e("li",[e("strong",[t._v("线程状态")]),t._v("："),e("code",[t._v("state")])]),t._v(" "),e("li",[e("strong",[t._v("锁拥有者")]),t._v("："),e("code",[t._v("exclusiveOwnerThread")])])]),t._v(" "),e("p"),t._v(" "),e("h2",{attrs:{id:"四、参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、参考"}},[t._v("#")]),t._v(" 四、参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.im/post/5aeb055b6fb9a07abf725c8c",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考一"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5aeb07ab6fb9a07ac36350c8",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考二"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);