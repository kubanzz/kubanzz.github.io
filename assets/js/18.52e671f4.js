(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{344:function(e,_,v){"use strict";v.r(_);var r=v(12),o=Object(r.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"一、happens-before"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、happens-before"}},[e._v("#")]),e._v(" "),_("em",[e._v("一")]),e._v("、happens-before")]),e._v(" "),_("blockquote",[_("p",[e._v('【happens-before定义了某些操作下的可见性和"有序性"】'),_("br"),e._v("\n由于重排序（编译器重排和处理器重排）的底层规则的存在导致程序理解变得复杂，严重影响开发效率，为了解决此问题，JMM为程序员在上层提供了六条原则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。下面以两个方面来说。")])]),e._v(" "),_("h4",{attrs:{id:"_1-1-happens-before定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-happens-before定义"}},[e._v("#")]),e._v(" 1.1 happens-before定义")]),e._v(" "),_("blockquote",[_("p",[e._v("happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。JSR-133使用"),_("code",[e._v("happens-before")]),e._v("的概念来指定"),_("strong",[e._v("两个操作之间的执行顺序")]),e._v("。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，"),_("strong",[e._v("JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证")]),e._v("（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：")])]),e._v(" "),_("ul",[_("li",[e._v("如果一个操作"),_("code",[e._v("happens-before")]),e._v("另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n"),_("ul",[_("li",[e._v("此规则是"),_("strong",[e._v("JMM对程序员的承诺")]),e._v("。从程序员的角度理解"),_("code",[e._v("happens-before")]),e._v("：如果A happens-bofore B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。真正的运行顺序可能是不一样的，但是运行结果可以这么认为。")])])]),e._v(" "),_("li",[e._v("两个操作之间存在"),_("code",[e._v("happens-before")]),e._v("关系，并不意味着Java平台的具体实现必须要按照"),_("code",[e._v("happens-before")]),e._v("关系指定的顺序来执行。如果重排序之后的执行结果，与按"),_("code",[e._v("happens-before")]),e._v("关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。\n"),_("ul",[_("li",[e._v("此规则是"),_("strong",[e._v("JMM对编译器和处理器重排序的约束规则")]),e._v("。JMM是遵循一个基本原则：只要不改变程序的执行结果（指单线程和正确同步的多线程），编译器和处理器怎么优化都行。\tJMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。其本质上和"),_("code",[e._v("as-if-serial")]),e._v("类似。")])])])]),e._v(" "),_("h4",{attrs:{id:"_1-2-jmm原生happens-before规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-jmm原生happens-before规则"}},[e._v("#")]),e._v(" 1.2 JMM原生happens-before规则")]),e._v(" "),_("blockquote",[_("p",[e._v("下面规则为"),_("strong",[e._v("Java语言中无需任何同步手段保障就能成立的先行发生的规则")]),e._v("。")])]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("程序次序规则")]),e._v("：在一个线程内，按照程序代码顺序，书写在前面的操作"),_("code",[e._v("Happens-Before")]),e._v("书写在后面的操作（前面操作对后面代码可见）")]),e._v(" "),_("li",[_("strong",[e._v("管程锁定规则")]),e._v("：一个"),_("code",[e._v("unlock")]),e._v("操作"),_("code",[e._v("Happens-Before")]),e._v("后面对同一个锁的"),_("code",[e._v("lock")]),e._v("操作。")]),e._v(" "),_("li",[_("strong",[e._v("volatile变量规则")]),e._v("：一个线程对"),_("code",[e._v("volatile")]),e._v("变量的写入操作"),_("code",[e._v("Happens-Before")]),e._v("另外线程对这个变量的读操作。（volatile写操作对后续读可见）")]),e._v(" "),_("li",[_("strong",[e._v("线程启动规则")]),e._v("：Thread对象的"),_("code",[e._v("start()")]),e._v("方法"),_("code",[e._v("Happens-Before")]),e._v("此线程的每一个动作。")]),e._v(" "),_("li",[_("strong",[e._v("线程中断规则")]),e._v("： 对线程"),_("code",[e._v("interrupt()")]),e._v("方法的调用"),_("code",[e._v("Happens-Before")]),e._v("被中断线程的代码检测到中断事件的发生，可以通过"),_("code",[e._v("Thread.interrupt()")]),e._v("方法检测到是否有中断发生。")]),e._v(" "),_("li",[_("strong",[e._v("线程终止规则")]),e._v("：线程中的所有操作都"),_("code",[e._v("Happens-Before")]),e._v("对此线程的终止检测。")]),e._v(" "),_("li",[_("strong",[e._v("对象终结规则")]),e._v("：一个对象的"),_("strong",[e._v("初始化完成")]),e._v("（构造方法执行结束）"),_("code",[e._v("happens-before")]),e._v("它的"),_("code",[e._v("finalize()")]),e._v("方法的开始。")]),e._v(" "),_("li",[_("strong",[e._v("传递性")]),e._v("：如果某个动作a "),_("code",[e._v("happens-before")]),e._v(" 动作b，且b "),_("code",[e._v("happens-before")]),e._v(" 动作c，则有a "),_("code",[e._v("happens-before")]),e._v(" c。")])]),e._v(" "),_("h4",{attrs:{id:"_1-3-happens-before推导"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-happens-before推导"}},[e._v("#")]),e._v(" 1.3 happens-before推导")]),e._v(" "),_("blockquote",[_("p",[e._v("Java中原生满足"),_("code",[e._v("happens-before")]),e._v("关系的有以上八条，下面是由上面八条推导的规则，如：")])]),e._v(" "),_("ul",[_("li",[e._v("将一个元素放入一个线程安全的队列的操作"),_("code",[e._v("Happens-Before")]),e._v("从队列中取出这个元素的操作")]),e._v(" "),_("li",[e._v("将一个元素放入一个线程安全容器的操作"),_("code",[e._v("Happens-Before")]),e._v("从容器中取出这个元素的操作")]),e._v(" "),_("li",[e._v("在CountDownLatch上的倒数操作"),_("code",[e._v("Happens-Before")]),e._v("CountDownLatch#await()操作")]),e._v(" "),_("li",[e._v("释放Semaphore许可的操作"),_("code",[e._v("Happens-Before")]),e._v("获得许可操作")]),e._v(" "),_("li",[e._v("Future表示的任务的所有操作"),_("code",[e._v("Happens-Before")]),e._v("Future#get()操作")]),e._v(" "),_("li",[e._v("向Executor提交一个Runnable或Callable的操作"),_("code",[e._v("Happens-Before")]),e._v("任务开始执行操作")])]),e._v(" "),_("h4",{attrs:{id:"_1-4-小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-小结"}},[e._v("#")]),e._v(" 1.4 小结")]),e._v(" "),_("ul",[_("li",[e._v("如果两个操作不存在上述（前面8条 + 后面6条）任一一个"),_("code",[e._v("happens-before")]),e._v("规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A "),_("code",[e._v("happens-before")]),e._v("操作B，那么操作A在内存上所做的操作对操作B都是可见的。")]),e._v(" "),_("li",[_("code",[e._v("happen-before")]),e._v("原则是JMM中非常重要的原则，它是判断"),_("strong",[e._v("数据是否存在竞争")]),e._v("、"),_("strong",[e._v("线程是否安全")]),e._v("的主要依据，"),_("strong",[e._v("保证了多线程环境下的可见性")]),e._v("。")]),e._v(" "),_("li",[e._v("具体的例子可以"),_("a",{attrs:{href:"https://www.cnblogs.com/chenssy/p/6393321.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),_("OutboundLink")],1)])]),e._v(" "),_("p"),e._v(" "),_("h2",{attrs:{id:"二、as-if-serial"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、as-if-serial"}},[e._v("#")]),e._v(" 二、as-if-serial")]),e._v(" "),_("blockquote",[_("p",[_("strong",[e._v("as-if-serial")]),e._v("的语义是："),_("strong",[e._v("不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变")]),e._v("。编译器、处理器都必须遵守"),_("code",[e._v("as-if-serial")]),e._v("语义。为了遵守 as-if-serial 语义，编译器和处理器不会对存在"),_("strong",[e._v("数据依赖关系")]),e._v("的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序，从而提高处理性能。")])]),e._v(" "),_("p"),e._v(" "),_("h2",{attrs:{id:"三、参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、参考"}},[e._v("#")]),e._v(" 三、参考")]),e._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/chenssy/p/6393321.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考一"),_("OutboundLink")],1)]),e._v(" "),_("li",[_("a",{attrs:{href:"https://juejin.im/post/5ae6d309518825673123fd0e",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考二"),_("OutboundLink")],1)]),e._v(" "),_("li",[_("a",{attrs:{href:"http://ifeve.com/from-singleton-happens-before/",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考三"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=o.exports}}]);