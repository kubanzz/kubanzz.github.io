(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{372:function(e,s,n){"use strict";n.r(s);var a=n(12),t=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"一、什么是aop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是aop"}},[e._v("#")]),e._v(" 一、什么是AOP？")]),e._v(" "),s("h4",{attrs:{id:"_1-1、aop的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、aop的定义"}},[e._v("#")]),e._v(" 1.1、AOP的定义")]),e._v(" "),s("ul",[s("li",[e._v("AOP即"),s("code",[e._v("面向切面编程")]),e._v("，相比OOP —— 面向对象编程（最基本单位为"),s("code",[e._v("类和实例")]),e._v("），AOP的基本单位为"),s("code",[e._v("切面")]),e._v("。AOP编程主要可以用在如："),s("code",[e._v("权限校验")]),e._v("、"),s("code",[e._v("日志服务")]),e._v("、"),s("code",[e._v("事务控制")]),e._v("、"),s("code",[e._v("异常处理")]),e._v("等，能够对业务进行统一管理编程，"),s("code",[e._v("减少了代码的冗余")]),e._v("，"),s("code",[e._v("降低了业务代码也服务管理部分的耦合程度")]),e._v("，同时"),s("code",[e._v("提高了代码的可维护性")]),e._v("，对下面是Spring中关于AOP的定义：")])]),e._v(" "),s("blockquote",[s("p",[e._v("面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的"),s("code",[e._v("业务逻辑与系统级服务")]),e._v("（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。")])]),e._v(" "),s("h4",{attrs:{id:"_1-2、aop的的基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、aop的的基本概念"}},[e._v("#")]),e._v(" 1.2、AOP的的基本概念")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("通知/增强（Adivce） = 定位到方法后做什么事")])]),e._v(" "),s("ul",[s("li",[e._v("Before：前置通知（方法调用前）")]),e._v(" "),s("li",[e._v("After：后置通知（方法调用后，无论是否成功，相当于"),s("code",[e._v("Finally")]),e._v("代码块）")]),e._v(" "),s("li",[e._v("After-returning：最终通知（方法调用成功后）")]),e._v(" "),s("li",[e._v("After-throwing：异常通知（在方法抛出异常后调用通知）")]),e._v(" "),s("li",[e._v("Around：环绕通知（可以在目标方法前或方法后执行，即可以在环绕方法里调用目标方法）")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@Around("execution(...)")\npublic Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n    System.out.println("我是环绕通知前....");\n    //执行目标函数\n    Object obj= (Object) joinPoint.proceed();\n    System.out.println("我是环绕通知后....");\n    return obj;\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("切点（Pointcut） = 定位到具体方法的表达式")])]),e._v(" "),s("ul",[s("li",[e._v("切点可以认为是对应某个方法的点（可以被AOP扫描到的某个方法），它通常与通知一起使用，比如，不同方法的权限校验，使用AOP进行编程的话这几个方法属于不同的切点，多个切点则组成了切面。\n"),s("ul",[s("li",[s("code",[e._v("execution(* com.zdy..*(..))")]),e._v("：com.zdy包下所有类的所有方法.")]),e._v(" "),s("li",[s("code",[e._v("execution(* com.zdy.Dog.*(..))")]),e._v(": Dog类下的所有方法.")])])])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("连接点（Join point）")])]),e._v(" "),s("ul",[s("li",[e._v("连接点是一个比较虚拟的概念，可以理解为满足所有切点扫描的所有"),s("code",[e._v("时机")]),e._v("，每个连接点可以将切面代码插入到其中，并为之添加新的行为，如调用某个接口时，异常抛出时，或者修改某个字段时等。")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("切面（Aspect） = Advice + Pointcut")])]),e._v(" "),s("ul",[s("li",[e._v("切面是切点和通知的集合，一般单独作为一个类进行管理。通知和切点共同定义了关于切面的全部内容，它在什么时候（Advice的时间）、什么地方（切点）完成什么功能（Advice的功能）。")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("引入（Introduction）")])]),e._v(" "),s("ul",[s("li",[e._v("引用允许我们向现有的类添加新的方法或者属性")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("织入（Weaving）")])]),e._v(" "),s("ul",[s("li",[e._v("组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在"),s("code",[e._v("运行时")]),e._v("完成织入。")])])])]),e._v(" "),s("p"),e._v(" "),s("h2",{attrs:{id:"二、spring对aop的支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、spring对aop的支持"}},[e._v("#")]),e._v(" 二、Spring对AOP的支持")]),e._v(" "),s("h4",{attrs:{id:"_2-1、spring的代理模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、spring的代理模式"}},[e._v("#")]),e._v(" 2.1、Spring的代理模式")]),e._v(" "),s("ul",[s("li",[e._v("代理模式：代理模式在Java中是一种比较常见的设计模式。通过对目标类创建代理类，进而对目标类进行功能增强。包括以下三要素：共同接口、目标类、代理类")]),e._v(" "),s("li",[e._v("AOP思想的实现一般都是基于"),s("code",[e._v("代理模式")]),e._v("，在JAVA中一般采用"),s("code",[e._v("JDK动态代理")]),e._v("，但是由于JDK动态代理只能代理接口，如果代理类的话就不行了。因此，Sping AOP会自动进行切换，因为Spring同时支持"),s("code",[e._v("JDK动态代理")]),e._v("、"),s("code",[e._v("CGLIB")]),e._v("和"),s("code",[e._v("AspectJ")]),e._v("，当对象有实现接口时，会默认采用JDK动态代理，否则使用CGLIB代理\n"),s("ul",[s("li",[s("p",[e._v("如果目标对象的实现类"),s("code",[e._v("实现了接口")]),e._v("，Spring AOP 将会采用 "),s("code",[e._v("JDK 动态代理")]),e._v(" 来生成 AOP 代理类；")]),e._v(" "),s("ul",[s("li",[e._v("实现了接口如何强制使用CGLIB实现AOP？")]),e._v(" "),s("li",[e._v("（1）添加CGLIB库，SPRING_HOME/cglib/*.jar")]),e._v(" "),s("li",[e._v("（2）在spring配置文件中加入"),s("code",[e._v('<aop:aspectj-autoproxy proxy-target-class="true"/>')])])])]),e._v(" "),s("li",[s("p",[e._v("如果目标对象的实现类"),s("code",[e._v("没有实现接口")]),e._v("，Spring AOP 将会采用 "),s("code",[e._v("CGLIB")]),e._v(" 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心")])])])])]),e._v(" "),s("h4",{attrs:{id:"_2-2、cglib和jdk动态代理的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、cglib和jdk动态代理的区别"}},[e._v("#")]),e._v(" 2.2、CGLIB和JDK动态代理的区别")]),e._v(" "),s("p",[s("strong",[e._v("a、原理区别")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("JDK动态代理是利用"),s("code",[e._v("反射机制")]),e._v("生成一个实现代理接口的匿名类，在调用具体方法前调用"),s("code",[e._v("InvokeHandler")]),e._v("来处理。")]),e._v(" "),s("li",[e._v("CGLIB是利用"),s("code",[e._v("asm开源包")]),e._v("，将代理对象类的class文件加载进来，通过修改其"),s("code",[e._v("字节码")]),e._v("生成子类来处理。")])]),e._v(" "),s("p",[s("strong",[e._v("b、功能区别")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("JDK动态代理只能对"),s("code",[e._v("实现了接口的类")]),e._v("生成代理，而不能针对类。")]),e._v(" "),s("li",[e._v("CGLIB是"),s("code",[e._v("针对类实现代理")]),e._v("，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final")])]),e._v(" "),s("h2",{attrs:{id:"三、spring-aop配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、spring-aop配置"}},[e._v("#")]),e._v(" 三、SpRing AOP配置")]),e._v(" "),s("p",[s("strong",[e._v("切面配置")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("XML配置")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('<aop:config>\n    \x3c!-- 这是定义一个切面，切面是切点和通知的集合--\x3e\n    <aop:aspect id="do" ref="PermissionVerification">\n    \t\x3c!-- 定义切点 ，后面是expression语言，表示包括该接口中定义的所有方法都会被执行--\x3e\n        <aop:pointcut id="point" expression="execution(* wokao666.club.aop.spring01.Subject.*(..))" />\n        \x3c!-- 定义通知 --\x3e\n        <aop:before method="canLogin" pointcut-ref="point" />\n        <aop:after method="saveMessage" pointcut-ref="point" />\n    </aop:aspect>\n</aop:config>\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("ul",[s("li",[e._v("注解配置（AspectJ注解）\n"),s("ul",[s("li",[e._v("AspectJ是一个AOP框架，它能在"),s("code",[e._v("编译期")]),e._v("对JAVA代码进行AOP编译，让其具有AOP功能，AspectJ是目前实现AOP框架中最成熟的，并且与JAVA完全兼容。AspectJ单独就是一门语言，它需要专门的编译器(ajc编译器)，Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（"),s("code",[e._v("动态织入")]),e._v("），而AspectJ是"),s("code",[e._v("静态织入")]),e._v("，这是最根本的区别，并且Sping AOP"),s("code",[e._v("不尝试提供完整的AOP功能")]),e._v("，其注重的是Spring AOP与Spring IOC容器的结合，借助IOC优势处理切面问题。Spring AOP只是整合了AspectJ的那套注解，底层仍然是采用Spring AOP的"),s("code",[e._v("动态代理技术")]),e._v("实现。")])])])]),e._v(" "),s("p",[s("strong",[e._v("切面类")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@Aspect //声明自己是一个切面类\npublic class MyAspect {\n    /**\n     * 前置通知\n     */\n     // @Before是增强中的方位\n     // @Before括号中的就是切入点了\n     // before()就是传说的增强(建言):说白了，就是要干啥事.\n    @Before("execution(* com.zdy..*(..))")\n    public void before(){\n        System.out.println("前置通知....");\n    }\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[s("strong",[e._v("XML文件")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('//开启AspectJ功能.\n<aop:aspectj-autoproxy />\n\n<bean id="dog" class="com.zdy.Dog" />\n\x3c!-- 定义aspect类 --\x3e\n<bean name="myAspect" class="com.zdy.MyAspect"/>\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p"),e._v(" "),s("h4",{attrs:{id:"四、参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、参考"}},[e._v("#")]),e._v(" 四、参考")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.im/post/5aa7818af265da23844040c6",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考一"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.cnblogs.com/leifei/p/8263448.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考二"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.im/post/5a55af9e518825734d14813f",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考三"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=t.exports}}]);