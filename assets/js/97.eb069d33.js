(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{424:function(t,v,_){"use strict";_.r(v);var a=_(12),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"一、为什么会引入事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、为什么会引入事务"}},[t._v("#")]),t._v(" 一、为什么会引入事务")]),t._v(" "),v("blockquote",[v("p",[t._v("事务是一个程序执行单元，里面的所有操作要么全部执行成功，要么全部执行失败。")]),t._v(" "),v("p",[t._v("特性：ACID")]),t._v(" "),v("p",[v("strong",[t._v("Atomicity（原子性）")]),t._v("：事务是一个不可分割的整体，事务内所有操作要么全做成功，要么全失败。")]),t._v(" "),v("p",[v("strong",[t._v("Consistency（一致性）")]),t._v("：事务执行前后，数据从一个状态到另一个状态必须是一致的（A向B转账，不能出现A扣了钱，B却没收到）。")]),t._v(" "),v("p",[v("strong",[t._v("Isolation（隔离性）")]),t._v("： 多个并发事务之间相互隔离，不能互相干扰。")]),t._v(" "),v("p",[v("strong",[t._v("Durability（持久性）")]),t._v("：事务完成后，对数据库的更改是永久保存的，不能回滚。")])]),t._v(" "),v("p",[t._v("​\t\t事务有ACID的特性，可以保证事务范围内的操作要么全部成功要么全部失败，达到确保数据一致性的目的。在单机模式下，事务的操作基于数据库的"),v("strong",[t._v("本地资源管理器")]),t._v("即可实现。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220517130320376.png",alt:"image-20220517130320376"}})]),t._v(" "),v("p",[t._v("​\t\t但是随着业务的增长，为了提升性能及保证服务的高可用性，单机服务会被拆分为多个微服务，并且数据库表也会进行拆分，导致本地资源管理器出现多个，为了保证数据的一致性，这时候就需要用到分布式事务。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220517130455267.png",alt:"image-20220517130455267"}})]),t._v(" "),v("p"),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"二、分布式事务的解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、分布式事务的解决方案"}},[t._v("#")]),t._v(" 二、分布式事务的解决方案")]),t._v(" "),v("blockquote",[v("p",[t._v("分布式事务的解决方案有多个：XA（强一致性），消息队列（最终一致性），TCC（强一致性）。")]),t._v(" "),v("p",[t._v("XA协议是一个基于"),v("strong",[t._v("数据库")]),t._v("的"),v("strong",[t._v("分布式事务协议")]),t._v("，其分为两部分："),v("strong",[t._v("事务管理器")]),t._v("和"),v("strong",[t._v("本地资源管理器")]),t._v("。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。"),v("code",[t._v("二阶提交协议（2PC）")]),t._v("和"),v("code",[t._v("三阶提交协议（3PC）")]),t._v("就是根据此协议衍生出来而来。主流的诸如Oracle、MySQL等数据库均已实现了XA接口。")]),t._v(" "),v("p",[t._v("TCC是一个基于业务逻辑进行分解的分布式事务模型。需要做业务侵入处理。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220517141356497.png",alt:"image-20220517141356497"}})]),t._v(" "),v("h3",{attrs:{id:"两阶段提交-2pc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交-2pc"}},[t._v("#")]),t._v(" 两阶段提交（2PC）")]),t._v(" "),v("ul",[v("li",[t._v("prepare阶段：锁定资源（执行本地数据脚本但不提交事务）")]),t._v(" "),v("li",[t._v("commit阶段：提交资源（根据第一阶段的返回结果，确定rollback还是commit）")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220517131004403.png",alt:"image-20220517131004403"}})]),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("性能（同步阻塞）")]),t._v("：发送prepare后，如果部分参与者断开连接，会导致其他参与者的资源处于被动阻塞状态。")]),t._v(" "),v("li",[v("strong",[t._v("数据一致性（网络抖动）")]),t._v("：发送commit后，如果出现网络抖动，导致部分服务未接收到commit，则整个分布式系统会出现数据不一致的情况。")]),t._v(" "),v("li",[v("strong",[t._v("可靠性（单点故障）")]),t._v("：发送prepare后，如果协调者宕机并重新选举，选举后的协调者无法解决上个事务问题，导致参与者资源一直阻塞。")])]),t._v(" "),v("h3",{attrs:{id:"三阶段提交-3pc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三阶段提交-3pc"}},[t._v("#")]),t._v(" 三阶段提交（3PC）")]),t._v(" "),v("blockquote",[v("p",[t._v("3PC本质上是对2PC的优化，加入了一个precommit阶段，同时引入了超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，"),v("strong",[t._v("解决了2PC的单点故障问题")]),t._v("，通过ack超时重试机制，保证commit最终被提交，"),v("strong",[t._v("确实数据的一致性")]),t._v("。")])]),t._v(" "),v("ul",[v("li",[t._v("CanCommit：保证网络正常，确保资源满足要求。")]),t._v(" "),v("li",[t._v("PreCommit：执行数据库脚本，锁定资源，不提交事务。如果在锁定资源后等待DoCommit超时，则自动提交（根据概率计算而来），防止资源被无限锁定。")]),t._v(" "),v("li",[t._v("DoCommit：根据PreCommit的结果，确定是commit还是rollback。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/image-20220517132549216.png",alt:"image-20220517132549216"}})]),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("增加一个步骤，参与者和协调者通信次数增加。增加了系统的复杂度。")])]),t._v(" "),v("p",[v("strong",[t._v("优点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("增加询问功能【减缓阻塞】，在锁定资源前发现问题，减少阻塞时间。")]),t._v(" "),v("li",[t._v("自动提交功能【解决数据一致性问题】，在等待DoCommit超时后，自动提交事务（根据概率计算得来），防止资源被无限阻塞。")])]),t._v(" "),v("p"),t._v(" "),v("h3",{attrs:{id:"补偿事务-tcc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补偿事务-tcc"}},[t._v("#")]),t._v(" 补偿事务(TCC)")]),t._v(" "),v("blockquote",[v("p",[t._v("【柔性事务】")]),t._v(" "),v("p",[t._v("TCC本质上是2PC的实现，只不过2PC应用于DB层，TCC则可以理解为在应用层的2PC，是需要我们编写业务逻辑来实现的方式。")])]),t._v(" "),v("ul",[v("li",[t._v("Try：完成业务检查，预留业务所需的资源。Try是整个TCC的精髓，可以灵活选择业务资源锁的粒度。")]),t._v(" "),v("li",[t._v("Confirm：执行业务逻辑，直接使用Try操作预留的业务资源，无需再次检查。")]),t._v(" "),v("li",[t._v("Cancel：释放Try阶段预留的业务资源。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/images/635fbfb1c44f472580183218969cc572%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp",alt:"图片"}})]),t._v(" "),v("p"),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("业务侵入性强，需要实现Try、Confirm、Cancel接口，并在业务初始化阶段将这三个接口的实现注入TCC事务管理器。")])]),t._v(" "),v("p",[v("strong",[t._v("优点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("可以在Try阶段控制锁的粒度，只预留资源，而不是真正的操作。比如用XA，则在事物执行期间，相关数据会在数据库层面被锁定，导致其他事物无法操作。而TCC则不会，他在页面层面加锁，先预扣相关资源（Try），并提供错误补偿机制（Cancel），即使该TCC还在执行，也不阻塞其他TCC操作。")])]),t._v(" "),v("p",[v("strong",[t._v("参考")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("*https://zhuanlan.zhihu.com/p/142136446")]),t._v(" "),v("li",[t._v("*https://huzb.me/2019/06/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E2%80%94%E2%80%942PC%E3%80%813PC%E5%92%8CTCC/")]),t._v(" "),v("li",[t._v("https://www.pdai.tech/md/arch/arch-z-transection.html#acid")])])])}),[],!1,null,null,null);v.default=r.exports}}]);