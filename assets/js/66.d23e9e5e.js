(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{394:function(t,a,s){"use strict";s.r(a);var e=s(12),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、消息幂等"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、消息幂等"}},[t._v("#")]),t._v(" 一、消息幂等")]),t._v(" "),a("h3",{attrs:{id:"消息发送机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息发送机制"}},[t._v("#")]),t._v(" 消息发送机制")]),t._v(" "),a("ul",[a("li",[t._v("最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。")]),t._v(" "),a("li",[t._v("至少一次（at least once）：消息不会丢失，但有可能被重复发送。")]),t._v(" "),a("li",[t._v("精确一次（exactly once）：消息不会丢失，也不会被重复发送。")])]),t._v(" "),a("h3",{attrs:{id:"消息重复的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息重复的原因"}},[t._v("#")]),t._v(" 消息重复的原因")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("消费者组Reblance")])])]),t._v(" "),a("blockquote",[a("p",[t._v("如果采用offset的手动提交机制，那么在消费者还在消费并且没来得及提交offset，此时发送Reblance，则会出现重复消费问题。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220904181110372.png",alt:"image-20220904181110372"}})]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("服务端down机")])])]),t._v(" "),a("blockquote",[a("p",[t._v("kafka是批量处理方式，如果服务端的offset没来得及提交就宕机，那么会导致消息被重复消费。")])]),t._v(" "),a("ul",[a("li")]),t._v(" "),a("h3",{attrs:{id:"幂等性处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幂等性处理"}},[t._v("#")]),t._v(" 幂等性处理")]),t._v(" "),a("blockquote",[a("p",[t._v("通常为了保证数据不丢失，会采用可能重复消费的策略，由业务代码保证消息的幂等消费，消息的幂等性处理有以下几种。")])]),t._v(" "),a("ul",[a("li",[t._v("Redis：生成订单时前端先调用订单服务生成唯一订单并保存至Redis，当有请求过来时检查是否存在该订单号，存在则消费并删除，不存在则说明已经被消费过了，忽略该订单。")]),t._v(" "),a("li",[t._v("MySQL：由MySQL唯一索引约束，确保订单幂等。")])]),t._v(" "),a("h2",{attrs:{id:"二、消息事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、消息事务"}},[t._v("#")]),t._v(" 二、消息事务")]),t._v(" "),a("h3",{attrs:{id:"事务型生产者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务型生产者"}},[t._v("#")]),t._v(" 事务型生产者")]),t._v(" "),a("h3",{attrs:{id:"本地消息事务表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地消息事务表"}},[t._v("#")]),t._v(" 本地消息事务表")]),t._v(" "),a("h2",{attrs:{id:"三、消息有序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、消息有序"}},[t._v("#")]),t._v(" 三、消息有序")]),t._v(" "),a("h3",{attrs:{id:"分区机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区机制"}},[t._v("#")]),t._v(" 分区机制")]),t._v(" "),a("blockquote",[a("p",[t._v("Kafka中的分区策略主要有三种：")]),t._v(" "),a("ul",[a("li",[t._v("随机分区")]),t._v(" "),a("li",[t._v("顺序分区（默认）")]),t._v(" "),a("li",[t._v("按Partition Key分区")])]),t._v(" "),a("p",[t._v("第三种策略可以保证有序性，例如希望同个订单的操作有序，我们可以配置Partition key为订单号，保证同个订单操作的有序性。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);