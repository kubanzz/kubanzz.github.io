(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{342:function(t,a,v){"use strict";v.r(a);var _=v(12),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("类的加载过程、触发类加载的事件、双亲委派机制")])]),t._v(" "),a("h2",{attrs:{id:"一、类加载机制概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、类加载机制概念"}},[t._v("#")]),t._v(" 一、类加载机制概念")]),t._v(" "),a("p",[t._v("Java虚拟机是通过类元信息进行对象的内存分配和实例化操作的，而类加载机制就是将字节码文件加载到内存，并且在元方法区创建类元信息的过程，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220919102311495.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"二、类的加载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、类的加载过程"}},[t._v("#")]),t._v(" 二、类的加载过程")]),t._v(" "),a("p",[t._v("如下图所示，类的加载过程包括以下几个阶段：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("加载")]),t._v("：读取字节码文件（class文件）到内存，将类的字节码转化为运行时数据结构，并在方法区创建类元信息")]),t._v(" "),a("li",[a("strong",[t._v("链接")]),t._v("：\n"),a("ol",[a("li",[t._v("校验：检查文件格式、字节码文件数据的正确性")]),t._v(" "),a("li",[t._v("准备：给类的静态变量分配内存空间（static修饰的变量），并且赋予默认值（如null、false、0等）")]),t._v(" "),a("li",[t._v("解析：将符号引用转成直接引用（个人认为是对接口、类、字段进行解析，主要是为了将其解析为JVM可识别的结构）")])])]),t._v(" "),a("li",[a("strong",[t._v("初始化")]),t._v("：对类的静态变量，静态代码块执行初始化操作（类似于Spring中执行@PostContruct注解初始化）")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20230209162409440.png",alt:"image-20230209162409440"}})]),t._v(" "),a("h2",{attrs:{id:"三、类的初始化时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、类的初始化时机"}},[t._v("#")]),t._v(" 三、类的初始化时机")]),t._v(" "),a("blockquote",[a("p",[t._v("关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”。")]),t._v(" "),a("p",[t._v("初始化的时机简单来说就是：用到时就要立马进行初始化。")])]),t._v(" "),a("p",[t._v("常见的初始化时机：")]),t._v(" "),a("ol",[a("li",[t._v("创建类的实例（new）")]),t._v(" "),a("li",[t._v("访问类的静态变量/静态方法")]),t._v(" "),a("li",[t._v("反射加载类（"),a("code",[t._v('Class.forName("my.xyz.Test")')]),t._v("）")]),t._v(" "),a("li",[t._v("当初始化一个类时，发现其父类未初始化，则先初始化父类")]),t._v(" "),a("li",[t._v("虚拟机启动时，定义了"),a("code",[t._v("main")]),t._v("方法的类先初始化")])]),t._v(" "),a("h2",{attrs:{id:"四、双亲委派机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、双亲委派机制"}},[t._v("#")]),t._v(" 四、双亲委派机制")]),t._v(" "),a("blockquote",[a("p",[t._v("双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。")])]),t._v(" "),a("p",[t._v("类加载器")]),t._v(" "),a("ul",[a("li",[t._v("启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\\lib目录中并且能被虚拟机识别的类库到JVM内存中")]),t._v(" "),a("li",[t._v("扩展类加载器（Extension ClassLoader）：负责加载JAVA_HOME\\lib下的ext目录下的类库")]),t._v(" "),a("li",[t._v("应用程序类加载器（Application ClassLoader）：负责加载项目下相关的引入类")]),t._v(" "),a("li",[t._v("自定义类加载器")])])])}),[],!1,null,null,null);a.default=s.exports}}]);