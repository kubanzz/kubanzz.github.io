(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{403:function(t,a,e){"use strict";e.r(a);var s=e(12),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、缓存雪崩"}},[t._v("#")]),t._v(" 一、缓存雪崩")]),t._v(" "),a("blockquote",[a("p",[t._v("对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住就挂掉，这种就是缓存雪崩。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-caching-avalanche.png",alt:"redis-caching-avalanche"}})]),t._v(" "),a("p",[a("strong",[t._v("解决方案")])]),t._v(" "),a("ul",[a("li",[t._v("事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。")]),t._v(" "),a("li",[t._v("事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。")]),t._v(" "),a("li",[t._v("事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-caching-avalanche-solution.png",alt:"redis-caching-avalanche-solution"}})]),t._v(" "),a("h2",{attrs:{id:"二、缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、缓存穿透"}},[t._v("#")]),t._v(" 二、缓存穿透")]),t._v(" "),a("blockquote",[a("p",[t._v("对于系统 A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。")]),t._v(" "),a("p",[t._v("黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。请求每次都“"),a("strong",[t._v("视缓存于无物")]),t._v("”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-caching-penetration.png",alt:"redis-caching-penetration"}})]),t._v(" "),a("p",[a("strong",[t._v("解决方案")])]),t._v(" "),a("ul",[a("li",[t._v("将不存在的key也缓存到redis")]),t._v(" "),a("li",[t._v("通过布隆过滤器过滤")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-caching-avoid-penetration.png",alt:"redis-caching-avoid-penetration"}})]),t._v(" "),a("h2",{attrs:{id:"三、缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、缓存击穿"}},[t._v("#")]),t._v(" 三、缓存击穿")]),t._v(" "),a("blockquote",[a("p",[t._v("缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。")])]),t._v(" "),a("p",[a("strong",[t._v("解决方案")])]),t._v(" "),a("ul",[a("li",[t._v("若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。")]),t._v(" "),a("li",[t._v("若缓存的数据更新不频繁，可采用分布式锁保证只有少量线程进入数据库并更新到缓存，这样后续的线程都可以走缓存获取数据")]),t._v(" "),a("li",[t._v("若缓存的数据更新频繁，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);