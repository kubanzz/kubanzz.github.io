(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{377:function(t,v,e){"use strict";e.r(v);var a=e(12),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"一、如何基于spring写优雅易扩展的代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、如何基于spring写优雅易扩展的代码"}},[t._v("#")]),t._v(" 一、如何基于Spring写优雅易扩展的代码")]),t._v(" "),v("h3",{attrs:{id:"_1-1-案例一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-案例一"}},[t._v("#")]),t._v(" 1.1 案例一")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5gy1g9ofobumg8j30vf0datco.jpg",alt:"image.png"}})]),t._v(" "),v("h4",{attrs:{id:"_1-1-1-如何实现订单金额的计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-如何实现订单金额的计算"}},[t._v("#")]),t._v(" 1.1.1 如何实现订单金额的计算")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("策略模式")]),t._v("\n实现面向接口编程，由于计算金额的方法是会增加的，比如促销方案是会变的，可以利用策略模式，将订单金额计算的方法抽象为接口，有不同的促销模式时候实现该接口（接口隔离原则），避免频繁的修改代码（开闭原则）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("工厂模式")]),t._v("\n利用工厂方法实现方案计算方法实例的生成，（根据传入的String）利用反射获取各种金额计算方案的实现，如果是自己利用反射技术实现简单工厂的话，每次有新促销方案的话我们需要修改自定义的工厂，因为工厂需要初始化各个促销接口的实现类，为此引入下列几种方式，通过将变化的部分以配置文件的方式隔离（SPI）、Spring注入、Spring提供的工厂真正实现开闭原则。")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("Java SPI")]),t._v("："),v("code",[t._v("接口服务发现机制")]),t._v("，对接口的实现类自动完成加载。SPI机制可以避免硬编码的问题，厂商通过规定的配置规则，即"),v("code",[t._v("使用方提供规则，提供方根据规则把自己加载到提供方的思想")]),t._v("。在Java中通过"),v("code",[t._v("ServiceLoader")]),t._v("加载约定配置下的实现类，"),v("code",[t._v("ServiceLoader<Driver> s = ServiceLoader.load(Driver.class);")]),t._v("如：")]),t._v(" "),v("ul",[v("li",[v("ol",[v("li",[t._v("MySQL的驱动加载时，在"),v("code",[t._v("META/services")]),t._v("中以调用者给定的"),v("code",[t._v("完整接口名")]),t._v("命名文件，文件内容为该接口的"),v("code",[t._v("具体实现完整类名")]),t._v("；")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[t._v("Spring中的"),v("code",[t._v("component-scan")]),t._v("\n注解标签，会将@Controller、@Service等的标签注入到容器中，也就是Spring制定了规则，开发者根据规则去实现。")])])]),t._v(" "),v("li",[t._v("参考： "),v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/28909673",target:"_blank",rel:"noopener noreferrer"}},[t._v("链接"),v("OutboundLink")],1),t._v(" "),v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5gy1g9qsftdrwmj30k007cdhh.jpg",alt:"image.png"}}),t._v(" "),v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5gy1g9qk98mysdj30k00aujuf.jpg",alt:"image.png"}})])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("Dubbo SPI")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("Spring实现")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("@Autowired Map<String,Order> map")]),t._v("，利用"),v("code",[t._v("Map可以自动将所有Order接口的实现类注入")])]),t._v(" "),v("li",[t._v("利用"),v("code",[t._v("ApplicationContext")]),t._v("获取bean并实现方法的调用，即利用Spring提供的工厂模式")])])])])])]),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"二、如何提高工作效率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、如何提高工作效率"}},[t._v("#")]),t._v(" 二、如何提高工作效率")]),t._v(" "),v("h4",{attrs:{id:"为什么我们的工作效率不高"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么我们的工作效率不高"}},[t._v("#")]),t._v(" 为什么我们的工作效率不高")]),t._v(" "),v("ul",[v("li",[t._v("我们掌握的方法、技能、工具不多，不知道还有更好的开发模式，一直采用传统的堆代码开发，"),v("code",[t._v("要提高工作效率，需要多掌握更多更好的开发方法、工具和技能")]),t._v("。")])]),t._v(" "),v("h4",{attrs:{id:"高薪人的优势是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高薪人的优势是什么"}},[t._v("#")]),t._v(" 高薪人的优势是什么")]),t._v(" "),v("ul",[v("li",[t._v("能够解决更大的问题，更难的问题")]),t._v(" "),v("li",[t._v("相同时间解决的问题更多，绝对不是因为加班多才会薪资高")])]),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"三、如何基于spring写解耦易扩展的代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、如何基于spring写解耦易扩展的代码"}},[t._v("#")]),t._v(" 三、如何基于Spring写解耦易扩展的代码")]),t._v(" "),v("h3",{attrs:{id:"_3-1-案例分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-案例分析"}},[t._v("#")]),t._v(" 3.1 案例分析")]),t._v(" "),v("h4",{attrs:{id:"_3-1-1-业务场景演示"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-业务场景演示"}},[t._v("#")]),t._v(" 3.1.1 业务场景演示")]),t._v(" "),v("p",[v("strong",[t._v("常规代码流程")]),t._v("：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5gy1g9ogwyyd0jj30oa0630um.jpg",alt:"image.png"}})]),t._v(" "),v("p",[v("strong",[t._v("问题")])]),t._v(" "),v("ul",[v("li",[t._v("同步调用")]),t._v(" "),v("li",[t._v("如何邮件发送异常，则短信服务也无法进行，订票失败")]),t._v(" "),v("li",[t._v("违反单一原则（在订单方法中加入了邮件和短信通知）")]),t._v(" "),v("li",[v("code",[t._v("与不是强相关的类耦合")]),t._v("（航班预定与邮箱、短信类） - 复用性极低")]),t._v(" "),v("li",[t._v("如果有新功能加入，如需要发微信、QQ，则会违反开闭原则，不易扩展")])]),t._v(" "),v("hr"),t._v(" "),v("p",[v("strong",[t._v("基于"),v("code",[t._v("事件驱动")]),t._v("的流程（观察者模式）")]),t._v("：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5gy1g9oh3kzm5fj30mw09vtbk.jpg",alt:"image.png"}})]),t._v(" "),v("p",[v("strong",[t._v("事件驱动")])]),t._v(" "),v("ul",[v("li",[t._v("发布者：OrderService类中的预定订单方法")]),t._v(" "),v("li",[t._v("事件：航班预定事件，即Order（订单）对象为事件")]),t._v(" "),v("li",[t._v("事件通道：spring（"),v("code",[t._v("ApplicationContext")]),t._v("提供事件的发布通道，如"),v("code",[t._v("publishEvent(Object o)")]),t._v("和"),v("code",[t._v("publishEvent(ApplicationEvent event)")]),t._v("方法，一个用于对象事件如订单生成Order对象、一个用于应用事件如应用启动关闭事件，可以用于Spring启动的时候进行相关的初始化任务）")]),t._v(" "),v("li",[t._v("监听者：邮件发送类、短信发送类")])]),t._v(" "),v("p",[v("strong",[t._v("Spring注解")])]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("@Async")]),t._v("：异步执行注解")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("@Transactional")]),t._v("：添加事务")])]),t._v(" "),v("li",[v("p",[t._v("观察者模式")]),t._v(" "),v("ul",[v("li",[t._v("监听者："),v("code",[t._v("@EventListener")])])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("@EventListener\n@Async //异步执行\npublic void handleOrderEvent(Order order){\n\t//上面的传入对象参数即为监听的事件，该监听方法只对Order事件感兴趣\n\tEmail mail = ...;\n\tthis.sendMail(email);\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br")])]),v("ul",[v("li",[t._v("发布者：在发生订单事件的方法中调到Spring提供的"),v("code",[t._v("ApplicationContext")]),t._v("的发布方法")])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("@Autowired\nApplicationContext context;\npublic void bookOrder(Order o){\n\t...\n\tcontext.publishEvent(order);\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br")])])])]),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"四、如何基于spring写异步、定时任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、如何基于spring写异步、定时任务"}},[t._v("#")]),t._v(" 四、如何基于Spring写异步、定时任务")]),t._v(" "),v("p",[v("strong",[t._v("异步方式")])]),t._v(" "),v("ul",[v("li",[t._v("方式一：配置ApplicationEventMuticaster的Bean（基于事件的异步）\n"),v("ul",[v("li",[t._v("Spring提供，配置configuration的Bean，并在其中配置线程池（没有线程池配置则为同步）")]),t._v(" "),v("li",[t._v("缺点：一刀切（所有的事件执行都变为异步的）")])])]),t._v(" "),v("li",[t._v("方式二：@EnableAsync @Async（基于Bean的异步）\n"),v("ul",[v("li",[t._v("控制Bean的方法调用为异步执行（灵活），需要特定线程池则进行配置")]),t._v(" "),v("li",[v("code",[t._v("@EnableAsync")]),t._v("：开启SpringBoot异步模式")]),t._v(" "),v("li",[v("code",[t._v("@Async")]),t._v("：被标识的方法在调用的时候为异步调用，未被标识的方法为同步执行")])])])]),t._v(" "),v("p",[v("strong",[t._v("定时任务")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("@EnableScheduling")]),t._v("：开启SpringBoot定时任务")]),t._v(" "),v("li",[v("code",[t._v("@Schedule")]),t._v("：在执行逻辑的Bean（"),v("code",[t._v("@Component")]),t._v("）的方法上注释即可实现定时任务")])]),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"五、如何扩展我们的技术广度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、如何扩展我们的技术广度"}},[t._v("#")]),t._v(" 五、如何扩展我们的技术广度")]),t._v(" "),v("blockquote",[v("p",[t._v("针对事情快速应对，即想到相应的方法。需要有好的技术，想想如何达到高薪的位置，而不是单单想着拿高薪。\n单机的技术使用跟分布式的使用是不同的，单机的可以充分利用Spring的高级用法，而分布式则更多的依赖于中间件，比如上面说的事件驱动编程，如果在Spring中可以利用其注解快速实现，而分布式环境中则需要利用"),v("code",[t._v("MQ")]),t._v("实现发布订阅模式，要能快速的想出解决方案，需要我们有足够的知识广度。")])]),t._v(" "),v("p",[v("strong",[t._v("扩展技术广度的方法")])]),t._v(" "),v("ul",[v("li",[t._v("参加课程")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images006H3ec5ly1g9qw191vpfj312k0lb422.jpg",alt:"image.png"}})]),t._v(" "),v("ul",[v("li",[t._v("技术大牛带")]),t._v(" "),v("li",[t._v("项目的洗礼")]),t._v(" "),v("li",[t._v("去大的互联网公司")]),t._v(" "),v("li",[t._v("多看书、多交流探讨")])]),t._v(" "),v("p")])}),[],!1,null,null,null);v.default=r.exports}}]);