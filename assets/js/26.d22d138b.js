(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{353:function(a,s,e){"use strict";e.r(s);var t=e(12),n=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"一、容器间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、容器间的区别"}},[a._v("#")]),a._v(" 一、容器间的区别")]),a._v(" "),s("h4",{attrs:{id:"_1-1、list、map、set三者间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、list、map、set三者间的区别"}},[a._v("#")]),a._v(" 1.1、List、Map、Set三者间的区别")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("List")]),a._v("：List接口存储一组可重复的、有序的对象")]),a._v(" "),s("li",[s("strong",[a._v("Map")]),a._v("：Map接口存储以key为索引，value为值数据，其中key不可以重复，value可以")]),a._v(" "),s("li",[s("strong",[a._v("Set")]),a._v("：Set接口存储一组唯一的数据，不允许多个元素引用相同的对象")])]),a._v(" "),s("h4",{attrs:{id:"_1-2、arraylist和linkedlist的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、arraylist和linkedlist的区别"}},[a._v("#")]),a._v(" 1.2、ArrayList和LinkedList的区别")]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("是否线程安全")]),a._v("：都是非线程安全的")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("底层数据结构")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("ArrayList：底层是由"),s("code",[a._v("Object")]),a._v("数组实现")]),a._v(" "),s("li",[a._v("LinkedList：是用双向链表实现（JDK1.7前为循环双向链表")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("插入及删除效率是否受位置影响")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("ArrayList：由于数组的特性，插入及删除效率受位置的影响，需要对相关数据进行移动。")]),a._v(" "),s("li",[a._v("LinkedList：由于链表的特性，其插入及删除效率不受位置影响，时间复杂度都为O(1)")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("是否支持快速随机访问")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("ArrayList：支持高速随机访问，实现了"),s("code",[a._v("RandomAccess")]),a._v("标识接口（实现则采用"),s("code",[a._v("indexBinarySearch")]),a._v("方法，否则采用"),s("code",[a._v("iteratorBinarySearch")]),a._v("方法）")]),a._v(" "),s("li",[a._v("LinkedList：不支持高速随机访问，需要遍历数据")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("内存空间占用")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("ArrayList：在List结尾会预留一定的容量空间")]),a._v(" "),s("li",[a._v("LinkedList：则主要体现在每个元素都需要空间存放直接前驱和直接后继。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("扩容机制")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("ArrayList默认长度为10，扩容时为原来的"),s("code",[a._v("1.5倍")])])])])]),a._v(" "),s("h4",{attrs:{id:"_1-3、arraylist和vector的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、arraylist和vector的区别"}},[a._v("#")]),a._v(" 1.3、ArrayList和Vector的区别")]),a._v(" "),s("ul",[s("li",[a._v("Vector：所有方法都是"),s("strong",[a._v("线程同步")]),a._v("的，所以在同步操作上需要耗费大量时间")]),a._v(" "),s("li",[a._v("ArrayList：是非线程安全的，在单线程的情况下采用ArrayList会有更好的性能")])]),a._v(" "),s("h4",{attrs:{id:"_1-4、hashmap和hashtable-已被淘汰-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、hashmap和hashtable-已被淘汰-的区别"}},[a._v("#")]),a._v(" 1.4、HashMap和HashTable（已被淘汰）的区别")]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("是否线程安全")]),a._v("：HashTable为线程安全")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("效率")]),a._v("：HashTable由于是全表同步的，其同步开销较大，效率较低")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("对Null key和value的支持")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("HashMap：支持key和value为null，但是key中的null必须是唯一的")]),a._v(" "),s("li",[a._v("HashTable：支持value为null，当key为null时会报"),s("code",[a._v("NullPointException")])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("初始容量及扩容")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("HashTable：默认大小为11，扩容为原来的"),s("code",[a._v("2n+1")]),a._v("，当给定了初始值时，会直接使用该值")]),a._v(" "),s("li",[a._v("HashMap：默认大小为16，扩容时为原来的"),s("code",[a._v("2倍")]),a._v("，当给定了初始值时，会先扩充为"),s("code",[a._v("2的幂次方")])])])])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('HashMap的构造方法：\n\n public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException("Illegal initial capacity: " +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException("Illegal load factor: " +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n     public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br")])]),s("ul",[s("li",[s("strong",[a._v("底层数据结构")]),a._v("：\n"),s("ul",[s("li",[a._v("JDK1.8后，HashMap在处理哈希冲突上采用的是"),s("code",[a._v("数组 + 链表")]),a._v("的形式，同时在链表长度超过阈值时（默认为8），将链表转换为"),s("code",[a._v("红黑树")]),a._v("，提高了搜索效率，将链表（寻址时间复杂度为"),s("code",[a._v("O(N)")]),a._v("）转换为红黑树（寻址时间复杂度为"),s("code",[a._v("O(log(N))")]),a._v("），而HashTable则没有")])])])]),a._v(" "),s("h4",{attrs:{id:"_1-5、hashmap和hashset的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5、hashmap和hashset的区别"}},[a._v("#")]),a._v(" 1.5、HashMap和HashSet的区别")]),a._v(" "),s("ul",[s("li",[a._v("HashSet：\n"),s("ul",[s("li",[a._v("底层是基于HashMap实现")]),a._v(" "),s("li",[a._v("在校验重复上，插入时先比较HashCode是否相同，如果相同则调用"),s("code",[a._v("equal")]),a._v("方法比较，都相同则不能成功插入。")])])])]),a._v(" "),s("h4",{attrs:{id:"_1-6、hashtable和concurrenthashmap的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6、hashtable和concurrenthashmap的区别"}},[a._v("#")]),a._v(" 1.6、HashTable和ConCurrentHashMap的区别")]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("底层数据结构")]),a._v("：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("HashTable")]),a._v("：数组（主体） + 链表（解决哈希冲突）")]),a._v(" "),s("li",[s("strong",[a._v("ConCurrentHashMap")]),a._v("：\n"),s("ul",[s("li",[s("em",[a._v("JDK1.7")]),a._v("：分段数组 + 链表")]),a._v(" "),s("li",[s("em",[a._v("JDK1.8")]),a._v("：数组 + 链表/红黑二叉树")])])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("实现线程安全的方式")]),a._v("：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("HashTable")]),a._v("：\n"),s("ul",[s("li",[a._v("同一把锁，使用"),s("code",[a._v("synchronized")]),a._v("保证线程安全，效率非常低下。\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images62021127-548c5700-b1f8-11e9-8902-927c850b7774.png",alt:"image"}})])])]),a._v(" "),s("li",[s("strong",[a._v("ConCurrentHashMap")]),a._v("：\n"),s("ul",[s("li",[s("em",[a._v("JDK1.7")]),a._v("：采用"),s("code",[a._v("分段锁")]),a._v("，对整个桶数据进行了分割分段，每段有一把锁，多线程并发不同数据段的数据，不会有锁竞争，提高了并发效率。\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images62021137-5f46ec00-b1f8-11e9-8635-958ee4cb7d3a.png",alt:"image"}})]),a._v(" "),s("li",[s("em",[a._v("JDK1.8")]),a._v("：取消了分段锁机制，采用"),s("code",[a._v("Node 数组（实现了Map接口） + 链表 + 红黑树")]),a._v("，并发控制使用"),s("code",[a._v("synchronized")]),a._v("和"),s("code",[a._v("CAS")]),a._v("。synchronized只锁定当前链表或红黑二叉树的"),s("code",[a._v("首节点")]),a._v("，这样只要hash不冲突，就不会产生并发，效率又提升N倍。\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images62021143-640ba000-b1f8-11e9-98f7-5a2e79dc5d63.png",alt:"image"}})])])])])])]),a._v(" "),s("p"),a._v(" "),s("h2",{attrs:{id:"二、容器的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、容器的特性"}},[a._v("#")]),a._v(" 二、容器的特性")]),a._v(" "),s("h4",{attrs:{id:"_2-1、hashmap的长度为什么是2的幂次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、hashmap的长度为什么是2的幂次方"}},[a._v("#")]),a._v(" 2.1、HashMap的长度为什么是2的幂次方")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("为了让HashMap存取高效，尽量减少碰撞，也就是尽量的把数据分配均匀。Hash 值的范围值"),s("code",[a._v("-2147483648")]),a._v("到"),s("code",[a._v("2147483647")]),a._v("，前后加起来大概"),s("code",[a._v("40亿")]),a._v("的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，"),s("code",[a._v("内存是放不下的")]),a._v("。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度"),s("code",[a._v("取模运算")]),a._v("，得到的"),s("code",[a._v("余数")]),a._v("才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是"),s("code",[a._v("(length - 1) & hash")]),a._v("。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。")])]),a._v(" "),s("li",[s("p",[a._v("&的运算比%的运算效率是高很多的，为了提高运算，在保证长度为2的幂次方的条件下， "),s("code",[a._v("hash & (length - 1)")]),a._v(" = "),s("code",[a._v("hash % length")]),a._v("是成立的，此时使用位运算"),s("code",[a._v("&")]),a._v("可以提高运行效率。")])])]),a._v(" "),s("h4",{attrs:{id:"_2-2、comparable和comparator的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、comparable和comparator的区别"}},[a._v("#")]),a._v(" 2.2、Comparable和Comparator的区别")]),a._v(" "),s("ul",[s("li",[a._v("comparable接口出自"),s("code",[a._v("java.lang")]),a._v("包 它有一个 "),s("code",[a._v("compareTo(Object obj)")]),a._v("方法用来排序，一般是在实体中实现此接口并重写compareTo方法。")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('//person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使TreeMap中的数据按顺序排列，而String和Integer等类型都已经默认实现了Comparable接口\n\npublic  class Person implements Comparable<Person> {\n    private int age;\n    \n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * TODO重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        // TODO Auto-generated method stub\n        if (this.age > o.getAge()) {\n            return 1;\n        } else if (this.age < o.getAge()) {\n            return -1;\n        }\n        return age;\n    }\n    \n     public static void main(String[] args) {\n        //TreeMap是\n        TreeMap<Person, String> pdata = new TreeMap<Person, String>();\n        pdata.put(new Person("张三", 30), "zhangsan");\n        pdata.put(new Person("李四", 20), "lisi");\n        pdata.put(new Person("王五", 10), "wangwu");\n        pdata.put(new Person("小红", 5), "xiaohong");\n        \n        // 得到key的值的同时得到key所对应的值\n        Set<Person> keys = pdata.keySet();\n        for (Person key : keys) {\n            System.out.println(key.getAge() + "-" + key.getName());\n\n        }\n    }\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br")])]),s("ul",[s("li",[a._v("comparator接口出自"),s("code",[a._v("java.util")]),a._v("包，它有一个"),s("code",[a._v("compare(Object obj1, Object obj2)")]),a._v("方法用来排序，通常是与"),s("code",[a._v("Collections")]),a._v("类一起使用")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("ArrayList<Integer> arrayList = new ArrayList<Integer>();\n\n//反转\nCollections.reverse(arrayList);\n//按自然排序升序排序\nCollections.sort(arrayList);\n// 定制排序的用法\nCollections.sort(arrayList, new Comparator<Integer>() {\n\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o2.compareTo(o1);\n    }\n});\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("h4",{attrs:{id:"_2-3、哈希冲突的解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、哈希冲突的解决方法"}},[a._v("#")]),a._v(" 2.3、哈希冲突的解决方法")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("开放地址法")]),a._v("：从发生冲突的那个单元起，按照一定的次序，从哈希表中选择一个空闲的单元，将发生冲突的单元放入即可，开放地址法的缺点是不能真正的删除元素，只能做特殊标识，直到有下个元素插入才可以真正删除，否则会引起查找错误。\n"),s("ul",[s("li",[s("em",[a._v("线行探查法")]),a._v("：依次判断")]),a._v(" "),s("li",[s("em",[a._v("平方探查法")]),a._v("：d[i] + n^2")]),a._v(" "),s("li",[a._v("双散列函数探查法：")])])]),a._v(" "),s("li",[s("strong",[a._v("拉链法")]),a._v("："),s("code",[a._v("数组 + 链表")])]),a._v(" "),s("li",[s("strong",[a._v("再哈希法")]),a._v("：构造"),s("code",[a._v("多个不同")]),a._v("的哈希函数，出现ch")]),a._v(" "),s("li",[s("strong",[a._v("建立公共溢出区")]),a._v("：将哈希表分为"),s("code",[a._v("公共表")]),a._v("和"),s("code",[a._v("溢出表")]),a._v("，当溢出发生时，将所有溢出数据统一放到溢出区。")])]),a._v(" "),s("p"),a._v(" "),s("h2",{attrs:{id:"三、容器底层数据结构总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、容器底层数据结构总结"}},[a._v("#")]),a._v(" 三、容器底层数据结构总结")]),a._v(" "),s("h4",{attrs:{id:"_3-1、list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、list"}},[a._v("#")]),a._v(" 3.1、List：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("ArrayList")]),a._v("：Object数组")]),a._v(" "),s("li",[s("strong",[a._v("Vector")]),a._v("：Object数组")]),a._v(" "),s("li",[s("strong",[a._v("LinkedList")]),a._v("：双向链表（1.6前为循环双向链表）")])]),a._v(" "),s("h4",{attrs:{id:"_3-2、map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、map"}},[a._v("#")]),a._v(" 3.2、Map")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("HashMap")]),a._v("：\n"),s("ul",[s("li",[a._v("1.7以前：数组 + 链表")]),a._v(" "),s("li",[a._v("1.8以后：数组 + 链表/红黑二叉树")])])]),a._v(" "),s("li",[s("strong",[a._v("HashTable")]),a._v("：\n"),s("ul",[s("li",[a._v("数组 + 链表")])])]),a._v(" "),s("li",[s("strong",[a._v("ConcurrentHashMap")]),a._v("：\n"),s("ul",[s("li",[a._v("1.7以前：数组 + 链表（分段锁）")]),a._v(" "),s("li",[a._v("1.8以后：Node数组 + 链表/红黑二叉树（只锁定当前链表或红黑二叉树的首节点）")])])]),a._v(" "),s("li",[s("strong",[a._v("TreeMap")]),a._v("：红黑树（自平衡的排序二叉树）")]),a._v(" "),s("li",[s("strong",[a._v("LinkedHashMap")]),a._v("："),s("code",[a._v("继承")]),a._v("自 HashMap，在 HashMap 基础上，通过维护一条"),s("code",[a._v("双向链表")]),a._v("，解决了 HashMap 不能随时"),s("code",[a._v("保持遍历顺序和插入顺序一致")]),a._v("的问题（"),s("a",{attrs:{href:"https://www.imooc.com/article/22931",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考"),s("OutboundLink")],1),a._v("）")])]),a._v(" "),s("h4",{attrs:{id:"_3-3、set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、set"}},[a._v("#")]),a._v(" 3.3、Set")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("HashSet（无序、唯一）")]),a._v("：基于 HashMap 实现的，底层采用 HashMap 来保存元素")]),a._v(" "),s("li",[s("strong",[a._v("LinkedHashSet")]),a._v("： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。")]),a._v(" "),s("li",[s("strong",[a._v("TreeSet（有序，唯一）")]),a._v("： 红黑树(自平衡的排序二叉树，需要重写"),s("code",[a._v("Compare")]),a._v("或者"),s("code",[a._v("CompareTo")]),a._v("方法)")]),a._v(" "),s("li",[s("strong",[s("a",{attrs:{href:"https://blog.csdn.net/lijock/article/details/80410202",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考"),s("OutboundLink")],1)])])]),a._v(" "),s("h4",{attrs:{id:"_3-4、集合的选用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、集合的选用"}},[a._v("#")]),a._v(" 3.4、集合的选用")]),a._v(" "),s("ul",[s("li",[a._v("主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。")])]),a._v(" "),s("p"),a._v(" "),s("h2",{attrs:{id:"四、参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、参考"}},[a._v("#")]),a._v(" 四、参考")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://www.jianshu.com/p/4d3cb99d7580",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考一"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://snailclimb.top/JavaGuide/#/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=collection",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考二"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=n.exports}}]);