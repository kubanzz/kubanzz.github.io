(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{396:function(t,e,a){"use strict";a.r(e);var v=a(12),n=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、netty基础理论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、netty基础理论"}},[t._v("#")]),t._v(" 一、Netty基础理论")]),t._v(" "),e("h4",{attrs:{id:"什么是netty"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是netty"}},[t._v("#")]),t._v(" 什么是Netty")]),t._v(" "),e("blockquote",[e("p",[t._v("Netty是 一个异步事件驱动的网络应用程序框架，用于开发的高性能协议服务器和客户端。Netty本质是上对Java NIO的封装，采用"),e("strong",[t._v("Reactor线程模型")]),t._v("（"),e("em",[t._v("Selector")]),t._v("（多路复用）器、"),e("em",[t._v("Acceptor")]),t._v("、"),e("em",[t._v("Handler")]),t._v("）、"),e("strong",[t._v("零拷贝")]),t._v("技术，极大的提升了socket通信性能。")])]),t._v(" "),e("h4",{attrs:{id:"netty的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty的特点"}},[t._v("#")]),t._v(" Netty的特点")]),t._v(" "),e("blockquote",[e("p",[t._v("高并发、传输快和封装好")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("高并发")]),t._v("：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的"),e("strong",[t._v("网络通信框架")]),t._v("，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。")]),t._v(" "),e("li",[e("strong",[t._v("传输快")]),t._v("：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。")]),t._v(" "),e("li",[e("strong",[t._v("封装好")]),t._v("：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。")])])]),t._v(" "),e("h4",{attrs:{id:"netty的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty的应用场景"}},[t._v("#")]),t._v(" Netty的应用场景")]),t._v(" "),e("blockquote",[e("p",[t._v("Netty主要作为基础通信框架提供高性能、低延时的通信服务。可用于构建高性能、低延时的各种Java中间件，例如阿里分布式服务框架 Dubbo、 RocketMQ 默认使用 Netty 作为通讯框架。")]),t._v(" "),e("p",[t._v("在个人开发的项目中，主要用来作为基础设备通信框架，例如采用NIO做情报板、水电表数据及基础设备信息的采集。")]),t._v(" "),e("ul",[e("li",[t._v("情报板通信：停车位自动发布，其发布过程分为四个阶段，1.删除旧文件 2.创建文件 3.下发文件 4. 播放文")]),t._v(" "),e("li",[t._v("设备状态采集：通过SNMP协议，NIO获取并异步更新设备状态")])])]),t._v(" "),e("h2",{attrs:{id:"二、netty架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、netty架构"}},[t._v("#")]),t._v(" 二、Netty架构")]),t._v(" "),e("h4",{attrs:{id:"netty的处理流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty的处理流程"}},[t._v("#")]),t._v(" Netty的处理流程")]),t._v(" "),e("ul",[e("li",[t._v("（以服务端为例子）")])]),t._v(" "),e("ol",[e("li",[t._v("创建ServerBootstrap启动器\n"),e("ul",[e("li",[t._v("绑定Reactor线程池")]),t._v(" "),e("li",[t._v("绑定NIO SocketChannel")]),t._v(" "),e("li",[t._v("绑定ChannelHandler")]),t._v(" "),e("li",[t._v("绑定端口并通过Selector轮询监听")])])]),t._v(" "),e("li",[t._v("客户端通过"),e("strong",[t._v("IP + 端口")]),t._v("连接服务端")]),t._v(" "),e("li",[t._v("服务端监听到连接，创建channel注册到服务端的EventLoopGroup（类似于线程池）")]),t._v(" "),e("li",[t._v("EventLoopGroup分发channel到具体的EventLoop，每个EventLoop管理并监听多个channel")]),t._v(" "),e("li",[t._v("EventLoop监听到客户端channel的IO事件，调用ChannelPipeline中的入站handler进行处理")]),t._v(" "),e("li",[t._v("handler进行解析、执行业务，通过channel将结果发送到出站handler，由其进行包的封装")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimagesCiqc1F-NO9KAUOtaAAE1S5uRlDE275.png",alt:"Drawing 1.png"}})]),t._v(" "),e("ul",[e("li",[t._v("服务端")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220903114749308.png",alt:"image-20220903114749308"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220903114818970.png",alt:"image-20220903114818970"}})]),t._v(" "),e("ul",[e("li",[t._v("客户端")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontents.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220903114843180.png",alt:"image-20220903114843180"}})])])}),[],!1,null,null,null);e.default=n.exports}}]);