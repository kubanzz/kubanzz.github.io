<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>自我介绍 | Java 知识体系</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI&amp;CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目...">
    <meta name="robots" content="all">
    <meta name="author" content="pdai">
    <meta name="keywords" content="Java 全栈知识体系, java体系, java知识体系, java框架,java详解,java学习路线,java spring, java面试, 知识体系, java技术体系, java编程, java编程指南,java开发体系, java开发,java教程,java,java数据结构, 算法, 开发基础">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <link rel="preload" href="/assets/css/0.styles.2e713c08.css" as="style"><link rel="preload" href="/assets/js/app.1c337853.js" as="script"><link rel="preload" href="/assets/js/3.b02e7092.js" as="script"><link rel="preload" href="/assets/js/53.78d19eef.js" as="script"><link rel="prefetch" href="/assets/js/10.ceb3101a.js"><link rel="prefetch" href="/assets/js/100.b09a4b02.js"><link rel="prefetch" href="/assets/js/101.c905564f.js"><link rel="prefetch" href="/assets/js/102.b0347c86.js"><link rel="prefetch" href="/assets/js/103.0b941500.js"><link rel="prefetch" href="/assets/js/104.aa9d77de.js"><link rel="prefetch" href="/assets/js/105.4cbc1bc6.js"><link rel="prefetch" href="/assets/js/106.6a6b364e.js"><link rel="prefetch" href="/assets/js/107.4376147f.js"><link rel="prefetch" href="/assets/js/108.72d51d06.js"><link rel="prefetch" href="/assets/js/109.df0075ec.js"><link rel="prefetch" href="/assets/js/11.99f846c6.js"><link rel="prefetch" href="/assets/js/110.57cc32a8.js"><link rel="prefetch" href="/assets/js/111.982f4d8b.js"><link rel="prefetch" href="/assets/js/112.38bfda33.js"><link rel="prefetch" href="/assets/js/113.2d834ece.js"><link rel="prefetch" href="/assets/js/114.7600e6b5.js"><link rel="prefetch" href="/assets/js/115.c53dd888.js"><link rel="prefetch" href="/assets/js/116.dd8a6a65.js"><link rel="prefetch" href="/assets/js/117.8511fe15.js"><link rel="prefetch" href="/assets/js/118.ade530c5.js"><link rel="prefetch" href="/assets/js/119.f23bf053.js"><link rel="prefetch" href="/assets/js/12.743bef58.js"><link rel="prefetch" href="/assets/js/120.e0a8b7ea.js"><link rel="prefetch" href="/assets/js/121.ffc1f611.js"><link rel="prefetch" href="/assets/js/122.42847824.js"><link rel="prefetch" href="/assets/js/123.50e0eada.js"><link rel="prefetch" href="/assets/js/124.25d50192.js"><link rel="prefetch" href="/assets/js/125.e17385d1.js"><link rel="prefetch" href="/assets/js/126.904ed144.js"><link rel="prefetch" href="/assets/js/127.5a938814.js"><link rel="prefetch" href="/assets/js/128.b353e3a1.js"><link rel="prefetch" href="/assets/js/129.2c18e0d3.js"><link rel="prefetch" href="/assets/js/13.adb5d444.js"><link rel="prefetch" href="/assets/js/130.69a2b37b.js"><link rel="prefetch" href="/assets/js/131.c02089a1.js"><link rel="prefetch" href="/assets/js/132.bc2caf02.js"><link rel="prefetch" href="/assets/js/133.5b625fea.js"><link rel="prefetch" href="/assets/js/134.c0444d3e.js"><link rel="prefetch" href="/assets/js/135.570145d4.js"><link rel="prefetch" href="/assets/js/136.14dc0146.js"><link rel="prefetch" href="/assets/js/137.5571aeca.js"><link rel="prefetch" href="/assets/js/138.d0e7ecd3.js"><link rel="prefetch" href="/assets/js/139.8122e620.js"><link rel="prefetch" href="/assets/js/14.062ad1e9.js"><link rel="prefetch" href="/assets/js/140.a4157b9e.js"><link rel="prefetch" href="/assets/js/141.a21e8c95.js"><link rel="prefetch" href="/assets/js/142.b77c9e6a.js"><link rel="prefetch" href="/assets/js/143.6ed28be3.js"><link rel="prefetch" href="/assets/js/144.4ed950c5.js"><link rel="prefetch" href="/assets/js/145.defcbdcf.js"><link rel="prefetch" href="/assets/js/146.1601f6b6.js"><link rel="prefetch" href="/assets/js/147.bcf8cfce.js"><link rel="prefetch" href="/assets/js/148.06c95943.js"><link rel="prefetch" href="/assets/js/149.89cf96c2.js"><link rel="prefetch" href="/assets/js/15.b9719217.js"><link rel="prefetch" href="/assets/js/150.40482dd5.js"><link rel="prefetch" href="/assets/js/151.5c02beef.js"><link rel="prefetch" href="/assets/js/152.1c7a84a6.js"><link rel="prefetch" href="/assets/js/153.fde1ee98.js"><link rel="prefetch" href="/assets/js/154.11c91a1d.js"><link rel="prefetch" href="/assets/js/155.083704c8.js"><link rel="prefetch" href="/assets/js/156.5463b99a.js"><link rel="prefetch" href="/assets/js/157.560a333f.js"><link rel="prefetch" href="/assets/js/158.299f1eab.js"><link rel="prefetch" href="/assets/js/159.9abe708d.js"><link rel="prefetch" href="/assets/js/16.fca7d7b7.js"><link rel="prefetch" href="/assets/js/160.4ff46a0f.js"><link rel="prefetch" href="/assets/js/161.a6c486b5.js"><link rel="prefetch" href="/assets/js/162.bef29922.js"><link rel="prefetch" href="/assets/js/163.7cf2468e.js"><link rel="prefetch" href="/assets/js/164.27c6a07e.js"><link rel="prefetch" href="/assets/js/165.9279b6b4.js"><link rel="prefetch" href="/assets/js/166.1246f61a.js"><link rel="prefetch" href="/assets/js/167.9c2dbfa7.js"><link rel="prefetch" href="/assets/js/168.a40fd447.js"><link rel="prefetch" href="/assets/js/169.eaaa3b21.js"><link rel="prefetch" href="/assets/js/17.63c7bd06.js"><link rel="prefetch" href="/assets/js/170.38b55274.js"><link rel="prefetch" href="/assets/js/171.0aa03f11.js"><link rel="prefetch" href="/assets/js/172.a9b46f05.js"><link rel="prefetch" href="/assets/js/173.79282476.js"><link rel="prefetch" href="/assets/js/174.c0183c86.js"><link rel="prefetch" href="/assets/js/175.478a47f9.js"><link rel="prefetch" href="/assets/js/176.75a5a27f.js"><link rel="prefetch" href="/assets/js/18.52e671f4.js"><link rel="prefetch" href="/assets/js/19.448d0875.js"><link rel="prefetch" href="/assets/js/20.2cef79e7.js"><link rel="prefetch" href="/assets/js/21.aa3006bb.js"><link rel="prefetch" href="/assets/js/22.710d6e2c.js"><link rel="prefetch" href="/assets/js/23.ad2e9c92.js"><link rel="prefetch" href="/assets/js/24.020145fe.js"><link rel="prefetch" href="/assets/js/25.ada5f251.js"><link rel="prefetch" href="/assets/js/26.d22d138b.js"><link rel="prefetch" href="/assets/js/27.b3cf1201.js"><link rel="prefetch" href="/assets/js/28.5ff0bfb8.js"><link rel="prefetch" href="/assets/js/29.485f2b8b.js"><link rel="prefetch" href="/assets/js/30.2317d6ce.js"><link rel="prefetch" href="/assets/js/31.c4451eaa.js"><link rel="prefetch" href="/assets/js/32.6b847218.js"><link rel="prefetch" href="/assets/js/33.87c3b3aa.js"><link rel="prefetch" href="/assets/js/34.e38c6dd2.js"><link rel="prefetch" href="/assets/js/35.d279db47.js"><link rel="prefetch" href="/assets/js/36.f753589b.js"><link rel="prefetch" href="/assets/js/37.4a6a2e39.js"><link rel="prefetch" href="/assets/js/38.ae8bd94d.js"><link rel="prefetch" href="/assets/js/39.c59385c5.js"><link rel="prefetch" href="/assets/js/4.775276f1.js"><link rel="prefetch" href="/assets/js/40.ec09fa5c.js"><link rel="prefetch" href="/assets/js/41.38dd0189.js"><link rel="prefetch" href="/assets/js/42.eb939c7b.js"><link rel="prefetch" href="/assets/js/43.89c78c22.js"><link rel="prefetch" href="/assets/js/44.79d9957a.js"><link rel="prefetch" href="/assets/js/45.2d86fd58.js"><link rel="prefetch" href="/assets/js/46.b9bc9b70.js"><link rel="prefetch" href="/assets/js/47.ada08b04.js"><link rel="prefetch" href="/assets/js/48.539528a1.js"><link rel="prefetch" href="/assets/js/49.6fbfbbaa.js"><link rel="prefetch" href="/assets/js/5.eee55e85.js"><link rel="prefetch" href="/assets/js/50.3c0cf41c.js"><link rel="prefetch" href="/assets/js/51.5325c960.js"><link rel="prefetch" href="/assets/js/52.3b1cd138.js"><link rel="prefetch" href="/assets/js/54.5e468d37.js"><link rel="prefetch" href="/assets/js/55.d9a8dcb6.js"><link rel="prefetch" href="/assets/js/56.9d93de98.js"><link rel="prefetch" href="/assets/js/57.f21c715f.js"><link rel="prefetch" href="/assets/js/58.1475a83f.js"><link rel="prefetch" href="/assets/js/59.819b29ae.js"><link rel="prefetch" href="/assets/js/6.8e026274.js"><link rel="prefetch" href="/assets/js/60.41a3a7a0.js"><link rel="prefetch" href="/assets/js/61.e83bc878.js"><link rel="prefetch" href="/assets/js/62.329c8a5a.js"><link rel="prefetch" href="/assets/js/63.169b3b2c.js"><link rel="prefetch" href="/assets/js/64.47f034f3.js"><link rel="prefetch" href="/assets/js/65.0d8bd679.js"><link rel="prefetch" href="/assets/js/66.d23e9e5e.js"><link rel="prefetch" href="/assets/js/67.f9abb6fc.js"><link rel="prefetch" href="/assets/js/68.67f072df.js"><link rel="prefetch" href="/assets/js/69.a733e18a.js"><link rel="prefetch" href="/assets/js/7.c5a82798.js"><link rel="prefetch" href="/assets/js/70.752d07fc.js"><link rel="prefetch" href="/assets/js/71.c171bfd0.js"><link rel="prefetch" href="/assets/js/72.ebcd692e.js"><link rel="prefetch" href="/assets/js/73.00dab538.js"><link rel="prefetch" href="/assets/js/74.7cbd77ae.js"><link rel="prefetch" href="/assets/js/75.fad5345b.js"><link rel="prefetch" href="/assets/js/76.a5544c13.js"><link rel="prefetch" href="/assets/js/77.153c5242.js"><link rel="prefetch" href="/assets/js/78.dd6275bf.js"><link rel="prefetch" href="/assets/js/79.824b3d5e.js"><link rel="prefetch" href="/assets/js/8.dc522fd4.js"><link rel="prefetch" href="/assets/js/80.a40f869a.js"><link rel="prefetch" href="/assets/js/81.45fe78e3.js"><link rel="prefetch" href="/assets/js/82.cec07a57.js"><link rel="prefetch" href="/assets/js/83.4b57cb83.js"><link rel="prefetch" href="/assets/js/84.c39ee6cb.js"><link rel="prefetch" href="/assets/js/85.a32409a4.js"><link rel="prefetch" href="/assets/js/86.16a7b081.js"><link rel="prefetch" href="/assets/js/87.2c4f62cb.js"><link rel="prefetch" href="/assets/js/88.bd227216.js"><link rel="prefetch" href="/assets/js/89.ac4201b8.js"><link rel="prefetch" href="/assets/js/9.df3cd7fc.js"><link rel="prefetch" href="/assets/js/90.bf6b197a.js"><link rel="prefetch" href="/assets/js/91.9ba4ee3f.js"><link rel="prefetch" href="/assets/js/92.2972038d.js"><link rel="prefetch" href="/assets/js/93.5f3249d9.js"><link rel="prefetch" href="/assets/js/94.4da2a6f4.js"><link rel="prefetch" href="/assets/js/95.8ee0a7a7.js"><link rel="prefetch" href="/assets/js/96.6c75956c.js"><link rel="prefetch" href="/assets/js/97.eb069d33.js"><link rel="prefetch" href="/assets/js/98.d099974a.js"><link rel="prefetch" href="/assets/js/99.f53424f3.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.63928db4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2e713c08.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Java 知识体系</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/Go/Go基础-语法,反射,并发.html" class="nav-link">
  Go基础-语法,反射,并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          JVM相关
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/JVM相关/JVM进阶-JMM, GC, OOM.html" class="nav-link">
  JVM进阶-JMM, GC, OOM
</a></li><li class="dropdown-subitem"><a href="/posts/Java/JVM相关/JVM进阶-常见OOM, MAT, JVM参数.html" class="nav-link">
  JVM进阶-常见OOM, MAT, JVM参数
</a></li></ul></li><li class="dropdown-item"><h4>
          Java并发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/AQS抽象队列同步器.html" class="nav-link">
  AQS抽象队列同步器
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Java并发原则.html" class="nav-link">
  Java并发原则
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Java并发基础.html" class="nav-link">
  Java并发基础
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Synchronize关键字.html" class="nav-link">
  Synchronize关键字
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Volatile关键字.html" class="nav-link">
  Volatile关键字
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/线程安全 - 原子操作, 死锁.html" class="nav-link">
  线程安全 - 原子操作, 死锁
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/线程池与数据库连接池的区别.html" class="nav-link">
  线程池与数据库连接池的区别
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/posts/Java/Java版本特性.html" class="nav-link">
  Java版本特性
</a></li><li class="dropdown-item"><h4>
          Java集合框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/Java集合框架/HashMap.html" class="nav-link">
  HashMap
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java集合框架/Java容器基础-Map, List, Set.html" class="nav-link">
  Java容器基础-Map, List, Set
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/算法/leetcode100.html" class="nav-link">
  leetcode100
</a></li><li class="dropdown-item"><!----> <a href="/posts/算法/排序算法.html" class="nav-link">
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/posts/算法/算法框架学习.html" class="nav-link">
  算法框架学习
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架｜中间件" class="dropdown-title"><span class="title">框架｜中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架｜中间件" class="mobile-dropdown-title"><span class="title">框架｜中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          kafka
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/kafka/Kafka基础-架构, 组件.html" class="nav-link">
  Kafka基础-架构, 组件
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/kafka/kafka进阶-高性能, 高可用, 高可靠.html" class="nav-link">
  kafka进阶-高性能, 高可用, 高可靠
</a></li></ul></li><li class="dropdown-item"><h4>
          netty
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty基础-基础理论, 架构.html" class="nav-link">
  Netty基础-基础理论, 架构
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty实战-Modbus.html" class="nav-link">
  Netty实战-Modbus
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty实战-情报板.html" class="nav-link">
  Netty实战-情报板
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty进阶-IO, 线程模型, 零拷贝.html" class="nav-link">
  Netty进阶-IO, 线程模型, 零拷贝
</a></li></ul></li><li class="dropdown-item"><h4>
          redis
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis基础-常用命令.html" class="nav-link">
  Redis基础-常用命令
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis基础-数据结构.html" class="nav-link">
  Redis基础-数据结构
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-管道, 事务, 持久化.html" class="nav-link">
  Redis进阶-管道, 事务, 持久化
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-缓存雪崩, 击穿, 穿透.html" class="nav-link">
  Redis进阶-缓存雪崩, 击穿, 穿透
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-高可用模式.html" class="nav-link">
  Redis进阶-高可用模式
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/其他/Nginx的安装及负载均衡.html" class="nav-link">
  Nginx的安装及负载均衡
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Quartz核心知识.html" class="nav-link">
  Quartz核心知识
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Tomcat配置日志格式.html" class="nav-link">
  Tomcat配置日志格式
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Tomcat集群部署.html" class="nav-link">
  Tomcat集群部署
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring" class="mobile-dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Spring Boot
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/Spring AOP实现自动读写分离.html" class="nav-link">
  Spring AOP实现自动读写分离
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot2.0静态变量注入及过滤器的使用.html" class="nav-link">
  SpringBoot2.0静态变量注入及过滤器的使用
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot定时任务及redis分布式锁创建.html" class="nav-link">
  SpringBoot定时任务及redis分布式锁创建
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot实现全局异常的捕获.html" class="nav-link">
  SpringBoot实现全局异常的捕获
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Junit4.html" class="nav-link">
  SpringBoot整合Junit4
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Maven实现环境隔离.html" class="nav-link">
  SpringBoot整合Maven实现环境隔离
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Spring Session实现单点登陆.html" class="nav-link">
  SpringBoot整合Spring Session实现单点登陆
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合redis.html" class="nav-link">
  SpringBoot整合redis
</a></li></ul></li><li class="dropdown-item"><h4>
          Spring Cloud
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合ELK.html" class="nav-link">
  SpringCloud整合ELK
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合WebSocket.html" class="nav-link">
  SpringCloud整合WebSocket
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合Zipkin + Slethu.html" class="nav-link">
  SpringCloud整合Zipkin + Slethu
</a></li></ul></li><li class="dropdown-item"><h4>
          Spring Framework
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring AOP.html" class="nav-link">
  Spring AOP
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring Bean.html" class="nav-link">
  Spring Bean
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring IOC.html" class="nav-link">
  Spring IOC
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring高级应用.html" class="nav-link">
  Spring高级应用
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/认证授权（OAuth、JWT）.html" class="nav-link">
  认证授权（OAuth、JWT）
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          MySQL
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL事务隔离级别及Spring事务管理.html" class="nav-link">
  MySQL事务隔离级别及Spring事务管理
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL优化-分表,分库,主从.html" class="nav-link">
  MySQL优化-分表,分库,主从
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL优化-索引.html" class="nav-link">
  MySQL优化-索引
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL进阶-InnoDB存储引擎.html" class="nav-link">
  MySQL进阶-InnoDB存储引擎
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/posts/数据库/数据库建表规则—三大范式.html" class="nav-link">
  数据库建表规则—三大范式
</a></li><li class="dropdown-item"><!----> <a href="/posts/数据库/数据库设计.html" class="nav-link">
  数据库设计
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据" class="dropdown-title"><span class="title">大数据</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据" class="mobile-dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/大数据/Flume收集日志 - windows（实战版一）.html" class="nav-link">
  Flume收集日志 - windows（实战版一）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Flume收集日志 - windows（实战版二）.html" class="nav-link">
  Flume收集日志 - windows（实战版二）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/HBase理论学习与分析.html" class="nav-link">
  HBase理论学习与分析
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Hadoop平台的搭建.html" class="nav-link">
  Hadoop平台的搭建
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Hadoop的设计目标及重要特性.html" class="nav-link">
  Hadoop的设计目标及重要特性
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Oozie学习（基本任务）.html" class="nav-link">
  Oozie学习（基本任务）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Oozie学习（定时任务）.html" class="nav-link">
  Oozie学习（定时任务）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/海量数据处理.html" class="nav-link">
  海量数据处理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具｜运维" class="dropdown-title"><span class="title">工具｜运维</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具｜运维" class="mobile-dropdown-title"><span class="title">工具｜运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          实用工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/实用工具/hugo + github编写个人博客.html" class="nav-link">
  hugo + github编写个人博客
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/实用工具/vuepress + github搭建个人博客.html" class="nav-link">
  vuepress + github搭建个人博客
</a></li></ul></li><li class="dropdown-item"><h4>
          开发工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/IDEA远程连接Hadoop集群.html" class="nav-link">
  IDEA远程连接Hadoop集群
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/IDEA高效开发.html" class="nav-link">
  IDEA高效开发
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/构建工具Q&amp;A（Maven).html" class="nav-link">
  构建工具Q&amp;A（Maven)
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/程序员的工具包.html" class="nav-link">
  程序员的工具包
</a></li></ul></li><li class="dropdown-item"><h4>
          运维部署
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：1、安装及常见命令.html" class="nav-link">
  Docker实战：1、安装及常见命令
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：2、Dockerfile构建镜像.html" class="nav-link">
  Docker实战：2、Dockerfile构建镜像
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：3、三剑客之Docker Compose.html" class="nav-link">
  Docker实战：3、三剑客之Docker Compose
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker的基础概念.html" class="nav-link">
  Docker的基础概念
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/JVM监测工具.html" class="nav-link">
  JVM监测工具
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/阿里云部署SpringBoot.html" class="nav-link">
  阿里云部署SpringBoot
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="方法论" class="dropdown-title"><span class="title">方法论</span> <span class="arrow down"></span></button> <button type="button" aria-label="方法论" class="mobile-dropdown-title"><span class="title">方法论</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/事务理论-ACID.html" class="nav-link">
  事务理论-ACID
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式一致性算法.html" class="nav-link">
  分布式一致性算法
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式事务算法（2PC, 3PC, TCC).html" class="nav-link">
  分布式事务算法（2PC, 3PC, TCC)
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式理论（BASE）.html" class="nav-link">
  分布式理论（BASE）
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式理论（CAP）.html" class="nav-link">
  分布式理论（CAP）
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式规范（XA）.html" class="nav-link">
  分布式规范（XA）
</a></li></ul></li><li class="dropdown-item"><h4>
          开发设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/RESTful.html" class="nav-link">
  RESTful
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/UML.html" class="nav-link">
  UML
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/设计模式.html" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/Go/Go基础-语法,反射,并发.html" class="nav-link">
  Go基础-语法,反射,并发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          JVM相关
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/JVM相关/JVM进阶-JMM, GC, OOM.html" class="nav-link">
  JVM进阶-JMM, GC, OOM
</a></li><li class="dropdown-subitem"><a href="/posts/Java/JVM相关/JVM进阶-常见OOM, MAT, JVM参数.html" class="nav-link">
  JVM进阶-常见OOM, MAT, JVM参数
</a></li></ul></li><li class="dropdown-item"><h4>
          Java并发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/AQS抽象队列同步器.html" class="nav-link">
  AQS抽象队列同步器
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Java并发原则.html" class="nav-link">
  Java并发原则
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Java并发基础.html" class="nav-link">
  Java并发基础
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Synchronize关键字.html" class="nav-link">
  Synchronize关键字
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/Volatile关键字.html" class="nav-link">
  Volatile关键字
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/线程安全 - 原子操作, 死锁.html" class="nav-link">
  线程安全 - 原子操作, 死锁
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java并发框架/线程池与数据库连接池的区别.html" class="nav-link">
  线程池与数据库连接池的区别
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/posts/Java/Java版本特性.html" class="nav-link">
  Java版本特性
</a></li><li class="dropdown-item"><h4>
          Java集合框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Java/Java集合框架/HashMap.html" class="nav-link">
  HashMap
</a></li><li class="dropdown-subitem"><a href="/posts/Java/Java集合框架/Java容器基础-Map, List, Set.html" class="nav-link">
  Java容器基础-Map, List, Set
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/算法/leetcode100.html" class="nav-link">
  leetcode100
</a></li><li class="dropdown-item"><!----> <a href="/posts/算法/排序算法.html" class="nav-link">
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/posts/算法/算法框架学习.html" class="nav-link">
  算法框架学习
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架｜中间件" class="dropdown-title"><span class="title">框架｜中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架｜中间件" class="mobile-dropdown-title"><span class="title">框架｜中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          kafka
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/kafka/Kafka基础-架构, 组件.html" class="nav-link">
  Kafka基础-架构, 组件
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/kafka/kafka进阶-高性能, 高可用, 高可靠.html" class="nav-link">
  kafka进阶-高性能, 高可用, 高可靠
</a></li></ul></li><li class="dropdown-item"><h4>
          netty
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty基础-基础理论, 架构.html" class="nav-link">
  Netty基础-基础理论, 架构
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty实战-Modbus.html" class="nav-link">
  Netty实战-Modbus
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty实战-情报板.html" class="nav-link">
  Netty实战-情报板
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/netty/Netty进阶-IO, 线程模型, 零拷贝.html" class="nav-link">
  Netty进阶-IO, 线程模型, 零拷贝
</a></li></ul></li><li class="dropdown-item"><h4>
          redis
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis基础-常用命令.html" class="nav-link">
  Redis基础-常用命令
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis基础-数据结构.html" class="nav-link">
  Redis基础-数据结构
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-管道, 事务, 持久化.html" class="nav-link">
  Redis进阶-管道, 事务, 持久化
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-缓存雪崩, 击穿, 穿透.html" class="nav-link">
  Redis进阶-缓存雪崩, 击穿, 穿透
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/redis/Redis进阶-高可用模式.html" class="nav-link">
  Redis进阶-高可用模式
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/中间件/其他/Nginx的安装及负载均衡.html" class="nav-link">
  Nginx的安装及负载均衡
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Quartz核心知识.html" class="nav-link">
  Quartz核心知识
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Tomcat配置日志格式.html" class="nav-link">
  Tomcat配置日志格式
</a></li><li class="dropdown-subitem"><a href="/posts/中间件/其他/Tomcat集群部署.html" class="nav-link">
  Tomcat集群部署
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><span class="title">Spring</span> <span class="arrow down"></span></button> <button type="button" aria-label="Spring" class="mobile-dropdown-title"><span class="title">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Spring Boot
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/Spring AOP实现自动读写分离.html" class="nav-link">
  Spring AOP实现自动读写分离
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot2.0静态变量注入及过滤器的使用.html" class="nav-link">
  SpringBoot2.0静态变量注入及过滤器的使用
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot定时任务及redis分布式锁创建.html" class="nav-link">
  SpringBoot定时任务及redis分布式锁创建
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot实现全局异常的捕获.html" class="nav-link">
  SpringBoot实现全局异常的捕获
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Junit4.html" class="nav-link">
  SpringBoot整合Junit4
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Maven实现环境隔离.html" class="nav-link">
  SpringBoot整合Maven实现环境隔离
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合Spring Session实现单点登陆.html" class="nav-link">
  SpringBoot整合Spring Session实现单点登陆
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Boot/SpringBoot整合redis.html" class="nav-link">
  SpringBoot整合redis
</a></li></ul></li><li class="dropdown-item"><h4>
          Spring Cloud
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合ELK.html" class="nav-link">
  SpringCloud整合ELK
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合WebSocket.html" class="nav-link">
  SpringCloud整合WebSocket
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Cloud/SpringCloud整合Zipkin + Slethu.html" class="nav-link">
  SpringCloud整合Zipkin + Slethu
</a></li></ul></li><li class="dropdown-item"><h4>
          Spring Framework
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring AOP.html" class="nav-link">
  Spring AOP
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring Bean.html" class="nav-link">
  Spring Bean
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring IOC.html" class="nav-link">
  Spring IOC
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/Spring高级应用.html" class="nav-link">
  Spring高级应用
</a></li><li class="dropdown-subitem"><a href="/posts/Spring/Spring Framework/认证授权（OAuth、JWT）.html" class="nav-link">
  认证授权（OAuth、JWT）
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          MySQL
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL事务隔离级别及Spring事务管理.html" class="nav-link">
  MySQL事务隔离级别及Spring事务管理
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL优化-分表,分库,主从.html" class="nav-link">
  MySQL优化-分表,分库,主从
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL优化-索引.html" class="nav-link">
  MySQL优化-索引
</a></li><li class="dropdown-subitem"><a href="/posts/数据库/MySQL/MySQL进阶-InnoDB存储引擎.html" class="nav-link">
  MySQL进阶-InnoDB存储引擎
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/posts/数据库/数据库建表规则—三大范式.html" class="nav-link">
  数据库建表规则—三大范式
</a></li><li class="dropdown-item"><!----> <a href="/posts/数据库/数据库设计.html" class="nav-link">
  数据库设计
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据" class="dropdown-title"><span class="title">大数据</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据" class="mobile-dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/posts/大数据/Flume收集日志 - windows（实战版一）.html" class="nav-link">
  Flume收集日志 - windows（实战版一）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Flume收集日志 - windows（实战版二）.html" class="nav-link">
  Flume收集日志 - windows（实战版二）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/HBase理论学习与分析.html" class="nav-link">
  HBase理论学习与分析
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Hadoop平台的搭建.html" class="nav-link">
  Hadoop平台的搭建
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Hadoop的设计目标及重要特性.html" class="nav-link">
  Hadoop的设计目标及重要特性
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Oozie学习（基本任务）.html" class="nav-link">
  Oozie学习（基本任务）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/Oozie学习（定时任务）.html" class="nav-link">
  Oozie学习（定时任务）
</a></li><li class="dropdown-item"><!----> <a href="/posts/大数据/海量数据处理.html" class="nav-link">
  海量数据处理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具｜运维" class="dropdown-title"><span class="title">工具｜运维</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具｜运维" class="mobile-dropdown-title"><span class="title">工具｜运维</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          实用工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/实用工具/hugo + github编写个人博客.html" class="nav-link">
  hugo + github编写个人博客
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/实用工具/vuepress + github搭建个人博客.html" class="nav-link">
  vuepress + github搭建个人博客
</a></li></ul></li><li class="dropdown-item"><h4>
          开发工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/IDEA远程连接Hadoop集群.html" class="nav-link">
  IDEA远程连接Hadoop集群
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/IDEA高效开发.html" class="nav-link">
  IDEA高效开发
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/构建工具Q&amp;A（Maven).html" class="nav-link">
  构建工具Q&amp;A（Maven)
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/开发工具/程序员的工具包.html" class="nav-link">
  程序员的工具包
</a></li></ul></li><li class="dropdown-item"><h4>
          运维部署
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：1、安装及常见命令.html" class="nav-link">
  Docker实战：1、安装及常见命令
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：2、Dockerfile构建镜像.html" class="nav-link">
  Docker实战：2、Dockerfile构建镜像
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker实战：3、三剑客之Docker Compose.html" class="nav-link">
  Docker实战：3、三剑客之Docker Compose
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/Docker的基础概念.html" class="nav-link">
  Docker的基础概念
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/JVM监测工具.html" class="nav-link">
  JVM监测工具
</a></li><li class="dropdown-subitem"><a href="/posts/开发运维/运维部署/阿里云部署SpringBoot.html" class="nav-link">
  阿里云部署SpringBoot
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="方法论" class="dropdown-title"><span class="title">方法论</span> <span class="arrow down"></span></button> <button type="button" aria-label="方法论" class="mobile-dropdown-title"><span class="title">方法论</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础理论
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/事务理论-ACID.html" class="nav-link">
  事务理论-ACID
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式一致性算法.html" class="nav-link">
  分布式一致性算法
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式事务算法（2PC, 3PC, TCC).html" class="nav-link">
  分布式事务算法（2PC, 3PC, TCC)
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式理论（BASE）.html" class="nav-link">
  分布式理论（BASE）
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式理论（CAP）.html" class="nav-link">
  分布式理论（CAP）
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/基础理论/分布式规范（XA）.html" class="nav-link">
  分布式规范（XA）
</a></li></ul></li><li class="dropdown-item"><h4>
          开发设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/RESTful.html" class="nav-link">
  RESTful
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/UML.html" class="nav-link">
  UML
</a></li><li class="dropdown-subitem"><a href="/posts/方法论/开发设计/设计模式.html" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="自我介绍"><a href="#自我介绍" class="header-anchor">#</a> 自我介绍</h1> <p>​		面试官你好，我叫曾博佳，毕业于北京师范大学珠海分校软件工程专业。开发技能上主要以Java语言为主，有扎实的Java基础和良好的编码风格，熟悉并发编程、JVM及锁知识，开发模式上熟悉以SpringBoot、SpringCloud为主的Web开发模式，但是最近有人了解到Go语言，也有意愿学习和转语言。目前的工作经历主要有两段，第一是做国际航运生命周期编排系统开发，特点是采用敏捷开发、微服务开发，采用K8S服务网格做微服务容器编排和部署。第二是在一家交通行业公司做智慧服务区的开发，它的特点主要是物联网、基础设备状态采集、微服务开发。最后做是简单的自我评价，我是一个比较上进，有较好的自我驱动力及自律能力，有机会的话希望能够进入到公司，跟优秀的人一起干有挑战性的事。</p> <h1 id="简历知识点"><a href="#简历知识点" class="header-anchor">#</a> 简历知识点</h1> <h3 id="整理扫盲"><a href="#整理扫盲" class="header-anchor">#</a> 整理扫盲</h3> <ul><li><strong>专业技能</strong> <ul><li>并发编程经验：
<ul><li>线程池开发</li> <li>多线程下的单例（例如建立连接并缓存连接channel）</li> <li>并发集合：ConcurrentHashMap、CopyOnWriteArrayList</li> <li>同步锁：哪里用到了锁？</li></ul></li> <li>分布式理论：
<ul><li>CAP、BASE、2PC、Gossip（凤凰）、ZAB理论和分布式事务、一致性算法的区别？</li></ul></li></ul></li> <li>分布式锁：
<ul><li>Redisson分布式锁实现（看门狗、RedLock）</li> <li>Zookeeper分布式锁实现，Zookeeper底层原理</li> <li>MySQL表分布式锁实现，Quartz原理
<ul><li>Quartz原理：<a href="https://juejin.cn/post/7063698731488509966" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>基本组件及架构</li> <li>基于数据库表的分布式锁</li> <li>自动故障转移</li></ul></li></ul></li></ul></li> <li>分布式事务：
<ul><li>强事务、柔性事务、TCC</li> <li>本地消息表最终一致性：https://juejin.cn/post/6844903951448408071</li></ul></li> <li>Drools
<ul><li>决策树模型理解</li> <li>分布式缓存处理？</li></ul></li> <li>设计模式：
<ul><li>适配器模式</li> <li>工厂模式</li></ul></li></ul> <h3 id="面试流程"><a href="#面试流程" class="header-anchor">#</a> 面试流程</h3> <blockquote><p>初筛 ：HR主要的工作就是快速扫视你的简历，主要目的是获取类似与年龄、学历、工作经验等硬性信息。</p> <p>复筛：从初筛中挑选出部分简历，此时主要比较学历、工作经历</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesPl8g2uc6Dag8X4vcpoiR.png" alt="img"></p> <h1 id="面试记录"><a href="#面试记录" class="header-anchor">#</a> 面试记录</h1> <p>CVTE一轮面试：</p> <ol><li><p>JVM</p> <ol><li>旧系统的OOM？OOM如何做检测和检查？</li></ol> <blockquote><ol><li>使用系统工具：通过在线内存监控工具监测，例如<code>VisualVM、JConsole</code>，或者系统自带的内存监控命令，例如<code>top、free</code>命令等查看JVM内存。</li> <li>配置警报：通过整合监控报警框架，例如<code>Zabbix、Prometheus</code>配置内存使用率阈值，当内存使用率达到阈值时，监控工具将触发警报。</li> <li>编写脚本：可以编写脚本，定期检查内存使用情况，如果发现内存使用率较高，则发送警报或执行其他操作。</li></ol> <p>对于OOM后打印的文件，可以通过MAT、VisualVM等进行检查分析</p></blockquote> <ol><li>垃圾回收器
<ol><li>垃圾回收器有哪些？G1和CMS的区别？回收流程是什么？适合在什么场景？</li> <li>新生代老年代的垃圾回收策略</li></ol></li> <li>标记-整理和标记-清除的区别？</li> <li>做过哪些JVM上的优化？</li></ol> <blockquote><p>实践：</p> <ol><li>堆大小的调整，根据系统的内存情况和应用程序的内存需求，调整 JVM 的堆大小，以最大程度地利用内存。<code>-Xms、-Xmx</code>。</li> <li>调整堆最大最小一致，防止动态扩容导致的启动时频繁GC<code>-Xms、-Xmx</code>。</li> <li>添加辅助参数，例如<code>-XX:+HeapDumpOnOutOfMemoryError</code></li></ol> <p>其他：</p> <ol><li><p>替换垃圾回收器，例如在服务器内存、CPU性能高的情况下，可以采用G1垃圾回收器</p> <ul><li><code>-XX:+UseG1GC</code>、<code>-XX:+UseConcMarkSweepGC</code></li></ul></li> <li><p>调整年轻代、老年代占比</p> <ul><li><p><code>-Xmn</code>：调整年轻代内存大小。</p></li> <li><p><code>-XX:SurvivorRatio</code>：可以调整<strong>年轻代</strong>的Eden、S0、S1的比例，例如参数等于6，则S0、S1、Eden的比例为1:1:6。</p></li> <li><p><code>-XX:NewRatio</code>：可以调整年轻代老年代内存占比，2则表示年轻代：老年代为2：1。</p></li></ul></li> <li><p>设置JVM线程栈大小</p> <ul><li><code>-XX:ThreadStackSize</code>：可以用于设置线程栈的大小</li></ul></li></ol></blockquote> <ol><li>如何检查线程数量，可以通过哪些方式去检查？JDK自带哪些工具？</li></ol> <blockquote><ol><li>通过JMX工具查看，例如JConsole、VisualVM</li> <li>Java API获取</li></ol> <ul><li><code>ManagementFactory</code></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ThreadMXBean</span> threadBean <span class="token operator">=</span> <span class="token class-name">ManagementFactory</span><span class="token punctuation">.</span><span class="token function">getThreadMXBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> threadCount <span class="token operator">=</span> threadBean<span class="token punctuation">.</span><span class="token function">getThreadCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Active Threads: &quot;</span> <span class="token operator">+</span> threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><code>Thread</code></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">getAllStackTraces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>JDK自带的工具
<ul><li><code>jstack</code>：导出线程快照</li></ul></li></ol></blockquote></li> <li><p>项目</p> <ol><li><p>旧系统为什么要进行拆分？</p> <ol><li>出现OOM？哪些OOM？内存泄露？线程创建过多？</li> <li>线上部署了几个实例？</li> <li>服务耦合，相互影响，版本控制困难。</li></ol> <blockquote><ol><li>提高系统可扩展性：微服务拆分使得系统可以更容易扩展，因为每个微服务都是独立的，可以单独部署和维护。</li> <li>提高系统可靠性：微服务拆分使得系统具有更高的可靠性，因为如果一个微服务出现故障，不会影响整个系统的正常运行。</li> <li>提高开发效率：微服务拆分使得系统的开发和维护效率更高，因为开发人员可以更加关注特定的业务领域，而不是需要考虑整个系统的复杂性。</li> <li>提高系统可用性：微服务拆分使得系统具有更高的可用性，因为系统可以更容易地恢复和更新。</li></ol></blockquote></li> <li><p>微服务监控怎么做的？如何评估服务需要扩容？如何及时发现系统异常情况？</p></li> <li><p>难点是什么？如何解决的？</p></li> <li><p>拆分成多少个服务？微服务拆分时间多长？</p></li> <li><p>数据库也是做了拆分吗？按数据表做垂直拆分？保证数据一致性（分布式事务）</p></li> <li><p>单表数据量是多大？</p></li> <li><p>采用了什么消息队列？为什么要用消息队列做服务通信而不用spring cloud？</p></li> <li><p>项目采用了DDD，在微服务中DDD是如何分层的？</p></li> <li><p>自己学习了什么知识？应用到项目了吗？</p> <ol><li>分布式事务</li> <li>分布式ID</li> <li>redis bitmap</li> <li>幂等性处理、有序性处理、可靠性处理</li> <li>netty nio采集</li></ol></li></ol></li> <li><p>MySQL（回答的还可以）</p> <ol><li>如何进行优化？</li> <li>索引结构有哪些？</li> <li>有做分库分表吗？</li> <li>MySQL锁有哪些？间隙锁的作用是什么？（隔离级别：可重复读，解决幻读）</li> <li>需要重点了解：死锁及解决思路</li></ol></li></ol> <h1 id="面试准备"><a href="#面试准备" class="header-anchor">#</a> 面试准备</h1> <ul><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/es-architecture" target="_blank" rel="noopener noreferrer">中国石杉Java进阶知识扫盲<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/search?search_type=0&amp;query=%E3%80%8A%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%BF%9B%E5%A4%A7%E5%8E%82%E3%80%8B" target="_blank" rel="noopener noreferrer">我们一起进大厂系列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.pdai.tech/md/java/java8up/java9-11.html" target="_blank" rel="noopener noreferrer">pdai大佬<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener noreferrer">敖丙大佬<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/40%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="noopener noreferrer">技术文章大佬<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <h3 id="av树-红黑树-b树-b-树的区别"><a href="#av树-红黑树-b树-b-树的区别" class="header-anchor">#</a> AV树/红黑树/B树/B+树的区别</h3> <ul><li><a href="https://blog.csdn.net/whoamiyang/article/details/51926985" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h2> <h3 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h3> <ul><li><a href="https://juejin.cn/post/7104117388676694046" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h2> <h3 id="排序算法"><a href="#排序算法" class="header-anchor">#</a> 排序算法</h3> <h4 id="快速排序-普通-双指针"><a href="#快速排序-普通-双指针" class="header-anchor">#</a> 快速排序（普通 + 双指针）</h4> <blockquote><p>不稳定算法</p> <p>算法思想：分而治之（分治思想）</p> <p>时间复杂度：</p> <ul><li>最坏：O(n ^ 2)，数组基本有序并取最左边的作为pivot</li> <li>最好：O(nlog(n))，每次都能平均分割</li> <li>平均：O(nlog(n))</li></ul> <p>空间复杂度：</p> <ul><li>最好：O(logn)：pivot为中间值，树平衡</li> <li>最坏：O(n)：数组基本有序，取第一个数作为pivot会导致生成树不平衡，数高度=数组长度</li> <li>平均：O(logn)</li></ul></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>public int[] sortArray(int[] nums) {

    quickSort(nums, 0, nums.length - 1);

    return nums;
}

public void quickSort(int[] nums, int left, int right){
    if(left &gt;= right){
        return;
    }

    int pIndex = partition(nums, left, right);
    quickSort(nums, left, pIndex - 1);
    quickSort(nums, pIndex + 1, right);
}

// 普通快排
private int partition1(int[] nums, int left, int right){

    int pivot = nums[left];
    int lt = left;

    for(int i = left + 1;i &lt;= right;i ++){
        if(nums[i] &lt;= pivot){
            lt ++;
            swap(nums, i, lt);
        }
    }
    swap(nums, left, lt);

    return lt;
}

// 双指针快排
private int partition2(int[] nums, int left, int right){

    int pivot = nums[left];
    int lt = left;
    int gt = right;

    while(lt &lt; gt){
        while(lt &lt; gt &amp;&amp; nums[gt] &gt;= pivot){
            gt --;
        }

        while(lt &lt; gt &amp;&amp; nums[lt] &lt;= pivot){
            lt ++;
        }

        swap(nums, lt, gt);
    }
    swap(nums, left, lt);

    return lt;
}

private void swap(int[] nums, int left,int right){
    int tmp = nums[left];
    nums[left] = nums[right];
    nums[right] = tmp;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><h4 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h4> <blockquote><p>不稳定算法</p> <p>时间复杂度：</p> <ul><li>平均：O(nlogn)</li> <li>最坏：O(nlogn)</li></ul> <p>空间复杂度：</p> <ul><li>O(1)</li></ul></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>public int[] sortArray(int[] nums) {
    
    // 构建大根堆，堆顶为最大值
    int len = nums.length - 1;
    for(int i = len / 2;i &gt;= 0;i --){
        adjustHeap(nums, i, len);
    }
	
	// 替换堆顶和数组尾，再次调整大根堆，重复提取当前堆的最大值即可完成排序
    for(int i = len;i &gt;=0 ;i --){
        swap(nums, 0, i);
        adjustHeap(nums, 0, i - 1);
    }

    return nums;
}

// k为起始节点
private void adjustHeap(int[] nums, int k, int end){

    while(2 * k + 1 &lt;= end){
        int j = 2 * k + 1;
        if(j + 1 &lt;= end &amp;&amp; nums[j + 1] &gt;= nums[j]){
            j ++;
        }
        if(nums[j] &gt; nums[k]){
        	// 由于发生了替换，所以被替换的子节点需要调整
            swap(nums, j, k);
            k = j;
        }else {
        	// 当前节点已经为所在堆最大值
            break;
        }
    }
}

private void swap(int[] nums, int left, int right){
    int tmp = nums[left];
    nums[left] = nums[right];
    nums[right] = tmp;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h4 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h4> <blockquote><p>稳定算法</p> <p>算法思路：分而治之（分治思想），递归分别排序，并且合并两个排序后的数组</p> <p>时间复杂度：</p> <ul><li>最好、最坏、平均：O(nlogn)</li></ul> <p>空间复杂度：</p> <ul><li>O(n)：需要额外的空间合并数组</li></ul></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>public int[] sortArray(int[] nums) {
    if(nums.length &lt;= 1){
        return nums;
    }
    
    int num = nums.length / 2;
    int[] left = Arrays.copyOfRange(nums, 0, num);
    int[] right = Arrays.copyOfRange(nums, num, nums.length);

    return merge(sortArray(left), sortArray(right));
}


private int[] merge(int[] left, int[] right){
    int len1 = left.length;
    int len2 = right.length;
    int i = 0, j = 0, k = 0;

    int[] res = new int[len1 + len2];
    while(i &lt; len1 &amp;&amp; j &lt; len2){
        if(left[i] &lt; right[j]){
            res[k++] = left[i++];
        }else {
            res[k++] = right[j++];
        }
    }
    while(i &lt; len1){
        res[k++] = left[i++];
    }

    while(j &lt; len2){
        res[k++] = right[j++];
    }

    return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h3 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="header-anchor">#</a> 缓存淘汰算法</h3> <ul><li>FIFO（First in First out）：先进先出算法。思路：先进入缓存的，先被淘汰。</li> <li>LFU（Least Frequently Used）：最近最常使用。思路：最近使用频率最高的更容易被再次使用。</li> <li>LRU（Least Recently User）：最近最少使用。思路：最近被使用的大概率更容易被再次使用。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//手写版</span>

<span class="token keyword">class</span> <span class="token class-name">DLinkNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>

    <span class="token class-name">DLinkNode</span> prev<span class="token punctuation">;</span>
    <span class="token class-name">DLinkNode</span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
<span class="token class-name">DLinkNode</span> dummyHead<span class="token punctuation">;</span>
<span class="token class-name">DLinkNode</span> dummyTrail<span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">&gt;</span></span> cache<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyTrail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyTrail<span class="token punctuation">;</span>
    dummyTrail<span class="token punctuation">.</span>prev <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DLinkNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addNodeToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">DLinkNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">DLinkNode</span> rNode <span class="token operator">=</span> dummyTrail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span>rNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>rNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">DLinkNode</span> nNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addNodeToHead</span><span class="token punctuation">(</span>nNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> nNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addNodeToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">DLinkNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addNodeToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>	

<span class="token comment">/* *********************************** */</span>

<span class="token comment">// java版</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 传递进来最多能缓存多少数据
     *
     * @param capacity 缓存大小
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 如果map中的数据量大于设定的最大容量，返回true，再新加入对象时删除最老的数据
     *
     * @param eldest 最老的数据项
     * @return true则移除最老的数据
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当 map中的数据量大于指定的缓存个数的时候，自动移除最老的数据</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br></div></div><h3 id="校验算法"><a href="#校验算法" class="header-anchor">#</a> 校验算法</h3> <p>完成的数据帧：</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/5rmsa7bv09.jpeg" alt="img"></p> <ul><li>奇偶校验：统计数据中数字1的个数
<ul><li>偶校验位：如果为奇数，则补一个bit1，使得总的1的个数为偶</li> <li>奇校验位：如果为奇数，则补一个bit0，使得总的1的个数为奇</li></ul></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/v2-9c025c1b6d3b754f46375968fba3f26e_b.jpg" alt="img"></p> <ul><li>校验和：
<ul><li>MD5：一种哈希算法，将任何数据转换成固定长度（128）位数的算法，不可逆。</li> <li>CRC：循环冗余校验，是一种对网络数据包进行多项式计算，并得到固定长度位的数据传输检错算法。</li></ul></li></ul> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <h2 id="中间件"><a href="#中间件" class="header-anchor">#</a> 中间件</h2> <h3 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h3> <ul><li>场景：<a href="https://www.nowcoder.com/discuss/953289?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=7A239D7C6F1FE3A8AAC731BCD696C405-1655743167774" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>高频面试题：<a href="https://www.nowcoder.com/discuss/945665?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=7A239D7C6F1FE3A8AAC731BCD696C405-1655743167774" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="说说对redis的了解"><a href="#说说对redis的了解" class="header-anchor">#</a> 说说对Redis的了解</h4> <blockquote><p><strong>what</strong>：</p> <ul><li>下定义</li> <li>特点</li></ul> <p><strong>why</strong>：根据其特点进行解析why</p> <ul><li>为什么使用它？（其特点和传统处理方式的优点，不同框架的对比）</li> <li>为什么拥有特点？（结合how去解析特点）</li></ul> <p><strong>how</strong>：</p> <ul><li>底层实现原理（基本底层原理、特点底层原理）</li> <li>如何使用（编程、应用场景）</li></ul></blockquote> <blockquote><p>答：Redis是一款开源的非关系性数据库，底层采用C语言编写，其特点是：</p> <ul><li><strong>高性能</strong>：Redis基于<strong>内存</strong>进行数据的操作，所以操作性能很高，并且采用<strong>单线程模型</strong>实现数据的存取，避免了多线程下的并发处理及同步处理问题，降低了Redis实现的复杂度。在通信方面，Redis基于Socket进行网络通信，采用<strong>IO多路复用</strong>的IO模型，使得单线程下能够管理多路IO连接，提高IO性能。</li> <li><strong>高可用</strong>：提供集群、主从、哨兵模式</li> <li><strong>高可靠</strong>：提供数据可持久化机制</li> <li><strong>高级数据结构</strong>：五大数据类型</li></ul> <p>基于Redis可以搭建高性能的缓存服务，也可以作为简单的消息队列框架及实现分布式锁，这也是常用的应用场景，而其底层也是利用其数据结构和相关特性实现，例如消息队列基于List数据结构，分布式锁基于setnx原子命令等。在Java中，我们可以通过RestTemplate对Redis进行操作，也可以利用Redision进行加锁解锁处理。</p></blockquote> <h4 id="一条redis命令的执行过程"><a href="#一条redis命令的执行过程" class="header-anchor">#</a> 一条Redis命令的执行过程</h4> <ul><li>参考：<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/01%20Redis%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.md" target="_blank" rel="noopener noreferrer">Redis的执行过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122545.png" alt="image.png"></p> <ol><li>连接建立</li></ol> <blockquote><p>Redis包括客户端与服务端，客户端发送相关执行，服务端负责接收、解析并执行。通常Redis客户端和服务端都在不同的服务器上，Redis基于Socket进行网络通信，采用IO多路复用模型进行Socket连接管理。</p></blockquote> <blockquote><p><strong>I/O 多路复用</strong>：Redis 使用的是 I/O 多路复用功能来监听多 Socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122546.png" alt="IO多路复用.png"></p></blockquote> <ol start="2"><li>客户端发送命令：封装RESP协议</li></ol> <blockquote><p>用户发送命令，客户端会将命令封装成RESP协议（Redis的通信协议），接着通过Socket进行发送。通过协议服务端和客户端之间可以快速理解通信内容。</p></blockquote> <blockquote><p><strong>Socket 小知识</strong>：每个 Socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p></blockquote> <ol start="3"><li>服务端接收命令：解析RESP协议</li></ol> <blockquote><p>数据大小验证：服务器会先去输入缓冲中读取数据，如果数据量大于1G则关闭客户端连接。</p> <p>协议解析：数据大小验证通过后，解析协议并且提取出指令存放在Client对象中（服务端为每个连接创建一个Client对象）</p></blockquote> <ol start="4"><li>执行前的验证准备</li></ol> <blockquote><ol><li><p><strong>用户权限校验</strong>：未通过身份验证的用户只能执行AUTH(授权) 命令</p></li> <li><p><strong>集群相关校验</strong>：</p> <ul><li><p>目标节点重定向：如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</p></li> <li><p>从节点状态效验：当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</p></li> <li><p>只读从节点验证：当此服务器为只读从节点时，只接受 master 的写命令；</p></li></ul></li> <li><p><strong>内存校验</strong>：如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作（引出Redis的缓存清除机制及缓存淘汰算法）；</p></li> <li><p><strong>持久化检测</strong>：检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</p></li> <li><p><strong>事物检验</strong>：如果执行的是事务命令，则开启事务把命令放入等待队列；</p></li></ol></blockquote> <ol start="5"><li>执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</li> <li>执行完后的相关记录和统计</li></ol> <blockquote><ol><li>检查慢查询是否开启，如果开启会记录慢查询日志；</li> <li>检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；</li> <li>检查持久化功能是否开启，如果开启则会记录持久化信息；</li> <li>如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</li></ol></blockquote> <ol start="5"><li>返回结果给客户端</li></ol> <h4 id="redis用在什么场景"><a href="#redis用在什么场景" class="header-anchor">#</a> Redis用在什么场景？</h4> <p><strong>已用</strong></p> <ul><li>缓存热点数据，缓解数据库压力：统计信息、基础用户信息、基础设施信息
<ul><li>缓存击穿场景如何处理？</li></ul></li> <li>幂等性处理（引出Kafka）
<ul><li>四种解决幂等方案：<a href="https://juejin.cn/post/6906290538761158670" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>基于数据库唯一主键：客户端先跟服务器请求分布式ID，再作为主键插入，重复插入会报错。</li> <li>基于数据库乐观锁：在数据库表添加版本字段，保证更新的时候都带版本号。</li> <li>基于Redis + 防重Token：客户端先请求服务器获取token，并存入Redis中，更新的时候先查找Redis是否存在该token，存在则允许更新并删除，不存在则说明是重复消费。</li> <li>基于Redis + 业务唯一序列号（短时间内不重复）：例如订单号、车牌号，客户端请求的时候带上该序列，查找Redis不存在该key则处理业务，并且在处理后存入Redis中，存在则认为是重复消费。</li></ul></li> <li>卡口车辆驶入，会出现重复消费的问题吗？会有的
<ul><li>比如卡口对同一辆车可能会传多份照片</li> <li>Kafka是auto commit机制
<ul><li>如果消费者还没来得及commit就重启，重启后会从kafka拉取未过更新的offset，则会造成重复消费。</li> <li>如果commit了，但是MQ宕机导致接收不到，则重启后会重复消费</li></ul></li></ul></li></ul></li> <li>*bitmap统计设备是否在线，减少数据库压力</li></ul> <p><strong>其他</strong></p> <ul><li>简单消息队列：使用Redis自身的发布/订阅模式或者List来实现简单的消息队列，实现异步操作。</li> <li>分布式锁：利用redis的原子性命令setnx</li> <li>好友关系：利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。</li></ul> <h4 id="redis应用到了哪些数据结构-缓存"><a href="#redis应用到了哪些数据结构-缓存" class="header-anchor">#</a> *Redis应用到了哪些数据结构（缓存）？</h4> <ul><li>已用：
<ul><li>String（缓存统计数据，提高读性能）</li></ul></li></ul> <blockquote><p>Redis的String数据结构称为<strong>SDS对象</strong>，包括了整形和字符串，底层采用<strong>int、emstr、raw</strong>三种数据结构分别对不同长度的字符串申请相应的存储类型，从而有效的节约了空间。</p> <ul><li>int：整型数据</li> <li>emstr：字符串并且长度小于44字节</li> <li>raw：字符串并且长度大于44字节（即SDS对象大于64byte）</li></ul></blockquote> <blockquote><p>为什么是44字节而不是64？</p> <p>因为Redis中每个对象都会包含一个redisObject 对象头，该对象头结构如下：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 总共占用16bytes</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit，对象的数据类型</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit，对象的数据编码</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">// 3 个字节，最近最少使用信息，内存回收时会用到</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">// 4 个字节，引用计数器</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 8 个字节，对象指针，指向具体的内容</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>除了redisObject对象头外，SDS对象还包含自己的数据结构，包括已使用长度、总长度等属性，减完用于存储数据的内存就剩下44bytes。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220807225006177.png" alt="image-20220807225006177"></p></blockquote> <blockquote><p>常用场景：</p> <ul><li><p>页面数据缓存：减少数据库操作，提供性能</p></li> <li><p>数字计算与统计：原子性操作</p></li> <li><p>共享数据：如Session共享</p></li> <li><p>分布式锁：原子性set</p></li></ul></blockquote> <blockquote><p>常用的指令：</p> <ul><li>set k1 1000  val1</li> <li>incrby k3 5：对k3的值+5</li> <li>incr k1：对k1对值自增</li></ul></blockquote> <ul><li>字典-底层基于哈希实现（服务区的map作为缓存）
<ul><li>参考：<a href="https://juejin.cn/post/6987016272143712263" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <blockquote><p>Redis中的字典底层采用哈希表实现</p> <ul><li>ht：包含两个哈希表h0和h1，h1只有在rehash的时候被分配空间使用。
<ul><li>dicht：
<ul><li>table：哈希表包含key和value，底层采用<strong>数组+链表</strong>的方式进行存储，数组用于哈希索引查找元素存储，链表用于解决哈希冲突问题。</li> <li>size：当前的哈希表中的大小</li> <li>sizemask：用于哈希计算下标索引</li> <li>used：当前的元素大小</li></ul></li></ul></li> <li>rehashidx：记录当前rehash的下标，-1表示没有开启rehash，其他表示正在rehash</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesba21aa268514476dac59388ea1fb7089%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p></blockquote> <blockquote><p>常用场景：</p> <ul><li>存储用户信息</li> <li>存储用户购物车信息</li> <li>存储服务区的基础信息</li></ul></blockquote> <blockquote><p>渐进式扩容：</p> <p>由于Redis是采用单线程进行任务处理的，如果同时大数据量的字典的rehash，会导致服务很长时间无法提供服务，为了避免这种情况的发生，Redis采用渐进式rehash的方式。当需要进行扩容操作时，为h1分配内存空间，并且将字典的rehashidx置为0，增量式的将h0的元素rehash到h1，每完成一个rehashidx+1，直到所有元素都被rehash到h1中。在此过程中，get操作会在h0和h1之间进行查找，put操作会直接put到h1，当完成h0的rehash后，将h0指向h1，将h1置为null。该思想类似于写时复制的思想，例如Java中的CopyOnWriteArrayList。</p></blockquote> <ul><li>List（卡口基本数据）</li></ul> <blockquote><p>Redis中的List结构是一个有序链表，底层采用**ziplist（压缩列表）<strong>和</strong>quicklist（快速列表）**实现，当元素比较少的时候，采用ziplist存储，ziplist会开辟一块连续的内存块，减少元素前后指针带来的内存消耗。如果元素比较多，则采用将ziplist转化为qickklist并采用双向链表存储，而qucklistNode本质上就是一个ziplist。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-31230.png" alt="列表类型使用-quicklist结构图.png"></p> <p>ziplist：</p> <ul><li>zlbytes：压缩列表字节长度，占 4 字节</li> <li>zllen：压缩列表的元素个数</li> <li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数</li> <li>zlend：压缩列表的结尾，占 1 字节</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-031231.png" alt="列表类型使用-压缩列表结构图.png"></p> <p>quicklist添加元素的过程：</p> <p>我的理解是，会先判断当前是否为ziplist存储，如果是就在头节点插入，否则创建新的quicklistNode插入。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-28-031232.png" alt="列表类型使用-插入流程图.png"></p></blockquote> <blockquote><p>常用场景：</p> <ul><li>消息队列：lpush、rpop可以实现左进右出</li> <li>文章列表：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</li></ul></blockquote> <blockquote><p>常用指令：</p> <ul><li>查找指定区间元素：lrange key start stop（-1代表到结尾）</li> <li>从链表左边添加元素：lpush key value1</li> <li>从链表右边取出元素：rpop key</li></ul></blockquote> <p>Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。特点是可表达内容少，但是占用空间极低，可以用于统计用户是否在线，设备是否在线等。</p> <ul><li>未用：
<ul><li>SortedSet：有序Set。内部维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。
<ul><li><a href="https://juejin.cn/post/6983810713055658015#heading-13" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/14%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903446475177998#heading-8" target="_blank" rel="noopener noreferrer">*参考三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></li></ul> <blockquote><p>SortedSet是一个有序集合，其存储元素相当于由两个值组成的，一个是集合的元素值，一个是排序值。有序集合<strong>ZSet</strong>底层采用 <strong>ziplist（压缩链表）<strong>或</strong>字典（哈希）</strong>+ <strong>zskiplist (跳跃表)</strong> 组成的。元素数量小于128并且长度都小于64字节，则采用压缩链表，否则采用字典+跳跃表。与Java中的HashMap的链表转红黑树的思想类似，n值比较小时以时间换空间，因为时间可控，n大于某个阈值，则采用空间换时间策略。</p> <ul><li><p>压缩链表：<a href="https://juejin.cn/post/6844903438510194695" target="_blank" rel="noopener noreferrer">ziplist<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是一个经过特殊编码的双向链表，它的设计目标就是为了节约内存，但是查找需要顺序查找，即时间复杂度为O(n)。</p></li> <li><p>字典表：key-vale对应obj-score，查找某元素的排序的时候，可以先通过字典表查找到score，再通过跳表查询对应的元素。</p></li> <li><p>跳表：zskiplist包含头指针和尾指针zskiplistNode，分别指向元素头节点和尾节点，并且包含length和level属性。</p> <ul><li>length属性：元素个数</li> <li>level属性：该跳表最大的层数</li> <li>zskiplistNode：即元素，zskiplistNode包含object、score及level数组，每个元素生成的时候会根据Redis提供的算法随机生成level，level即元素的层数（比如7即代表该元素在1-7层），各个层数通过指针形成单向链表。在Redis中level的最大长度为32，</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// level随机生成算法如下，从概率学上，其保证了产生越高的层数概率越低，保证平均时间为log(n)</span>
<span class="token class-name">MaxLevel</span> <span class="token operator">=</span> <span class="token number">32</span>
p <span class="token operator">=</span> <span class="token number">0.25</span>
<span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    level <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment">// random()返回一个[0...1)的随机数</span>
    <span class="token keyword">while</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> p and level <span class="token operator">&lt;</span> <span class="token class-name">MaxLevel</span> <span class="token keyword">do</span>
        level <span class="token operator">:</span><span class="token operator">=</span> level <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> level
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesb9c4c86dd4b74d0fbfc2619e6d319f74%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="image-20210705150306846"></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images9b97ffa5afac0f5f3ba7.png%7Etplv-t2oaga2asx-zoom-crop-mark%3A3024%3A3024%3A3024%3A1702.awebp" alt="Redis 为什么用跳表而不用平衡树？"></p></blockquote> <blockquote><p>常用的应用场景：</p> <ul><li>学生成绩排名</li> <li>粉丝列表，根据关注的先后时间排序</li></ul></blockquote> <blockquote><p>常用的指令有：</p> <ul><li><p>添加元素：<code>zadd key 5 redis 10 java</code></p></li> <li><p>查找区间元素：<code>zrange key minscore maxscore</code></p></li> <li><p>查找元素排序（索引）：<code>zrank key redis</code></p></li> <li><p>查找元素分数：<code>zscore key redis</code></p></li></ul></blockquote> <blockquote><p>skiplist（跳表）的实现原理：</p> <p>跳表是一种可以进行二分查找的有序链表，底层实现是在原有的<strong>有序链表</strong>上面增加了<strong>多级索引</strong>，通过索引来实现快速查找，其查找、插入、删除的时间复杂度都为log(n)，因为需要维护索引。跳表的特点是效率高、实现简单。查找过程是<strong>从上层索引往下查找，每次都找到最后一个小于查找值的元素，然后往下级索引查找，直到找到元素</strong>。在Redis中，有序集合中对socre进行排序存储，涉及到对有序列表的查询，故采用跳表。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimages2020-02-28-031228.png" alt="有序集合-跳跃表.png"></p></blockquote> <blockquote><p>Redis为什么用skiplist而不用平衡树？（来自Redis的作者）</p> <ol><li>内存占用上跳表更可控，可以通过设置maxlevel控制索引层数。</li> <li>性能上跳表拥有跟其他平衡树类差不多的性能。</li> <li>实现难度上跳表逻辑及实现更加简单。</li></ol></blockquote> <ul><li>Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。</li></ul> <blockquote><p>Set是一个无序集合，其存储的元素都是唯一的，不会有重复元素。Set底层采用<strong>intset (整数集合)</strong> 或 <strong>字段表 (普通哈希表)</strong> 进行存储，<strong>只有在元素都为整数，并且元素数量小于512的时候使用intset</strong>，其他的采用HashTable（key为值，value为null）。</p></blockquote> <blockquote><p>常见的应用场景有：</p> <ul><li>用户标签：可以基于<code>sunion</code>指令获取用户间的共同爱好</li> <li>抽奖系统：set可以存储不重复的人员，通过<code>spop key nums</code>可以随机抽取并移除三名人员，<code>srandmember key nums</code>则是随机抽取三人，但是不移除。</li></ul></blockquote> <blockquote><p>常用的指令有：</p> <ul><li>交集：<code>sinter</code></li> <li>并集：<code>sunion</code></li> <li>错集：<code>sdiff</code></li></ul></blockquote> <blockquote><p><a href="https://blog.csdn.net/ldw201510803006/article/details/123515390" target="_blank" rel="noopener noreferrer">insert和hashtable的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：inset底层采用有序整数存储，时间复杂度上查找元素为logn（二分查找），增加和删除为On（需要移动元素），而hashtable都是O1，时间上hashtable快于inset，而空间上inset优于hashtable（key-value存储，value为null），所以inset是一种时间换空间的结构。</p></blockquote> <h4 id="redis的原理"><a href="#redis的原理" class="header-anchor">#</a> Redis的原理</h4> <ol><li>Redis中的key有时间限制，你觉得是怎么实现的？</li></ol> <blockquote><p>Redis中的定时策略可以根据用户定制的时间保证键值对过期失效，底层采用字典表实现，Redis维护了一个<strong>过期字典表</strong>，key为用户的key，value即为过期时间。当用户请求键值的时候，流程如下：</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images3bf71ae0-5de7-11ea-9e57-957b6467a3fc.png" alt="内存过期策略-过期键判断流程.png"></p></blockquote> <blockquote><p>Redis的过期策略：</p> <p>由于Redis是单线程的框架，如果直接对所有过期键值进行清除，会导致服务一段时间无法提供服务，为了避免这种情况发生，redis提供了多种过期策略，主要以下三种，Redis默认采用第二+第三种。</p> <ul><li><p>定时全量删除：定时扫描并删除所有过期键值，可以快速释放内存，但是数量量大时会导致服务卡顿。</p></li> <li><p>惰性删除：用户访问键值时再检查是否过期，过期则删除。</p></li> <li><p>定时随机删除：定时随机检查部分键值是否过期，过期则删除，Redis中默认每10秒扫描一次，并且扫描策略如下，为了防止死循环，规定了扫描时间不超过25ms。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesc511d450-5de7-11ea-a9fa-c1c510366b3a.png" alt="内存过期策略-执行流程2.png"></p></li></ul></blockquote> <ol start="2"><li>Redis的持久化原理</li></ol> <blockquote><p>由于Redis在内存中做数据操作，为了保证服务器重启时数据不丢失，Redis提供了两种持久化机制（Redis的持久化过程都是通过fork新的线程异步执行），分别为AOF（appendonly.aof）和RDB（dump.rdb），两者的区别如下：</p> <ul><li>文件格式不同：AOF存储的是键值操作的命令，以文件追加的方式添加到AOF文件中，所以文件会比较大。而RDB存储的是某时刻的内存快照，将当前数据以二进制文件存储并写入磁盘，相对文件比较小。
<ul><li>AOF文件恢复速度比较慢，但是可读性好，容易修复，而且增量的方式更加轻量。</li> <li>RDB文件则恢复速度快，但是每次都需要持久化整块内存快照，所以在数据量较大而且CPU性能不佳时会导致服务停顿。</li></ul></li> <li>持久化时间不同：AOF默认每秒将命令追加到AOF文件中，即使服务重启也只会丢失一秒内的操作，而RDB由于是对内存快照的复制，不能像AOF那样进行增量增加，所以通常是隔一段时间进行持久化存储，这就导致RDB模式下容易丢失某段时间内的数据。</li> <li>恢复程度不同：如果不小心调用了flushall命令，由于AOF是文件追加方式，可以通过删除flushall命令还原，而RDB是基于内存快照，会导致所有数据被清空。</li></ul> <p>AOF和RDB除了自动触发外，也可以通过手动触发：</p> <ul><li>save：同步持久化，阻塞主线程</li> <li>bgsave：异步持久化，通过fork命令创建子线程，而fork也会消耗一定的内存</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122534.png" alt="image.png"></p></blockquote> <blockquote><p>AOF重写机制</p> <p>由于AOF以文件追加方式添加到AOF文档，为了解决文档过大的问题，Redis提供了文件重写功能，当达到一定的文件大小（默认为60M），则重写当前文件，并把当前数据的最少操作命令保存到新文件上，从而减少文件大小。</p></blockquote> <blockquote><p>AOF和RDB混合持久化</p> <p>由于AOF和RDB各有弊端，AOF文件过大时会影响启动速度，RDB会有一段时间的数据丢失，为了同时能用到AOF和RDB的优点，Redis4.0后新增了混合持久化的方式，在混合持久化的模式下，AOF在重写时会把Redis的持久化数据，以RDB的格式进行存储，并且将接下来的持久化以AOF格式追加到文件末尾。开头为RDB文件，使得Redis能够快速启动，同时又结合了AOF的优点，避免了大量数据丢失的风险。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122549.png" alt="image.png"></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2020-02-24-122601.png" alt="image.png"></p></blockquote> <ol start="3"><li><p>Redis的存储原理</p> <ol><li>新增节点哈希槽会如何变化？</li></ol> <blockquote><p>新增节点后需要重新分配槽点，这个需要进行手动分配，我们可以通过reshard命令指定分配多少个槽点到某个节点，redis会从其他节点中分配对应的槽点到新节点。删除节点也一样，删除前需要将槽点reshard到其他节点上再进行删除。</p> <p>添加新节点：</p> <ul><li>添加主节点，添加从节点</li> <li>从其他节点分配槽点到新增节点（source 其他节点-all，to 新节点的ID，cluster node命令获取ID）</li></ul> <p>删除节点：</p> <ul><li>删除从节点</li> <li>将槽点迁移到其他节点（source 要删除的节点，to 另外节点或者all）</li> <li>删除主节点</li></ul></blockquote> <ol start="2"><li>哈希槽是如何存储的？</li></ol> <blockquote><p>个人认为哈希槽是以字典方式存储的，key为master节点id，value为对应槽点的set集合，当客户端请求某个节点上的数据，该节点会计算槽点并查看是否为自己管理的，不是则查找自己的元数据中目标槽对应的节点Id，包装在MOVE命令中并返回，客户端重新发送。</p></blockquote></li></ol> <h4 id="redis的集群模式"><a href="#redis的集群模式" class="header-anchor">#</a> Redis的集群模式</h4> <ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/40%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>主从模式</strong></p> <blockquote><p><strong>主从模式</strong></p> <p>主从模式是一种“读写分离”思想的实现。Redis单机大概能支撑几万的qps，而主从模式可以大大提高其读并发性能，主从模式通常是一主多从，主节点负责写操作和将数据复制到其他从节点，从节点负责读操作，本质上就是读写分离。主从模式下的Redis有以下特点：</p> <ul><li>高并发（读写分离）</li> <li>高可用（主从切换）</li> <li>高可靠（从备份数据）</li></ul> <p><img src="https://pika-oss1.oss-cn-beijing.aliyuncs.com/blog/imagesredis-master-slave.png" alt="Redis-master-slave"></p></blockquote> <blockquote><p><strong>数据同步</strong></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication.png" alt="Redis-master-slave-replication"></p> <ul><li><p><strong>全量复制</strong>：当有新的从服务器连接时，为了保障多个数据库的一致性，主服务器会执行一次 <code>bgsave</code> 命令生成一个 RDB 文件，然后再以 Socket 的方式发送给从服务器，从服务器收到 RDB 文件之后再把所有的数据加载到自己的程序中，就完成了一次全量的数据同步。</p></li> <li><p><strong>增量复制</strong>：</p> <ul><li><p>2.8之前：从服务器掉线重连后，主服务器都会进行一次完整的数据同步，如果掉线时间比较短，那么这种方式是非常不划算的。</p></li> <li><p>2.8之后：当从服务器掉线后，主服务器会把离线后的写入命令，存储在一个特定大小的队列中，队列可以保证先进先出的顺序，当从服务器重写恢复上线之后，主服务会判断离线这段时间内的命令是否还在队列中，如果在就直接把队列中的数据发送给从服务器，这样就避免了完整同步的资源浪费。</p> <blockquote><p>存储离线命令的队列大小默认是 1MB，可以修改队列大小的配置项 repl-backlog-size。</p></blockquote></li></ul></li> <li><p><strong>无盘同步</strong>：当新的从节点加入时，主服务器会通过bgsave在本地生成RDB文件发送给从服务器，从服务器会先将RDB文件持久化到磁盘再读取，由于磁盘操作非常慢，为了解决这一问题，在2.8.18后增加了无盘复制功能，其特点是RDB文件不需要存入磁盘，而是由子线程生成数据内容通过socket直接发送到从服务器，这样主服务器可以避免磁盘写入与读取的过程，提高同步性能。</p> <blockquote><p>无盘复制默认是开闭的，需要通过配置<code>repl-diskless-sync</code>为yes开启</p></blockquote></li></ul> <p><strong>完整流程</strong></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-master-slave-replication-detail.png" alt="Redis-master-slave-replication-detail"></p></blockquote> <blockquote><p><strong>常用命令</strong></p> <ul><li><p><code>replicaof host port</code>：配置从节点</p></li> <li><p><code>replicaof no one</code>：关闭从节点</p></li> <li><p><code>role</code>：查看当前节点角色</p></li></ul></blockquote> <p><strong>哨兵模式</strong></p> <blockquote><p>哨兵模式是一种自动容灾技术，可以避免手动切换服务器带来的弊端。Redis的实现方式是搭建一个sentinel集群，通过每秒一次ping命令的频率监听当前的主从模式的节点（默认超过30秒则认为下线），假如当前的sentinel节点有五个，quorum配置为3，那么当超过3个sential节点监测到主节点下线（主观认为），则客观认为主节点掉线，此时会启动故障转移。</p> <p><img src="https://pika-oss1.oss-cn-beijing.aliyuncs.com/blog/91c09780-8574-11ea-a330-69dc969564d3-20220813125936520.png" alt="哨兵模式-多哨兵.png"></p></blockquote> <blockquote><p><strong>Sentinel集群搭建</strong></p> <ol><li><p>配置<code>sentinel.conf</code>文件，如监听的master ip、端口和密码</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>sentinel monitor mymaster 127.0.0.1 6379 1
sentinel auth-pass mymaster pwd654321
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>启动sentinel</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 通过以下命令可以启动sentinel，当多个sentinel监听同个master时会相互识别，形成sentinel
./src/redis-sentinel sentinel.conf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol></blockquote> <blockquote><p><strong>主从节点竞选</strong></p> <p>故障转移即剔除掉线的主节点，从从节点中竞选主节点，竞选过程主要参照以下两个指标：</p> <ul><li>优先级：即节点的权重，可以通过<code>replica-priority</code>配置，值越小则优先级越高。</li> <li>偏移量：即从节点数据同步情况，偏移量越大则说明数据同步度更高，优先级也越高。</li></ul> <p>故障转移过程重点有以下步骤：</p> <ul><li>从节点排除
<ul><li>排除掉线的从节点</li> <li>排除长时间没有跟主几点通信的从节点</li> <li>排除优先级为0的从节点</li></ul></li> <li>主节点竞选
<ul><li>优先级高的从节点优先</li> <li>优先级一样，则偏移量高的从节点优先</li> <li>优先级和偏移量一样，则选择 Redis 运行时随机生成 ID 最小那个为新的主服务器</li></ul></li> <li>旧的主节点恢复：会作为新的从节点存在，并且清空数据，同步新的主节点的数据</li></ul></blockquote> <blockquote><p><strong>主备切换导致数据丢失</strong></p> <ul><li>异步复制导致数据丢失（宕机）</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/async-replication-data-lose-case.png" alt="async-replication-data-lose-case"></p> <ul><li>脑裂导致的数据丢失（网络问题）</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/redis-cluster-split-brain.png" alt="Redis-cluster-split-brain"></p> <p><strong>数据丢失的解决方案</strong></p> <p>下面配置表示：至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。这个配置可以保证主节点超过十秒的数据至少被从节点同步过了，否则主节点拒绝接收写入命令。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 超过十秒的主数据
min-slaves-max-lag 10
// 至少被同步到一台从服务器上
min-slaves-to-write 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个配置可以将上述的两个问题导致的数据丢失都控制在10秒内，也就是保证丢失的数据是可控的。</p></blockquote> <blockquote><p><strong>哨兵集群的自动发现机制</strong></p> <ul><li><a href="https://juejin.cn/post/7112434646851584013" target="_blank" rel="noopener noreferrer">redis发布订阅<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code>（发布订阅，在redis种<code>pubsub_channels</code>是字典数据结构，key为channel即频道，value为list即订阅的客户端） 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220816142203876.png" alt="image-20220816142203876"></p></blockquote> <blockquote><p><strong>配置传播</strong></p> <p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后通过发布订阅模式同步给其他的哨兵。其他的哨兵会根据配置信息的版本号，更新最新版本的master配置信息。</p></blockquote> <blockquote><p><strong>常用命令</strong></p> <ul><li>添加新的sentinel节点到集群：<code>sentinel monitor master-name ip port quorum</code></li> <li>移除sentinel节点：<code>sentinel remove mymaster</code></li> <li>修改quorum；<code>sentinel set master-name quorum n</code></li> <li>查看某主节点的信息：<code>sentinel master master-name</code>：</li> <li>通过主节点名查看其ip和端口号：<code>sentinel get-master-addr-by-name master-name</code></li> <li>查看某从节点的信息：
<ul><li><code>sentinel slaves slave-name</code></li> <li><code>sentinel replicas slave-name</code></li></ul></li> <li>强制故障转移：<code>sentinel failover master-name</code></li></ul></blockquote> <p><strong>集群模式</strong></p> <blockquote><p>Redis Cluster是3.0后推出的去中心化的集群方案。其通过将数据分为16384个槽分布到不同的服务器上，来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。其特点是</p> <ul><li><p><strong>高读写性能</strong>：主节点存在多个，可以多路写入，从节点提供读服务，读写分离。</p></li> <li><p><strong>高可用</strong>：部分master不可用时，还是可以继续工作</p></li></ul> <p><img src="https://pika-oss1.oss-cn-beijing.aliyuncs.com/blog/b74ff8b0-8579-11ea-ab1b-af991e0896fe-20220813145034902.png" alt="image.png"></p></blockquote> <blockquote><p><strong>分布式寻址算法</strong></p> <p><strong>Hash算法</strong></p> <blockquote><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimageshash.png" alt=""></p></blockquote> <p><strong>一致性 hash 算法</strong></p> <blockquote><ol><li>将整个hash值空间虚拟成一个环，将master节点进行hash计算其在环上的位置</li> <li>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置</li> <li>如果一个节点挂了，那么只会影响这个节点上的部分数据。</li></ol> <p>一致性hash算法在节点比较少的时候，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesconsistent-hashing-algorithm.png" alt="consistent-hashing-algorithm"></p></blockquote> <p><strong>hash slot算法（槽位定位）</strong></p> <blockquote><p>Redis 集群总共的槽位数是 16384 个，每一个主节点负责维护一部分槽以及槽所映射的键值数据，Redis 集群默认会<strong>对要存储的 key 值使用 CRC16 算法进行 hash 得到一个整数值</strong>，然后用这个整数值对 16384 进行取模来得到具体槽位，公式为：</p> <p><code>slot = CRC16(key) % 16383</code></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imageshash-slot.png" alt="hash-slot"></p></blockquote></blockquote> <blockquote><p><strong>节点内部通信机制</strong></p> <p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。<strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。如Kafka中的zookeeper。</p> <p><strong>集中式</strong>：</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imageszookeeper-centralized-storage.png" alt="zookeeper-centralized-storage"></p> <p><strong>gossip 协议</strong>：</p> <p>节点间通过开启10000+当前端口号的端口，用于内部的节点间通信，通过PING、PONG命令监测节点存活以及集群元数据交换，通过MEET命令添加新节点进入集群，当某个节点发现故障节点后，向其他节点发送FAIL命令通知其他节点进行检测和故障确定。</p> <ul><li>ping命令深入解析：
<ul><li>每个节点会周期性的选择5个最久没有通信的其它节点。如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping。</li> <li>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</li></ul></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesredis-gossip.png" alt="Redis-gossip"></p></blockquote> <blockquote><p><strong>负载均衡</strong></p> <p>在 Redis 集群负载不均衡的情况下，我们可以使用 rebalance 命令重新分配各个节点负责的槽数量，从而使得各个节点的负载压力趋于平衡，从而提高 Redis 集群的整体运行效率。</p> <p><code>redis-cli --cluster rebalance 127.0.0.1:30007</code></p></blockquote> <blockquote><p><strong>故障发现</strong>：疑似下线 + 确定下线</p> <ul><li><p>正常情况下集群中节点会定期向其他节点发送PING确认其是否在线，如果规定时间内没有收到PONG，该节点会将其标记为疑似下线并向集群广播</p></li> <li><p>其他节点收到广播后会向该节点发送PING，如果超过半数标记为疑似下线，则标记为确认下线并向集群广播</p></li> <li><p>其他节点收到下线广播后，会立即对该节点进行主从切换（故障转移）</p></li></ul> <p><strong>故障转移</strong></p> <ul><li>选择节点：从下线的主节点中选择一个从节点（根据新主节点选举原则）</li> <li>切换模式：从节点执行<code>SLAVEOF NO ONE</code>命令，切换为主节点模式，保留原来同步的数据</li> <li>重派槽点：新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li> <li>通知集群：新的主节点向集群广播一条 PONG 消息，通知其他节点自己已经切换为主节点并且接管了槽位</li> <li>正常处理：新的主节点开始处理相关的命令请求，此故障转移过程完成。</li></ul></blockquote> <blockquote><p><strong>新主节点选举</strong></p> <ul><li>每个主节点都有一票</li> <li>当从节点发现自己正在复制的主节点确认下线之后，就会向集群广播一条消息，要求所有有投票权的主节点给自己投票</li> <li>每个主节点会向第一个要求投票的从节点投票</li> <li>从节点获票数超过主节点数的1/2，则选举成功，从节点晋升为主节点</li></ul></blockquote> <p><strong>Redis的管道作用</strong></p> <ul><li>参考：<a href="https://juejin.cn/post/7089081484958679077#heading-5" target="_blank" rel="noopener noreferrer">链接*<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>管道技术本质上就是一种批处理技术。由于客户端与服务端通过socket进行连接，当短时间内大量命令产生的时候，如果采用普通的传输方式进行请求，命令间需要同步调用、请求的往返需要时间，并且客户端和服务端需要多次进行IO的的用户态到内核台的切换，会造成大量的网络资源浪费，而管道技术就是将所有命令都整合起来一次性发给服务端，再一次性响应给客户端，从而大大提升redis的响应速度。管道虽然提升了响应速度，但是仍然需要注意管道传输的数据大小，redis的输入缓冲区默认的最大是1G，超过会被断开连接。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220809001446974.png" alt="image-20220809001446974"></p></blockquote> <blockquote><p><strong>pipeline和原生批量命令（mget、mset）的区别</strong></p> <ul><li>原生命令具有原子性（跟setnx原子性命令类似），pipeline不具备原子性（中间命令出错仍然会继续执行）。</li> <li>原生命令是一个命令对应多个键值对，而pipeline是多条命令。</li> <li>原生命令是服务端实现，而pipeline是服务端和客户端共同完成。（pipeline需要在客户端缓冲区中组装多条指令）</li></ul></blockquote> <blockquote><p><strong>pipeline和事务的区别</strong></p> <ul><li><p><a href="https://juejin.cn/post/7125820336104275982" target="_blank" rel="noopener noreferrer">*Redis的事物<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>事物关注的是ACID，而pipeline关注的是RTT的减少</p></li> <li><p>Redis的事物通过Multi、Exec命令控制，先Multi开启事物，此过程的命令会被存储在队列中，然后在通过exec提交事物</p> <ul><li>原子性：不保证，执行过程有命令出错，仍然会继续执行，但是如果是在执行前检测到命令有误，则会回滚事物</li> <li>隔离性：保证，Redis的事物有CAS（check and set）机制，通过watch机制监控相关key数据是否被修改，修改则关闭事物</li> <li>持久性：不保证，没来得及被持久化的数据，仍然会丢失</li></ul></li></ul></blockquote> <blockquote><p><strong>pipeline的优缺点</strong></p> <ul><li>优点：批量操作，减少传输IO及系统切换开销</li> <li>缺点：
<ul><li>不能保证原子性，部分指令可能执行失败，并且其他指令会继续执行。</li> <li>只能作用在一个节点上，暂时不支持集群。</li></ul></li></ul> <p><strong>适用场景</strong></p> <ul><li>pipeline适用于指令间没有依赖关系的情况，并且对可靠性要求不高的场景。因为其不能保证所有命令都正常执行。</li> <li>例如用户群发短信，这时候就可以用pipeline，因为群发消息实时性要求不高，并且即使部分失败，后续有补偿机制即可。</li></ul></blockquote> <blockquote><p><strong>pipeline用法</strong></p> <ol><li>redistemplate</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span> <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">executePipelined</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RedisCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Nullable</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">doInRedis</span><span class="token punctuation">(</span><span class="token class-name">RedisConnection</span> connection<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">DataAccessException</span> <span class="token punctuation">{</span>
    connection<span class="token punctuation">.</span><span class="token function">openPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
      connection<span class="token punctuation">.</span><span class="token function">zCount</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ol start="2"><li>Jedis</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取 Pipeline 对象</span>
<span class="token class-name">Pipeline</span> pipe <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置多个 Redis 命令</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pipe<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token string">&quot;val&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 执行命令并返回结果</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> pipe<span class="token punctuation">.</span><span class="token function">syncAndReturnAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> obj <span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 打印结果</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></blockquote> <blockquote><p><strong>keys命令和scan命令的区别</strong></p> <p>keys命令时间复杂度是O(n)，大数据量下会导致服务卡顿，而scan命令是分批次扫描的，不会阻塞线程，并且可以通过limit控制返回的数据量，缺点是可能会有数据一致性问题，因为是分批次读取。</p></blockquote> <h4 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="header-anchor">#</a> 如何保证缓存与数据库的双写一致性？</h4> <ul><li><a href="https://juejin.cn/post/6844903941646319623" target="_blank" rel="noopener noreferrer">*一致性问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>数据更新的时候涉及到redis和数据库的更新，那么根据更新的先后顺序，分为以下几种：</p> <ol><li>先更新缓存后更新数据库：不可取，存在数据丢失问题</li> <li>先更新数据库后更新缓存：不可取，存在顺序问题，例如A，B顺序更新数据库，但是缓存更新可能是B，A，导致旧数据被保存</li> <li>先删除缓存，再更新数据库：不可取，存在顺序问题，例如删除缓存后，还没更新数据，这时候有请求获取数据并且写入缓存，导致旧数据被存在缓存中</li> <li>先更新数据库，再删除缓存：可取，数据存在短暂的不一致问题，但是大数据量下存在缓存击穿问题，可以采用加锁的方式，保证在没缓存的情况下只有少量请求进入数据库查找并缓存到redis中</li></ol></blockquote> <h4 id="redis-的并发竞争问题是什么"><a href="#redis-的并发竞争问题是什么" class="header-anchor">#</a> Redis 的并发竞争问题是什么</h4> <blockquote><ol><li>顺序问题：本来的请求是A-B，但是更新redis的时候是B-A，解决：
<ol><li>可以通过添加当前请求的版本号或者时间戳，如果写入的时候发现版本号低则丢弃。</li> <li>添加消息队列，保证串行化处理</li></ol></li> <li>并发写入问题：先读后修改，再写入，这样存在数据覆盖问题，解决：
<ol><li>添加分布式锁（redis、zookeeper），保证不发生并发修改问题</li> <li>避免先读后写，例如如果是数据算术操作，可以直接使用Redis的原子性命令自增。</li></ol></li></ol> <p>两个是处理不一样的问题，只实现其中一个另外一个都会都问题，比如A-B请求取更新缓存，然后顺序颠倒了，这样即使加锁了也会导致旧数据的覆盖。</p></blockquote> <h3 id="netty"><a href="#netty" class="header-anchor">#</a> Netty</h3> <ul><li><a href="https://www.zhihu.com/question/24322387" target="_blank" rel="noopener noreferrer">通俗的理解Netty<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://juejin.cn/post/6844903703183360008" target="_blank" rel="noopener noreferrer">Netty知识<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>面试题：
<ul><li><a href="https://www.nowcoder.com/discuss/832208?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1656053990442" target="_blank" rel="noopener noreferrer">资料一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6999225355374428168" target="_blank" rel="noopener noreferrer">资料二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/148726453" target="_blank" rel="noopener noreferrer">阿里大牛<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <h4 id="什么是netty"><a href="#什么是netty" class="header-anchor">#</a> 什么是Netty</h4> <blockquote><p>Netty是 一个异步事件驱动的网络应用程序框架，用于开发的高性能协议服务器和客户端。Netty本质是上对Java NIO的封装，采用Reactor线程模型（Selector（多路复用）器、Acceptor、Handler）、零拷贝技术，极大的提升了socket通信性能。</p></blockquote> <h4 id="netty的特点"><a href="#netty的特点" class="header-anchor">#</a> Netty的特点</h4> <blockquote><p>高并发、传输快和封装好</p></blockquote> <ul><li><strong>高并发</strong>：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的<strong>网络通信框架</strong>，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</li> <li><strong>传输快</strong>：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li> <li><strong>封装好</strong>：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li></ul> <h4 id="netty的应用场景-你们项目用在什么地方"><a href="#netty的应用场景-你们项目用在什么地方" class="header-anchor">#</a> Netty的应用场景？你们项目用在什么地方</h4> <blockquote><p>Netty主要作为基础通信框架提供高性能、低延时的通信服务。可用于构建高性能、低延时的各种Java中间件，例如阿里分布式服务框架 Dubbo、 RocketMQ 默认使用 Netty 作为通讯框架。</p></blockquote> <ul><li>作为基础设备通信框架，例如采用NIO做情报板、水电表数据及基础设备信息的采集。
<ul><li>情报板通信：停车位自动发布，其发布过程分为四个阶段，1.删除旧文件 2.创建文件 3.下发文件 4. 播放文</li> <li>设备状态采集：通过SNMP协议，NIO获取并异步更新设备状态</li></ul></li></ul> <h4 id="netty的整个处理流程"><a href="#netty的整个处理流程" class="header-anchor">#</a> Netty的整个处理流程</h4> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCiqc1F-NO9KAUOtaAAE1S5uRlDE275.png" alt="Drawing 1.png"></p> <ul><li>服务端</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf93e830044e7%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf9418d4c86e4%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <ul><li>客户端</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/166cf957e59b5066%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <h4 id="nio、bio、aio的区别"><a href="#nio、bio、aio的区别" class="header-anchor">#</a> NIO、BIO、AIO的区别</h4> <ul><li><p><a href="https://juejin.cn/post/6844903687626686472" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>衍生：Linux的五种IO模型的区别（磁盘IO）</p></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220705103107463.png" alt="image-20220705103107463"></p> <ul><li><p>Java中三种IO模型的区别（BIO、NIO、AIO）</p> <blockquote><p>Java中的三种IO模型都是依赖操作系统IO进行的封装，</p></blockquote> <ul><li><p>BIO：<strong>同步阻塞型IO</strong>（1请求1线程连接），连接建立后用户线程发起IO请求，系统切换到内核态读取磁盘数据到内核缓冲区，此过程中用户线程阻塞等待直到内核缓冲区数据读取完成，再将其复制到用户态缓冲区（再到socket缓冲区）</p></li> <li><p>NIO：<strong>同步非阻塞型IO</strong>（多请求1线程连接），连接建立后，用户线程发起IO请求并注册到selector（多路复用器）中，注册完用户线程返回，由Selector（ Selector 其实就是 select/poll/epoll 的外包类）中的线程去检查多路连接的IO是否准备就绪，完毕则调用用户线程将内核缓冲区的数据复制到用户缓冲区。与上面的Linux模型中的普通NIO（不断轮询查看）不同，Java中的NIO是【多路复用IO+信号量IO】，大大减少用户线程的消耗，但是数据从内核到用户的复制仍然由用户线程执行，所以本质上仍然是同步的。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20200610173230680.png" alt="image-20200610173230680"></p></li> <li><p>AIO：<strong>非同步非阻塞型IO</strong>。与同步型IO不同，内核态到用户态的数据复制在AIO中直接由内核线程负责处理，所以对于用户线程来说，是异步执行的。</p></li></ul></li></ul> <h4 id="netty的线程模型了解吗"><a href="#netty的线程模型了解吗" class="header-anchor">#</a> Netty的线程模型了解吗？</h4> <ul><li><a href="https://juejin.cn/post/6844903974298976270" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>答：Reactor核心组成部分包括Selector、Acceptor和Handler，其中</p> <ul><li><p>selector 监控连接事件（read/write事件、连接事件）,收到事件后通过<strong>dispatch</strong>进行分发</p> <ul><li>连接事件：分发到acceptor通过accept接收连接，并创建Handler。</li> <li>读写事件：分发到Handler进行处理，<strong>Handler完成read-&gt;(decode-&gt;compute-&gt;encode)-&gt;send的业务流程</strong></li></ul> <p>而根据Reactor的数量和工作线程池的数量，又将Reactor分为三种模型。</p></li></ul></blockquote> <ul><li>单Reactor单线程模型 （单Reactor单线程）：单线程处理连接事件、读写事件、监听事件等，如果处理Handler出现死循环，将导致整个服务不可用。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16de9918fe8487b3%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="Reactor_1"></p> <ul><li>单Reactor多线程模型 （单Reactor多线程【处理Handler的线程池】）：业务处理由线程池异步执行，但是在大量高并发的场景下，单Reactor仍然会有性能问题。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16de9918fc15ffea%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="Reactor_2"></p> <ul><li>主从Reactor多线程模型 （多Reactor多线程) ：主从职责分离，主负责连接建立及验证，从负责事件监听、分发，是目前比较流行的线程模型。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16de9918fa25729e%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="Reactor_3"></p> <blockquote><p>主Reactor：通过selector监听连接事件，并调用acceptor创建连接并发送给从Reactor
从Reactor：接收到主Reactor的连接后加入队列，通过自己的Selector监听IO管道，并将读写事件分发给Handler的TheadPool，由该线程池做Handler的处理</p></blockquote> <p>三种模型详细介绍（挑重点记忆，我面试没遇到过让详细说的。）</p> <ul><li><strong>单线程模型</strong>：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都 是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连 接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的 链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li> <li><strong>多线程模型</strong>：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和 发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线 程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li> <li><strong>主从多线程模型</strong>：Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上， 用于处理I/O 的读写等操作，从而保证mainReactor只负 责接入认证、握手等操作；</li></ul> <h4 id="eventloop是什么-和reactor线程模型的关系"><a href="#eventloop是什么-和reactor线程模型的关系" class="header-anchor">#</a> EventLoop是什么？和Reactor线程模型的关系</h4> <blockquote><p>答：EventLoop直译即事件轮询，是一种用于事件等待和处理的程序模型。在Netty中，EventLoop可以认为是Reactor 线程模型的事件处理引擎，每个EventLoop都维护一个Selector和TaskQueue，主要负责处理IO事件、普通任务和定时任务。Reactor推荐使用NioEventLoop，其底层基于JDK的Epoll实现，并且避免了JDK Epoll的漏洞。在我的理解上，Reactor、EventLoopGroup、EventLoop、Channel之间的关系如下：</p> <p>Reactor可以简单的认为是EventLoopGroup，例如主从Reactor即有两个EventLoopGroup。</p> <p><strong>EventLoopGroup和EventLoop是一对多</strong>的关系，可以简单理解为线程池和线程的关系，只不过EventLoop有具体的实现，包括轮询（Selector）自己管理的任务队列（TaskQueue），对于从Reactor，其EventLoop的任务队列即Channel队列，轮询监听Channel的IO事件，并调用ChannelPipeline中的Handler进行处理，所以<strong>EventLoop和Channel是一对多的关系</strong>。</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220727105052377.png" alt="image-20220727105052377"></p> <h4 id="tcp-粘包-拆包的原因及解决方法"><a href="#tcp-粘包-拆包的原因及解决方法" class="header-anchor">#</a> TCP 粘包/拆包的原因及解决方法？</h4> <blockquote><p>答：TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p></blockquote> <p>原因：</p> <ul><li>当我们的数据包大于TCP包数据内容空间，则发生拆包，小于则发生粘包。例如：服务端将三个数据包被组装成两个TCP包发送，则服务端发生了粘包，客户端接收到粘包则需要进行拆包处理。</li></ul> <p>解决：</p> <ul><li>FixedLengthFrameDecoder：定长拆包器：应用层协议包简单，数据包长度固定，则可以使用。</li> <li>LineBasedFrameDecoder：行拆包器：数据包以换行符作为分隔。</li> <li>DelimiterBasedFrameDecoder：自定义分隔符分割器：是行拆分器的通用版本，可以自定义换行符。</li> <li>LengthFieldBasedFrameDecoder：基于长度域拆包器：自定义的协议中包含长度域字段，则可以用该拆包器。</li></ul> <h4 id="什么是零拷贝-跟传统拷贝的区别"><a href="#什么是零拷贝-跟传统拷贝的区别" class="header-anchor">#</a> 什么是零拷贝，跟传统拷贝的区别？</h4> <ul><li>*<a href="https://blog.csdn.net/liyifan687/article/details/106749460" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/16%20%20IO%20%E5%8A%A0%E9%80%9F%EF%BC%9A%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%20Netty%20%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.md" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://www.pdai.tech/md/java/io/java-io-nio-zerocopy.html#%E5%85%B6%E5%AE%83%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener noreferrer">参考三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6939881308114354207" target="_blank" rel="noopener noreferrer">参考四<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>什么是零拷贝</strong></p> <blockquote><p>零拷贝是个广义上的概念，可以认为只要能够减少不必要的 CPU 拷贝，都可以理解为是零拷贝。常见的零拷贝优化有以下：</p> <ul><li>操作系统级别的零拷贝</li> <li>用户态的数据操作优化</li></ul> <p>DMA： 全称叫直接内存存取（Direct Memory Access），是一种允许外围设备直接访问系统主存的机制。DMA 接管了数据读写的工作，不需要 CPU 再参与 I/O 中断的处理，从而减轻了 CPU 的负担。</p></blockquote> <p><strong>一次传统磁盘IO的过程</strong></p> <blockquote><p>磁盘 - 内核 - 用户空间（一次读写时共涉及了4次上下文切换，2次 DMA 拷贝以及2次 CPU 拷贝。）</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/screen-1535441.png" alt="screen-1535441"></p> <ul><li>一次网络IO的过程：web服务区 - 内核 - 用户空间 - 网卡（如果web服务器涉及磁盘IO，则还需要添加磁盘IO过程）<img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220705102442286.png" alt="image-20220705102442286"></li></ul> <p><strong>零拷贝实现</strong></p> <ul><li><strong>用户态直接IO</strong>：用户空间直接访问硬件设备，通过DMA进行数据传输</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/screen-1535947.png" alt="screen-1535947"></p> <ul><li><strong>mmap</strong>：MMAP 是数据不会到达用户空间内存，只会存在于系统空间的内存上，用户空间与系统空间共用同一个缓冲区，两者通过映射关联。（发生了 4 次上下文切换 + 1 次 CPU 拷贝 + 2 次 DMA 拷贝）</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/aHR0cDovL2ltZy5sbGM2ODcudG9wL3VQaWMvc2NyZWVuLTE3NzMyODcucG5n" alt="screen-1773287"></p> <ul><li><p><strong>sendfile</strong>： Linux 2.4 版本开始，减少了内核缓冲区到Socket缓冲区的一次CPU拷贝，采用传输数据描述信息，由网卡DMA直接进行内核缓冲区的数据拷贝。与 mmap 内存映射方式不同的是， sendfile() 调用中数据对用户空间是完全不可见的，可以认为是对nmap的优化。（sendfile再JDK的封装中即<code>FileChannel#transferTo</code>方法）</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20200610154454498.png" alt="image-20200610154454498"></p></li></ul> <p><strong>Netty的零拷贝优化</strong></p> <blockquote><p>Netty的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化。</p></blockquote> <ul><li><strong>堆外内存</strong>：Netty发送和接收消息主要使用bytebuffer，bytebuffer使用堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li> <li><strong>Composite Buffers</strong>：传统的bytebuffer，如果要合并两个bytebuffer，需要创建一个2*n大小的新数组，再将两个拷贝到新数组中，而Composite Buffers没有真正将多个bytebuffer组合起来，而是保存了他们的引用。</li> <li><strong>FileChannel.transferTo</strong>：Netty底层调用了FileChannel的transferTo方法，该方法即上述的sendfile方式的零拷贝，是操作系统级别的零拷贝技术。</li></ul> <hr> <h3 id="kafka"><a href="#kafka" class="header-anchor">#</a> Kafka</h3> <p>Kafka用在什么场景？</p> <ul><li><p>Kafka用于接收情报板、事件检测及其他设备采集的消息，用于与系统服务的解耦，可用做流量控制</p></li> <li><p>情报板发送需要保证<strong>有序性</strong>，防止情报板覆盖，采用情报板code作为partitionKey，防止乱序导致的覆盖问题。</p></li> <li><p>卡口数据接收需要<strong>防止消息丢失</strong>，采用手动ack机制，保证业务正常后再提交ack。</p></li> <li><p>Kafka采用最大努力通知配置，BASE理论，柔性事务最终一致性。</p> <ul><li><p>PCM采用最大努力通知（柔性事务）：消息异步发送，如果没有收到ack，则重复发送，本地重复失败后发送到Exception Queue，由Exception Queue再隔一段时间进行发送，并且会邮件通知相关人员排查。</p> <ul><li><a href="https://juejin.cn/post/7023620718692663326" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>服务区采用本地消息表：发布情报板后，异步返回发布成功，由于消息可能会丢失（发送端、传输过程等），故采用本地消息表，事务插入发布记录及发布的消息（消息及其状态），如果消息被正常处理后，则返回执行结果修改本地消息表中的发布状态。由于定时任务会定时检测消息状态，如果发布失败，则重新发送。</p> <ul><li><a href="https://juejin.cn/post/6844904041659498509" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></li> <li><p>Kafka的重复消费问题：幂等性处理</p> <ul><li><a href="https://juejin.cn/post/7002778713943343117" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>*Kafka性能、可靠性问题</p> <ul><li><a href="https://juejin.cn/post/7018702635544870948" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>Kafka扫盲</p> <ul><li><a href="https://juejin.cn/post/7012815379772768264#heading-3" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <p>目前系统可能存在的问题：</p> <ol><li>如果卡口车辆进入后，业务代码异常，导致消息丢失，如何处理？（车辆实际进去了，但是车位占用数据没有录入，并且卡口消息被消费了）
<ol><li>开启手动ack机制，业务完成后再ack，防止消息丢失</li> <li>重复消费问题：redis幂等处理，数据库唯一键处理</li></ol></li> <li>如果前面正常，但是在发布情报板的时候异常，导致消息没发送出去，如何处理？
<ol><li>采用本地消息表，存储消息状态，防止消息丢失</li></ol></li></ol> <p>手动提交ack和本地消息表的区别：</p> <ul><li>手动提交ack主要用于防止业务异常导致消息没有被正常消费的问题，而不能保证消息在传输过程中的其他问题（例如*上游服务宕机导致消息没有被发送、MQ宕机导致消息直接丢失等的问题，MQ可以有副本机制，但是也是最大程度的去避免丢失问题）
<ul><li>服务区应用：卡口车辆通过手动ack，防止业务异常导致消息丢失，进而导致车辆出入卡口数据不能被更新，停车位识别出现问题。</li></ul></li> <li>本地消息表则可以确保<strong>最终一致性原则</strong>（无论如何都会可以保证数据最终一致），因为其原理是在入口处就保存了请求，例如支付后先通过事务【执行支付业务并插入本地消息表】，然后发送支付消息到MQ，通过定时任务监控本地消息表保证后续业务正常执行（后续业务执行成功后会发MQ做确认），发现还没有完成则重新发送MQ，因此存在重复消费问题，需要对接口做幂等处理。
<ul><li>服务区应用：情报板发布后插入情报板相关业务数据，需要发送情报板更新的消息到另一个服务进行对接更新，如果消息在过程丢失，将会出现情报板已经发布但是没有更新的情况，因此引入本地消息表，事务【执行业务数据+插入本地消息表】，通过定时任务查看该条消息对应的需要更新的业务是否已经完成，没有完成则重新发送。</li></ul></li></ul> <h2 id="java"><a href="#java" class="header-anchor">#</a> Java</h2> <h3 id="java基础"><a href="#java基础" class="header-anchor">#</a> Java基础</h3> <ol><li><p>Integer和int的区别：</p> <ol><li>默认值：null，0</li> <li>本质：Integer是封装类，int基础数据结构</li> <li>内存：<code>new Integer</code>创建的实例在堆内存中，栈中存放的是引用，int直接存的是数值</li> <li>功能：Integer封装了对int相关操作的方法，如<code>Integer.valueOf()</code></li></ol></li> <li><p>说一说Java的异常</p></li></ol> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/java-basic-exception-1.png" alt="img"></p> <blockquote><p>Java中的异常都继承自Throwable类，主要有两类，分别为Error和Exception。</p> <p>常见的Error有：</p> <ul><li>OOM Error</li> <li>StackOverFlow Error</li> <li>ClassFormatError：类加载时格式有误</li> <li>UnKnowError：虚拟机未知异常</li></ul> <p>常见的运行时异常：</p> <ul><li>算数异常</li> <li>空指针异常：NullPointerException</li> <li>数组越界异常：IndexOutOfBoundsException</li> <li>类转换异常：ClassCaseException</li></ul></blockquote> <ol start="3"><li>抽象类和接口的区别</li></ol> <blockquote><p>声明：接口用interface声明，抽象类用abstract</p> <p>实现：接口用implement，抽象类用extends</p> <p>继承：接口可以多实现，并且必须实现全部方法；抽象类只能单继承，可以实现部分或不实现，如果子类还有抽象方法则需要定义为抽象类</p> <p>成员变量：接口的属性默认都是<code>public final static</code>的，可以直接通过接口调用到，抽象类可以有普通成员变量</p> <p>方法：接口只能有抽象方法，抽象类可以有普通方法和抽象方法</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220908131405287.png" alt="image-20220908131405287"></p> <h3 id="java并发编程"><a href="#java并发编程" class="header-anchor">#</a> Java并发编程</h3> <h4 id="线程-创建、状态、中断、park-wait-sleep"><a href="#线程-创建、状态、中断、park-wait-sleep" class="header-anchor">#</a> 线程（创建、状态、中断、park/wait/sleep）</h4> <ol><li>Java中线程的状态有哪些？</li></ol> <blockquote><p>Java中线程状态有6种，分为是new、runable、blocked、waiting、time-waiting、terminal。</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220706111105500.png" alt="image-20220706111105500"></p> <ol><li>创建线程的方式有哪些？关闭线程的方法是什么？</li></ol> <blockquote><p>本质上线程的创建方式只有一种，即new Thread，在此基础上，Java又提供了多种创建线程的方式</p> <ul><li>继承Thread</li> <li>实现Runnable接口</li> <li>实现Callable接口</li> <li>线程池创建</li></ul> <p>线程中断：<a href="https://juejin.cn/post/6844903477894709261" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>抢占式中断</strong>：线程提供了stop方式关闭线程，但是该方法被标志为过期方法，不推荐使用，理由是该方法调用后会离地跑出ThreadDeath异常，强制释放该线程持有的资源，如果是在同步代码块中间位置被执行，会导致无法确保数据的安全性（一致性）。</p> <p><strong>协作式中断</strong>：正确的关闭线程是用Thead的interrupt方法，JDK开发人员认为终止一个线程的时机应该由线程本身确定，而不是由其他线程决定，所以interrupt方法只是将线程的中断状态标志设置为true，由线程本身去轮询检测该标识，并在合适的时机结束线程。</p> <p>有了中断标识后，自然也需要有中断策略，而中断策略可以在JVM层面也可以在Java层做实现，例如JVM将Thread的wait()、sleep()、join()等方法都实现中断标识的轮询操作，避免由于阻塞而线程无法被中断。</p></blockquote> <ol start="2"><li>守护线程是什么？</li></ol> <blockquote><p>守护线程即服务于用户线程的线程，<strong>拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点</strong>。通过setDaemon(true)设置。</p> <p>例如在主线程中开启新线程打印，主线程结束后，JVM线程仍然不会结束，而是会等待工作线程（子线程）打印完后结束；对于守护线程的打印，如果主线程退出后，JVM线程会直接结束，而不会等待守护线程输出打印结果，即守护线程的优先级是比较低的，没有工作线程的情况下，不会特地等待其打印。</p> <p>典型的守护线程如Java种的垃圾回收线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动推出。</p></blockquote> <ol start="3"><li>线程、进程和协程的区别
<ol><li>为什么协程的性能好（GO）</li></ol></li></ol> <blockquote><p>两者的本质区别是：是否单独占有内存空间及其他系统资源（如IO）</p> <ol><li>本质：进程是系统分配资源的最小单位，线程是CUP调度和执行的最小单位。</li> <li>切换开销：进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收及页调度，开销较大；线程只需要保持栈信息和寄存器，开销较小。</li> <li>稳定性：进程间单独占有内存，即存在内存隔离，而线程是进程的一部分，同个进程内的线程共享进程的内存，所以进程间的崩溃不会相互影响，但是进程内某个线程的崩溃会影响到其他线程。</li> <li>安全性：由于进程间内存相互隔离，所以进程通信比较困难但是访问安全，而线程由于共享同块内存，通信容易，但是在并发下会存在线程安全问题。</li></ol> <p>协程：</p> <ul><li>属于线程，其没有上下文的切换的消耗，协程的调度切换是由程序员手动切换的。</li> <li>原子性操作，由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li></ul></blockquote> <ol start="4"><li>*线程、进程的中断过程是怎么样的？</li></ol> <ul><li><a href="https://mp.weixin.qq.com/s/pKdQu74Sl3PIaKyDlIEExg" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://juejin.cn/post/7023773498543702029" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://juejin.cn/post/7025201232151052301" target="_blank" rel="noopener noreferrer">参考三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>内中断（异常）：程序执行过程中抛出的异常（处理器及内存以内产生的中断，可以引出线程通过中断关闭）</p> <p>外中断：处理器和内存以外的部件引起的中断【IO设备发出的中断、外部信号中断[ESC键]、各种定时器引起的中断】</p> <p>时间片中断：保存线程上下文，切换至其他线程进行操作</p> <p>进程/线程中断过程（时间片中断）：</p> <ul><li>关中断：避免其他高级中断导致现场保存不完整</li> <li>保存现场和屏蔽字：如程序计数器等</li> <li>开中断</li> <li>执行中断服务程序</li> <li>关中断：执行完中断程序后，关闭中断</li> <li>恢复现场和屏蔽字：将被中断的程序恢复到原来的状态</li> <li>开中断，中断返回：中断服务程序的最后一条指令通常是一条中断返回指令，使被中断程序返回到原程序的断点处，以便继续执行任务。</li></ul></blockquote> <ol start="5"><li>说说Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别区别（引出线程间状态的变换）</li></ol> <ul><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html#threadsleep%E5%92%8Cobjectwait%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>Thread.sleep()和Object.wait()的区别：（锁释放、超时时间）</p> <ul><li>Thread.sleep()释放CPU，不会释放占有的锁，Object.wait()会释放CPU及占有的锁；</li> <li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</li> <li>Thread.sleep()到时间了会自动唤醒，然后继续执行；</li> <li>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</li> <li>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</li></ul> <p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p> <p>LockSupport核心类：<strong>AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作，底层调用的仍然是Unsafe类)</strong></p> <p>Object.wait()和LockSupport.park()的区别：</p> <ul><li><p>作用域：Object.wait()方法需要在synchronized块中执行，LockSupport.park()可以在任意地方执行；</p></li> <li><p>资源释放：Object.wait()释放锁和CPU资源，LockSupport.park()释放CPU不释放锁；</p></li> <li><p>中断处理：Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出，LockSupport.park()不需要捕获中断异常；</p></li> <li><p>唤醒处理：wait-notify/notifyAll（有顺序要求，notify后需要获取锁，并且notify是随机唤醒的），park-unpark（二元信号量，类似于许可证，无顺序要求，由于不释放锁，所以unpark后立刻执行，unpark可以执行唤醒的线程）</p></li></ul> <p>Object.wait()和Condition.await()的区别：</p> <p>两者实现了相同的阻塞功能，不过底层实现不同，Condition.await()底层是先释放锁，然后调用LockSupport.park()来实现阻塞当前线程的。</p></blockquote> <h4 id="多线程-线程安全、线程池、线程通信"><a href="#多线程-线程安全、线程池、线程通信" class="header-anchor">#</a> 多线程（线程安全、线程池、线程通信）</h4> <ol><li>怎样理解线程安全？</li></ol> <blockquote><p>线程安全即当多个线程访问某个对象时，不需要考虑运行环境下的调度、并发，也不需要做额外的同步操作，而调用这个对象的行为都可以得到正确的结果，那么这个对象便是线程安全的。但是在实际的多线程开发中，经常会遇到线程不安全的问题。</p> <p>常见的线程安全场景：</p> <ul><li>并发修改共享变量，先读后修改（例如i++）</li> <li>并发if-then（依赖时序，例如单例）</li> <li>不同数据间存在绑定关系（例如IP和端口，对于这部分的修改和访问需要保证其原子性，不能修改部分就被访问）</li></ul></blockquote> <ol start="2"><li>*线程的同步方式（线程同步即同个时间某份代码只能有一个线程访问）</li></ol> <blockquote><p>线程安全的方案：</p> <p>互斥同步（悲观锁）</p> <ul><li>Synchronized</li> <li>ReentrantLock</li></ul> <p>非阻塞同步（乐观锁，避免阻塞和唤醒，内核-用户态的切换而导致的资源消耗，适合竞争不激烈的场景，需要牺牲部分CPU）：</p> <ul><li>CAS（比较修改前后的预期值是否一致，不一致则说明被修改，会有ABA问题，所以加入版本-AtomicStampedReference）</li> <li>AtomicInteger、AtomicDouble（JUC包中使用Unsafe类实现CAS）</li></ul> <p>无同步方案</p> <ul><li>栈封闭（局部变量）</li> <li>线程本地存储（ThreadLocal）</li> <li>无状态代码（只提供运算，不提供数据存储）</li></ul></blockquote> <ol start="3"><li>*线程间的如何进行通信？
<ul><li>*<a href="https://juejin.cn/post/7004401589385609246" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904066905014285#heading-9" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ol> <blockquote><ul><li><p>Object.wait-notify/notifyAll：控制两个线程交叉执行，例如A先执行一部分，再执行B，再执行A剩下的部分（lock.wait()）</p></li> <li><p>LockSupport.park-unpark</p></li> <li><p>Thread.join：两个线程先后执行</p></li> <li><p>CountdownLatch：线程D在线程A、B、C执行完后执行（其中ABC同时执行）</p> <ul><li>创建一个计数器，并设置一个初始值， <code>CountdownLatch countDownLatch = new CountDownLatch(3)</code>;</li> <li>调用<code>countDownLatch.await()</code>进入等待状态，直到计数值变为0；</li> <li>在其他线程调用<code>countDownLatch.countDown()</code>，该方法会将计数值减一；</li> <li>当计数器的值变为 <code>0</code> 时，<code>countDownLatch.await()</code>等待线程中的方法会继续执行下面的代码。</li></ul></li> <li><p>CyclicBarrier：线程ABC在准备好后同时执行（即线程间相互等待）。CountdownLatch则适合一等多的场景。</p> <ul><li>首先创建一个公共对象<code>CyclicBarrier</code>，并设置同时等待的线程数，<code>CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</code></li> <li>这些线程同时开始准备，准备好后，需要等待别人准备好，所以调用<code>cyclicBarrier.await()</code>方法等待别人；</li> <li>当指定的需要同时等待的线程都调用了该<code>cyclicBarrier.await()</code>方法时，意味着这些线程准备好了，那么这些线程就会开始同时继续执行。</li></ul></li> <li><p>FutureTask：子线程将结果返回给主线程</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Callable&lt;Integer&gt; callable = () -&gt; {
    System.out.println(&quot;子任务开始执行&quot;);
    Thread.sleep(1000);
    int result = 0;
    for (int i = 0; i &lt;= 100; i++) {
    	result += i;
  	}
  System.out.println(&quot;子任务执行完成并返回结果&quot;);
  return result;
};
// FutureTask实现了Runnable接口，本质上仍是个runnable
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);
new Thread(futureTask).start();
// 阻塞主线程
Integer result = futureTask.get();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li></ul></blockquote> <ol start="4"><li>多线程开发过吗？通信方式有哪些？</li></ol> <blockquote><p>多线程开发过，主要是用线程池创新线程，并将任务提交给线程池处理，同时做线程安全相关的处理，比如在Java中Bean默认是单例模式，在多线程下对共享变量进行修改会有线程安全问题，所以需要对其加锁、或者改用线程安全的集合，例如ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等。</p></blockquote> <ol start="5"><li>多线程的理解（why、what、how，引出threadlocal、并发集合、volitile、同步方式（锁））</li></ol> <blockquote><p>线程是CPU调度和执行的最小单位，多线程的出现本质上是为了充分利用CPU资源，例如多核CPU，多线程可以充分利用多核并行处理，同时为了保证多应用能同时运行，且保证CPU不被例如IO这类操作阻塞导致资源浪费，CPU为线程分配了时间片，当时间片结束后会切换线程，所以多线程间又存在并发情况，而线程的并发操作会导致线程安全问题。Java提供了多种并发类解决线程安全问题，比如锁解决原子性问题（常见的锁包括Synchorize、ReentrantLock，CAS）、volitile解决内存可见性、指令重排问题、threadloca/并发类解决共享变量问题（并发类包括ConcurrentHashMap/HashTable、Vetor/CopyOnWriteArrayList、BlockingQueue等）</p></blockquote> <ol start="5"><li>多进程(继承什么, 不继承什么)，进程间的通信</li></ol> <blockquote><p><strong>进程创建</strong>：LInux中通过fork命令进行进程的创建，新进程都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。申请创建新进程的进程是父进程，被创建的进程是子进程。在Unix中，父子进程间形成类似树形的层次结构，进程和其所有子进程形成***进程组***。子进程创建后，父子进程拥有不同的地址空间，即其中一个进程对其地址空间进行了修改，这个修改对其他进程是不可见的。不同进程间的地址空间中的文件的共享通常分为两类：</p> <ol><li>不可写的内存区共享</li> <li>可写内存通过写时复制共享：当子线程要对该内存进行修改时，需要复制一份到自己的地址空间中，以确保修改是在自己的私有空间中进行。</li></ol> <p><strong>进程状态</strong>：简单状态</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagese4692f03e7af44d7bb6276acd7a0ab2d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p><strong>进程的调度</strong>：</p> <ul><li><a href="https://juejin.cn/post/6844903489148026888#heading-3" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>操作系统通过PCB（进程控制块）对进程进行调度，PCB包含了进行运行时代状态信息，包括以下三部分：</p> <ul><li>进程标识信息：用户ID、进程ID（PID）、父进程ID</li> <li>进程状态信息：进程的运行状态</li> <li>进程控制信息：优先级（获得CPU的优先级）、进程通信信息、资源分配信息</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagese07287f8a82d700ac8a13b72ed2c5cfe%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p><strong>进程通信</strong>：（内存、中间件、文件）：<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><strong>共享存储</strong>：通过对同块内存进行读写操作</li> <li><strong>消息通信</strong>：通过***send、recieve***进行发送和接收操作
<ul><li>直接通信：点对点通信</li> <li>间接通信：通过中间媒介（MQ）进行通信</li></ul></li> <li><strong>管道通信</strong>：基于文件系统，以FIFO方式进行通信，管道是半双工的，通过系统调用***read(), write()***函数进行读写操作。</li></ul></blockquote> <ol start="7"><li>线程池</li></ol> <blockquote><blockquote><p>*<strong>常见的线程池有哪几种？如果线程池爆了会怎样</strong>？ - ？</p></blockquote> <ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/12%20%E6%9C%89%E5%93%AA%206%20%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%20Java8%20%E7%9A%84%20ForkJoinPool%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgoB5l3kzomAckv5AAAxf6FCPco696.png" alt="img"></p> <ul><li><p><strong>FixedThreadPool</strong>：定长线程池，初始数量为0，达到最大数后线程池数量一定并且不会被回收，超过数量的线程则进入等待队列。</p></li> <li><p><strong>CachedThreadPool</strong>：可缓存线程池，无线程数量限制（最大可到Integer.MAX），每进来一个任务，如果无空间线程则创建新的线程，等待队列为SynchronousQueue（容量为0），60秒内线程无工作则被回收</p></li> <li><p><strong>ScheduledThreadPool</strong>：定时任务线程池，可指定核心线程数量，最大线程数量为Integer.MAX，超过核心数量的线程在执行完后即被回收</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ScheduledExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 每十秒定时执行一次</span>
service<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 十秒后，每十秒执行一次</span>
service<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 十秒后执行任务，并且在每次任务执行结束后的10秒后再次执行</span>
service<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p><strong>SingleThreadExecutor</strong>：单线程线程池。适用于所有被提交的任务都需要被依次执行的场景。</p></li> <li><p><strong>SingleThreadScheduledExecutor</strong>：单线程定时线程池。本质和定时线程池一样，只不过底层将线程数设置为1</p></li> <li><p><strong>ForkJoinPool</strong>：JDK7后引入的线程池，适合可以产生子任务的任务，例如递归、树的遍历等</p> <ul><li>特点：除了有任务队列，线程池中的每个线程都有自己的双端队列，任务fork（产生子任务后）会被分配到各个子线程的双端队列中，如果某个线程执行任务繁重，并且有其他线程空闲，则会用“work-stealing” 算法，从队列另外一端获取任务进行执行。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgotOV3kzomAflZxAAB99x9-MzI241.png" alt="img"></p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgoB5l3nFSOAFOkbAABvJKvhTKk938.png" alt="img"></p></li></ul> <blockquote><p><strong>实现线程池，你觉得核心是什么</strong></p></blockquote> <ul><li>线程数量的管理（核心/最大线程数量）</li> <li>线程等待队列（当任务&gt;核心线程数量时如何处理）</li> <li>拒绝策略（队列已满并且线程达到最大线程数量时如何处理）</li></ul> <blockquote><p><strong>线程池及参数，maximumSize 怎么达到</strong>；（线程池拒绝策略、核心线程等原理）</p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimagesCgoB5l3eH8mAAoJCAACEOKMHtpw036.png" alt="img"></p> <blockquote><p><strong>线程池等拒绝策略</strong></p></blockquote> <ul><li>AbortPolicy：直接抛出异常，开发者可以感知任务失败并捕获异常，做相关的处理</li> <li>DiscardPolicy：直接丢掉，消息会无感知丢失，存在数据丢失风险</li> <li>DiscardOldestPolicy：丢弃队列头部的任务（通常是在队列中待的时间最久的），同样存在数据丢失风险</li> <li>CallerRunsPolicy：由提交的线程执行其提交的任务（比较完善）。有以下好处：
<ul><li>由提交任务的线程执行，数据不会丢失</li> <li>提交任务的线程执行任务，即被占用，不能再提交，减缓任务提交的速度，为线程池提供缓冲期处理</li></ul></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimagesCgotOV3g0WWAVWVlAAEsBI6lEEA162.png" alt="img"></p> <blockquote><p><strong>线程池的等待队列</strong></p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgq2xl3nUryAJBkpAAA0_WFSrB8184.png" alt="img"></p> <blockquote><p><strong>线程池的处理过程</strong></p></blockquote> <ul><li>核心线程满则放入队列 -&gt; 队列满则启动备用策略，创建非核心线程 -&gt; 达到最大数量则采用拒绝策略</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimagesCgoB5l3eH-KAAHpkAAC4vEMOXQ4797.png" alt="img"></p> <blockquote><p><strong>线程池相关工具类介绍</strong></p></blockquote> <p>JUC中的Executors.new线程池()，相关的类包括</p> <ul><li>ThreadFactory（默认创建非守护线程）</li> <li>等待队列</li> <li>拒绝策略（RejectedExecutionHandler）</li></ul></blockquote> <h4 id="线程同步-synchorized、lock"><a href="#线程同步-synchorized、lock" class="header-anchor">#</a> 线程同步（Synchorized、Lock）</h4> <ol><li><strong>Java有哪些锁，分别适用于哪些场景</strong></li></ol> <blockquote><p>从待线程同步时实现思想的不同，可以分为：</p> <ul><li>乐观锁：乐观锁认为使用数据时不会有别的线程修改，所以不会加锁，只记录更新前后的数据等值判断是否被修改，如果被其他线程修改了，则根据不同的实现执行不同的操作，例如抛出异常或者自动重试（通常是后者）。Java中JUC的Atomic类都是基于CAS实现乐观锁。</li> <li>悲观锁：悲观锁认为在修改数据时一定会有其他线程来修改，所以在修改前会先加锁，确保不会被其他线程修改。Java中的Synchronized和Lock都是基于悲观锁思想实现。</li></ul> <p>从Synchronized去看待锁的轻重程度，可以分为：</p> <ul><li>偏向锁</li> <li>轻量级锁</li> <li>重量级锁</li></ul> <p>从线程申请锁时获取锁的顺序，可以分为：</p> <ul><li>公平锁：新线程来的时候如果等待队列不为空，会进入等待队列。例如ReentrantLock的公平模式。</li> <li>非公平锁：新线程来的时候，无论等待队列是否为空，都会先做锁抢占，成功则执行，失败则入队。例如Synchorize，则为非公平模式。</li></ul> <p>从同个线程是否可以重复获取锁，可以分为：</p> <ul><li>可重入锁：当线程递归调用的时候，获取同个锁时会将锁计数+1而不是阻塞，在一定程度上可以避免死锁。ReentrantLock和synchronized都是可重入锁。</li> <li>不可重入锁：同个线程获取多次获取同个锁，第二次会进入阻塞状态。</li></ul> <p>从锁是否可以被多个线程同时持有人，可以分为：</p> <ul><li>共享锁（读锁）：当某个线程对数据加了读锁后，其他线程仍然可以加读锁，但是不能加写锁。例如ReentrantReadWriteLock，本质上是实现了两个锁ReadLock和WriteLock（底层都是AQS的Sync实现），读锁可以保证并发读性能高效，而读写、写读、写写的过程互斥。公平模式下，阻塞队列的线程依次去做锁的获取；非公平模式下，写锁可以一直参与到锁的抢占，避免出现写锁饥饿的情况。</li> <li>独享锁（排他锁/写锁）：当某个线程对数据加了写锁后，该线程独占数据，不能被其他线程修改和读取。例如ReentrantLock。</li></ul></blockquote> <ol start="2"><li><strong>synchronized</strong> <ul><li><a href="https://pi-ka-chu.github.io/2019/12/synchronize%E5%85%B3%E9%94%AE%E5%AD%97/" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://juejin.cn/post/6844903918653145102#heading-15" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ol> <blockquote><blockquote><p><strong>锁（synchronized 和 Lock），synchronized 加到普通方法和静态方法的区别，一个类的两个方法都加了 synchronized，是一个锁还是两个锁</strong>； - ？</p></blockquote> <p>答：synchronized可以修饰方法、代码块，加的锁分为类锁和对象锁，例如synchronized修饰static和普通方法，修饰static的加的是<strong>类锁</strong>，不同对象对该方法的调用，都会出现锁竞争的情况，并且只有一个对象可以获取到锁。对于普通方法，加的是<strong>对象锁</strong>，即当前对象，即同时调用时只能有一个方法被调用，因为是对象锁，不同对象之间的调用则不会相互阻塞。</p> <blockquote><p><strong>synchronized的方法同步和代码块同步区别</strong></p></blockquote> <ul><li>*<a href="https://juejin.cn/post/6844903918653145102" target="_blank" rel="noopener noreferrer">synchronized加锁原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>答：两者在JVM的底层实现是不同的</p> <ul><li>同步代码块的实现主要基于对象监视器（Monitor）实现，其主要是利用<code>monitorenter</code>和<code>monitorexit</code>指令实现代码同步。</li> <li>同步方法则是依靠方法修饰符上的<code>ACC_SYNCHRONIZED</code>标识实现同步。被synchronized修饰的方法上会有ACC_SYNCHRONIZED标识，有该标识的方法需要先获取monitor对象锁，默认是当前对象，而同步代码块可以指定加锁的对象，通常我们是定义一个final对象，防止对象被修改导致无法达到锁的效果。</li></ul> <blockquote><p><strong>synchronized的原理</strong></p></blockquote> <p>第一层（synchronized）：synchronized可以修饰方法和代码块，同步代码块底层采用Monitor对象的minitorenter和monitorexit指令进行加锁和解锁。同步方法底层是对方法加了ACC_SYNCHRONIZED标识，而有该标识的方法需要先获取Monitor对象锁，所以本质上synchronized通过Monitor对象进行加锁解锁操作。</p> <p>第二层（Monitor）：Monitor又称为监视器，其实现了在一个时间点，最多只有一个线程在执行监视器的某个子程序，工作原理如下：</p> <ul><li>想要获取monitor的线程,首先会进入_EntryList队列。</li> <li>当某个线程获取到对象的monitor后,进入_Owner区域，设置为当前线程,同时计数器_count加1。</li> <li>如果线程调用了wait()方法，则会进入_WaitSet队列。它会释放monitor锁，即将_owner赋值为null,_count自减1,进入_WaitSet队列阻塞等待。</li> <li>如果其他线程调用 notify() / notifyAll() ，会唤醒_WaitSet中的某个线程，该线程再次尝试获取monitor锁，成功即进入_Owner区域。</li> <li>同步方法执行完毕了，线程退出临界区，会将monitor的owner设为null，并释放监视锁。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16ca34f7e0149c3d%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p>第三层（Minitor和对象的关联）：</p> <p>由图可知道，Monitor对象通过对象的Mark Work中的互斥量指针进行关联（重量级锁的情况下），所以在重量级锁的情况下，线程在获取锁的时候会去Monitor对象中做锁的获取。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16ca45741a93cf93%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p>不同锁的加锁过程（锁的膨胀）：</p> <ul><li>偏向锁：
<ol><li>访问<code>Mark Work</code>中偏向锁的标识是否为1（默认为1，即开启状态）</li> <li>如果为可偏向状态，则检查<code>_owner</code>线程Id是否指向当前线程，如果是，进入步骤5，否则进入步骤3</li> <li>如果线程ID未指向当前线程，则通过<code>CAS</code>操作竞争锁。如果加锁成功（成功加锁后获取锁的线程再次进入时只需校验是否当前获取锁的线程Id，无需再进行CAS操作），则执行步骤5；如果加锁失败，则执行步骤4。</li> <li>如果<code>CAS</code>获取偏向锁失败，则表示当前存在竞争，在到达全局安全点时，获取到偏向锁的线程被挂起，<strong>偏向锁升级为轻量级锁</strong>，然后被阻塞在安全点的线程继续执行同步代码。</li> <li>执行同步代码。</li> <li><strong>释放锁</strong>：偏向锁不会由线程主动释放，而是等到其他竞争锁的线程出现时，暂停拥有偏向锁的线程，检查线程是否存活，如果不存活，则恢复到无锁状态，允许其他线程竞争；如果存活，则挂起持有偏向锁的线程，将对象头<code>Mark word</code>修改为指向锁记录指针的标识，<strong>锁升级为轻量级锁状态（00）</strong>，最后重新唤醒挂起的线程。</li></ol></li> <li>轻量级锁：（轻量级获取锁的依据是第四步的栈帧和Mark Word相互指向成功，这个替换过程由CAS进行操作，如果执行过程中Mark Work中的指针发现变化，则说明有其他线程获取到了锁，此时线程继续自旋直到轻量级锁被释放，即Mark Work中的Lock Record被赋值回来，如果一直失败，则在一定次数后膨胀到重量级锁）
<ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁标识为“0”），虚拟机首先将在<strong>当前线程的栈帧</strong>中建立一个名为<strong>锁记录</strong>（<code>Lock Record</code>）的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝，官方称之为<code>Displaced Mark Word</code>。
<img src="http://ww1.sinaimg.cn/mw690/0061iV1igy1ga0yp11ok4j30t00dqtd3.jpg" alt="image.png"></li> <li>拷贝对象头中的<code>Mark Word</code>复制到锁记录中。</li> <li>拷贝成功后，虚拟机将使用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针，并将<code>Lock record</code>里的<code>owner</code>指针指向<code>object mark word</code>。如果更新成功，则执行步骤4，否则执行步骤5。</li> <li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象<code>Mark Word</code>的锁标志位设置为“00”，即表示此对象处于<strong>轻量级锁定状态</strong>，这时候线程堆栈与对象头的状态如下图所示。
<img src="http://ww1.sinaimg.cn/mw690/0061iV1igy1ga0yurrfbqj30sa0iyag8.jpg" alt="image.png"></li> <li>如果这个更新操作失败了，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁（<strong>重入</strong>，每次获取轻量级锁时都会创建一个 <code>Lock Record</code>，锁重入时会创建多个指向同一个<code>Object</code>的<code>Lock Record</code>，除第一次设置<code>Displaced Mark Word</code> ，后面均设置为 null），那就可以直接进入同步块继续执行。否则说明<strong>多个线程竞争锁</strong>，（多次自旋无果后）轻量级锁就要<strong>膨胀为重量级锁</strong>，锁标志的状态值变为“10”，<code>Mark Word</code>中存储的就是指向重量级锁（互斥量)的指针，后面等待锁的线程也要进入<strong>阻塞状态</strong>。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li> <li><strong>释放锁</strong>：利用<code>CAS</code>操作把当前线程的栈帧中的<code>Displaced Mark Word</code>替换回锁对象的<code>Mark Word</code>中去，如果替换成功，则解锁成功，恢复到无锁的状态（01）。若替换失败，则轻量级锁膨胀为重量级锁后再解锁。</li></ol></li> <li>重量级锁
<ul><li>重量级锁即为第二层的Monitor对象加锁过程，其应用到操作系统的互斥量进行操作，涉及到用户态和内核态的切换，开销比较大。</li></ul></li></ul> <p>总结：</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images16ca4f292061cb0a%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="img"></p> <p><strong>synchronized的优化</strong>：</p> <ul><li><p><strong>锁膨胀</strong>：1.7后，synchronized采用了锁膨胀的优化，如偏向锁、轻量级锁、重量级锁</p></li> <li><p><strong>锁消除</strong>：单线程下采用并发类或加锁，则锁会被消除</p> <blockquote><p>例如StringBuffer是一个线程安全的类，其内部方法使用Synchronize修饰，但是如果我们是在单线程下使用StringBuffer进行字符串操作，那么不存在线程安全问题（线程封闭），但是频繁的加锁和解锁会造成性能消耗，此时Java在运行时会把锁消除进行优化（运行时优化，javap无法查看），可以利用工具查看Java最终运行的汇编代码，利用汇编指令表可以对照查看。</p></blockquote></li> <li><p><strong>锁粗化</strong>：</p> <blockquote><p>例如在for循环中循环的加锁，会频繁的进行加锁解锁操作，造成性能消耗，Java会进行优化，将锁范围进行扩大，例如扩到到for循环外部。</p></blockquote></li> <li><p><strong>自旋锁</strong>：</p> <blockquote><p>轻量级锁加锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p></blockquote></li></ul></blockquote> <ol start="2"><li><strong>JUC</strong> <ul><li><a href="https://juejin.cn/post/6844903601534418958" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>*<a href="https://juejin.cn/post/6844903601538596877" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ol> <blockquote><blockquote><p><strong>JUC包的目录结构</strong></p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images163260cff7a637f5%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="concurrent目录结构.png"></p> <blockquote><p><strong>JUC包的整体实现图</strong></p></blockquote> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images163260cff7cb847c%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="concurrent包实现整体示意图.png"></p> <blockquote><p><strong>说一说ReentrantLock</strong></p></blockquote> <p>ReentrantLock是可重入锁（排他锁），提供了公平和非公平两种模式。与Synchorized不同，ReentrantLock是在Java层面实现，其底层通过实现Lock接口，并用AQS的实现类Sync做加锁、解锁和线程同步等操作。ReentrantLock本身没有太多代码，其核心代码都有Sync属性做了实现和操作，而Sync继承自AQS，所以AQS是ReentrantLock实现的核心组件。</p> <blockquote><p><strong>说一说AQS</strong></p></blockquote> <p>AQS即抽象队列同步器，其采用了模版方法的设计模式，封装了底层同步状态管理、线程排队、等待和唤醒等底层操作。并提供了抽象方法给具体类实现，如独占式获取与释放锁、共享式获取与释放锁，例如ReentrantLock提供了公平和非公平锁两种模式，底层就是通过继承AQS实现了两个锁，并且在tryAcquire（锁的获取）做不同的实现（true则抢占锁成功，false则失败），公平的返回false（AQS封装了入队操作），非公平的直接抢占，成功则返回true（AQS认为其加锁成功）。总的来说AQS的主要包括以下过程：</p> <ol><li>线程调用<strong>acquire</strong>方法尝试加锁(CAS改变同步状态state以及设置当前线程为owner线程)</li> <li>成功则执行业务代码，失败则调用<strong>addWaiter</strong>方法将线程封装成Node节点，通过CAS加入等待队列
<ul><li>AQS的等待队列是一个<strong>Node节点组成的双端队列</strong>，有虚拟头部和尾指针</li></ul></li> <li>当锁的拥有者执行完业务释放锁后，调用<strong>acquireQueue</strong>方法获取等待队列头部Node（非虚拟head），调用unpark唤醒并调用acquire进行加锁操作
<ol><li>（等待队列中的锁获取过程是FIFO）</li></ol></li> <li>成功则获取锁并执行业务，失败则调用park阻塞该节点</li></ol> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images163261637c891cc2%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp" alt="独占式锁获取（acquire()方法）流程图.png"></p></blockquote> <ol start="3"><li>CAS：</li></ol> <blockquote><blockquote><p><strong>ABA问题如何解决</strong></p></blockquote> <p>CAS即compare and swap，其实现逻辑即：在修改某内存值前，将该值跟预期值做比较，如果相等（说明期间没有其他线程进行修改），则进行修改操作，否则取消操作。而如果当纯用值做比较，则可能会出现ABA的问题，即在修改过程中，内存值被修改为A，然后又被修改成B，这导致跟我们的预期值一致，但实际是经过了并发修改，为了解决这个问题，引入了版本号，每次修改该变量，则版本号加一。</p> <p>Java中的CAS操作是由Unsafe类提供的compareAndSwapXXX方法操作，是个原子性操作，底层是一条 CPU 的原子指令（cmpxchg指令），该命令加了内存屏障，保证其执行的原子性及锁住内存。我的理解：</p> <ul><li>操作前记录内存值</li> <li>执行业务操作，准备好要修改的新值</li> <li>通过CAS原子性操作（通过内存屏障锁内存，保证CAS只有一个执行，而不会有两个CAS并发执行）</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int prev, next;
do {
  	prev = get();
	next = updateFunction.applyAsInt(prev);
} while (!compareAndSet(prev, next));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h4 id="并发类-threadlocal、volitile、原子类"><a href="#并发类-threadlocal、volitile、原子类" class="header-anchor">#</a> 并发类（ThreadLocal、Volitile、原子类）</h4> <ol><li>ThreadLocal 用过吗？底层如何实现的？作用是什么？应用场景？ *  2
<ul><li>*<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/44%20ThreadLocal%20%E9%80%82%E5%90%88%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B8%AD%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ol> <blockquote><p><strong>项目应用</strong>：</p> <p>用过，ThreadLocal我们用来保存每个请求的用户基本信息，ThreadLocal相当于为每个线程创建了副本变量，每个线程获取到的都是自己的用户数据，这样我们只需在网关解析用户信息并保存到ThreadLocal中，在线程经过的方法如果需要用到用户信息，则直接从ThreadLocal获取即可。</p> <p><strong>底层实现</strong>：</p> <p>ThreaLocal是用来解决线程安全问题的，但是它解决的不是多线程的资源共享问题，而是换了一种思路，为每个线程创建变量副本，所以对于本身就希望多线程间数据共享的场景，ThreadLocal并不适用，这时可以用Synchorized，当然Synchorized也可以解决ThreaLocal的场景一的问题，但是加锁并发性能大大降低，ThreadLocal则可以牺牲一定的内存，提高并发性能。</p> <ul><li>Thread、TreadLocal、ThreadLocalMap三者的关系：ThreadLocalMap是Thread的一个属性，即1对1的关系，而ThreadLocal的引用则作为ThreadLocalMap的key，set的值则作为ThreadLocalMap的value。</li> <li>ThreadLocalMap本质上是一个Entry 类型的数组，可以理解为类似HashMap的Key，Value结构，和HashMap采用拉链法解决哈希冲突不同，ThreadLocalMap采用的是线性探测法解决，即继续往下找下一个空位。</li> <li>获取ThreadLocal中value的流程如下
<ul><li>通过threadLocal的get方法获取</li> <li>get方法中会获取当前线程并获取线程的ThreadLocalMap（Entry数组）中的Entry</li> <li>接着从Entry获取该值并返回</li></ul></li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgq2xl5M5a6ADeCKAABC52ZxZCk238.png" alt="img"></p> <p><strong>应用场景</strong>：</p> <ol><li><strong>保证线程安全</strong>：<strong>每个线程有各自的副本对象，将原本并发线程不安全的情况变成<em>线程安全</em>的情况</strong>。例如：线程池 + SimpleDateFormat（线程不安全）+ ThreadLocal（加了ThreadLocal则安全，因为每个线程获取到的都是各自的副本）</li> <li><strong>单线程中优雅的共享变量</strong>：<strong>每个线程都有自己的副本对象，并且可以方便的共享给其他方法</strong>。例如：用户信息保存到ThreadLocal中，在需要的时候直接获取，而不需要通过参数传递。</li></ol> <p><strong>ThreadLocal如何解决内存泄漏问题</strong></p> <p>ThreadLocal的内存泄漏主要是ThreadLocalMap的key（ThreadLocal）和value（T），当线程执行完之后，ThreadLocal中的信息已经没有用了，并且方法栈中ThreadLocal的引用也消除了，但是仍然被线程的ThreadLocalMap引用，这会导致GC做可达性分析时标志为可达，造成内存泄漏，为了解决这个问题，JDK开发者做了以下措施：</p> <ol><li>Key对ThreadLocal的引用采用虚引用，所以当线程执行完业务后，虚引用的Key可以被GC。并且在执行 ThreadLocal 的 set、remove、rehash 等方法时，会扫描key为null的entry，将其value值置为null，以保证value值可以被GC。</li> <li>但是还是会有问题，假设ThreadLocal不再被使用，并且线程又一直存活，那么value还是会有内存泄漏问题，所以为了保证其可以被正常回收，在使用完ThreadLocal后，会调用其remove方法将value值删除。</li></ol> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesCgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt="img"></p></blockquote> <ol start="2"><li>用过原子类吗？答AtomicInteger，问它的原理；</li></ol> <blockquote><p>AtomicInteger是JUC的Atomic包下的类，可以在多线程并发的情况下对其进行计算操作，底层采用乐观锁实现，即volitile+CAS去更新value 值，其中volitile保证了value在多线程下的可见性，CAS保证了其并发修改的安全性。</p></blockquote> <ol start="3"><li>说说volitile（引出单例）</li></ol> <blockquote><p>volitile是Java中用于解决线程安全问题的类，可以认为是轻量版的synchorized，volitile只解决多线程下的可见性及指令重排带来的安全性问题，而不解决原子性问题。</p> <ul><li><strong>可见性</strong>：可见性问题出现的原因是由于CPU和主存的运行速度相差太大，为了提升CPU的使用率，在其两者间加入了了缓存，线程对值的修改都会先写入缓存，再写入内存中，单线程下是没有问题的，但是如果多线程下，而CPU又拥有多核，那么不同线程修改的值都更新在各自都CPU核对应的缓存上，导致出现可见性问题，volitile解决的就是这个问题，被volitile修饰的变量的修改会被直接更新到主存，读取也是从主从中读取，这样即解决了多线程下的可见性问题。</li> <li><strong>指令重排</strong>：以普通懒汉式单例模式为例子，当我们获取单例时，会先检查该对象是否为空，不为空就返回，单线程下是没问题的，但是多线程并发操作下，返回的实例可能由于指令重排还没被实例化，进而导致出错。通常创建实例的流程是这样的：类加载 - 获取类元信息 - 申请内存 - 根据类元信息创建实例 - 返回内存地址到方法栈，但是指令重排可能导致在申请内存后直接返回地址，然后才是创建实例，而如果返回到地址被其他线程调用，则会出现对象不为空但是还没实例好导致出错。</li></ul></blockquote> <ol start="4"><li>并发集合（引出集合类）</li></ol> <blockquote><p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesjava-thread-x-juc-overview-2.png" alt="image"></p> <p><strong>CopyOnWriteArrayList</strong></p> <p>原理：底层采用反射 + ReentrantLock保证线程安全问题</p> <ul><li>读不加锁</li> <li>写加锁（可重入锁），复制新数组，往新数组写入新元素，将数组引用指向复制的数组</li></ul> <p>使用场景：读多写少，且数据量不大的场景</p> <p>缺点：</p> <ul><li>性能问题：由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc（大对象创建）</li> <li>一致性问题：不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li></ul> <p><strong>ConcurrentHashMap</strong></p> <p>本质：ConcurrentHashMap是一个线程安全的Map集合</p> <ul><li>存储结构上：
<ul><li>1.7：数组 + 链表</li> <li>1.8：数组 + 链表 + 红黑树（超过8转换为红黑树，红黑树空间为Node的两倍，但是查询效率更高，为log(n)）</li></ul></li> <li>线程安全上：
<ul><li>1.7：<strong>Segment分段锁</strong>保证线程安全，相比较HashTable直接对整个对象加锁，segment降低了锁的粒度，提高了并发性能，segment继承自ReentrantLock，本质上是一把悲观锁。segment的数量默认是16，并且初始化后即使扩容也不能改变。</li> <li>1.8：采用 <strong>Volatile + CAS + synchronized</strong>保证线程安全，当目标Node数组的元素为空时，采用CAS去对Node数组做值的更新，当目标Node数组不为空，并且Key不同，即发生了哈希冲突，则采用synchorized锁住Node，并且做冲突处理。</li></ul></li></ul> <p>主体结构：</p> <ul><li><p>Node节点</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {

    final int hash;

    final K key;

    volatile V val;
	
		// 哈希冲突时的链表
    volatile Node&lt;K,V&gt; next;

    // ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li> <li><p>put方法</p> <ul><li>计算key的哈希值</li> <li>检查当前的Node数组是否为空，如果为空则进行初始化（默认为16）</li> <li>初始化后根据哈希值计算数组下标（（n-1）&amp; hash）
<ul><li>如果当前下标的Node为空则通过CAS方式放入新值；
<ul><li>如果当前槽点有数据，则比较key
<ul><li>相同则通过CAS覆盖值。</li> <li>不相同则说明出现哈希冲突，通过synchronized锁住当前Node节点，判断当前的哈希冲突数据机构
<ul><li>如果为链表则遍历链表，找到相同key则覆盖，没找到则添加，并检查添加后长度是否超过8，超过则将链表转换为红黑树</li> <li>如果为红黑树结构，则调用putTreeVal往树中添加元素</li></ul></li></ul></li></ul></li></ul></li></ul></li> <li><p>get方法</p></li></ul> <p><strong>LinkedBlockingQueue</strong></p> <ul><li><p>LinkedBlockingQueue实现了BlockingQueue接口，底层采用链表对元素进行存储，可以设置链表长度，默认为Integer.MAX_VAL，其采用FIFO的方式进行元素出队，并且采用ReentrantLock进行加锁处理，保证并发安全。像定长线程池和单线程线程池都采用LinkedBlockingQueue作为其阻塞队列。</p></li> <li><p>BlockingQueue：BlockingQueue是一个阻塞队列接口，定义了四组不同的方法用于插入和移除队列元素（put和take为阻塞的，其他失败都会返回或者抛异常），常用与作为生产者和消费者之间的等待队列，生产者将任务put入队列，消费者从另外一端take出。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220711003303473.png" alt="image-20220711003303473"></p></li></ul> <p><strong>SynchronousQueue</strong></p> <ul><li>用于可缓存线程池，队列容量为0，只提供阻塞作用，当任务来时阻塞直到线程池take。</li></ul></blockquote> <h3 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h3> <ul><li><strong>对象从产生到消亡的过程</strong>（类加载、内存分配、对象创建、代码运行、GC（垃圾标识、垃圾回收）</li></ul> <p>GC：</p> <ul><li>Minor gc 、Major gc和full gc的区别</li> <li>堆内存的垃圾回收算法（引出垃圾标识算法、垃圾回收器）</li> <li>Full GC场景</li> <li>说一下GC</li> <li>GC机制</li></ul> <p>JVM调优</p> <ul><li>有过调优经验吗
<ul><li>内存分配上的优化</li> <li>GC垃圾回收器选择</li> <li>辅助功能参数添加</li></ul></li></ul> <p>JMM</p> <ul><li>描述一下Java内存模型
<ul><li>JVM操作栈</li> <li>本地方法栈</li> <li>程序计数器</li> <li>堆</li> <li>元方法区（引出类加载过程）</li></ul></li> <li>Java的内存分配过程</li> <li>HotSpot 中的持久代指的是哪个分区？</li> <li>堆的分区是怎样的？（引出对象从young区到old区到整个过程，接着引出GC）</li> <li>Java堆栈的区别</li> <li>*什么情况下会发生OOM？（除了代码问题外，可以引出GC问题）
<ul><li>遇到过内存泄漏问题吗？</li></ul></li></ul> <p>类加载机制</p> <ul><li>类加载过程是怎么样的</li></ul> <blockquote><p><a href="https://juejin.cn/post/6844903564804882445#heading-2" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>加载 - 连接（验证、准备、解析）- 初始化</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630333038313834333235353933" alt="img"></p> <p><strong>加载</strong>：读取字节码文件（class文件）到内存，并在方法区创建类元信息</p> <p><strong>链接</strong>：</p> <ol><li>校验：检查文件格式、字节码文件数据的正确性</li> <li>准备：给类的静态变量分配内存空间（static修饰的变量），并且赋予默认值（如null、false、0等）</li> <li>解析：将符号引用转成直接引用（个人认为是对接口、类、字段进行解析，主要是为了将其解析为JVM可识别的结构）</li></ol> <p><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作</p></blockquote> <ul><li>类加载器有哪些</li></ul> <blockquote><ul><li>启动类加载器（Bootstrap ClassLoader）：加载JAVA_HOME\lib目录下的类</li> <li>扩展类加载器（Extension ClassLoader）：加载JAVA_HOME\lib\ext目录下的类</li> <li>应用程序类加载器（Application ClassLoader）：负责加载开发人员所编写的诸多类，如CLASS-PATH下的类</li> <li>自定义类加载器（User ClassLoader）：自定义类加载器，当存在上述类加载器解决不了的特殊情况，或存在特殊要求时，可以自行实现类加载逻辑</li></ul></blockquote> <ul><li>双亲委派机制</li></ul> <blockquote><p><a href="https://juejin.cn/post/6974405506630680590" target="_blank" rel="noopener noreferrer">*参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>类的加载过去是自下向上请求，自上下载加载的过程，下级加载器会向上级加载器请求加载某类，如果上级能加载则加载，否则由下一级加载器尝试，直到有类加载器能够加载。这种机制本质上是为了解决子类加载器覆盖父类加载器加载的类的问题，如果没有双亲委派，而是子类加载器直接加载，如果自定义了Object类，那么会导致基类Object类被覆盖，进而导致问题。</p> <p>如何打破双亲委派机制？</p> <ul><li>自定义类加载器，重写loadClass方法（该方法定义了双亲委派逻辑）</li> <li>使用上下文类加载器：该类加载器主要用来加载外部类，例如<code>JNDI、JDBC、JAXB</code>。因为双亲委派机制不能支持SPI（Service Provider Interface），对于这些外部类需要用到该加载器进行加载。</li></ul></blockquote> <h2 id="spring"><a href="#spring" class="header-anchor">#</a> Spring</h2> <h3 id="bean"><a href="#bean" class="header-anchor">#</a> Bean</h3> <ul><li>Spring Bean的生命周期是什么</li></ul> <blockquote><p>核心过程包括：Bean元信息加载、Bean实例化、Bean属性输入、Bean初始化、Bena的使用、Bean的销毁。</p> <p>主要钩子：</p> <ul><li>Aware获取BeanName、ApplicationContext，BeanFactory</li> <li>@PostContract、init-method初始化</li> <li>@PreDestory销毁前的资源关闭</li></ul></blockquote> <blockquote><ol><li>加载Bean元信息（@Compent、xml、Java类加载），存储在BeanDefinitionMap中</li> <li>执行BeanFactoryPostProcessor后置处理器（可以修改Bean元信息，不常用）</li> <li>实例化对象（反射机制）</li> <li>注入对象属性</li> <li>检查是否实现了Aware接口（BeanName，ApplicationContext、BeanFactory），类似于钩子，实现了该接口则调用其set方法，从而获取到对象的元素</li> <li>BeanPostProcessor before方法（AOP实现相关）</li> <li>执行初始化相关方法：@PostContruct、InitializingBean接口、定义的init-method方法</li> <li>BeanPostProcessor after方法</li> <li>可以正常调用对象</li> <li>执行销毁前的方法，如@PreDestroy（关闭连接）</li> <li>销毁Bean</li></ol></blockquote> <ul><li>如何解决循环依赖问题？</li></ul> <blockquote><p><a href="https://juejin.cn/post/6882266649509298189" target="_blank" rel="noopener noreferrer">*参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Spring采用三级缓存解决循环依赖问题，缓存本质上就是为了提前暴露Bean（半成品），避免循环依赖导致的死循环问题。</p> <table><thead><tr><th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>singletonObjects</td> <td>一级缓存，存放完整的 Bean。</td></tr> <tr><td>earlySingletonObjects</td> <td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td></tr> <tr><td>singletonFactories</td> <td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td></tr></tbody></table> <p>A、B循环依赖的处理过程：</p> <ol><li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li> <li>为 A 创建一个 Bean 工厂，并放入到 singletonFactories 中。</li> <li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li> <li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li> <li>为 B 创建一个 Bean 工厂，并放入到 singletonFactories 中。</li> <li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li> <li>将对象 A 注入到对象 B 中。</li> <li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li> <li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li> <li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li></ol></blockquote> <ul><li>为什么需要三级缓存？</li></ul> <blockquote><p><a href="https://juejin.cn/post/6882266649509298189" target="_blank" rel="noopener noreferrer">*参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Spring的三级缓存存放的是创建Bean的工厂实例（该实例可以提前创建代理对象），是为了解决AOP代理问题，通常的情况下，Spring Bean在完成初始化后开始为其创建代理对象，而在循环依赖过程中，依赖的对象并没有完成实例化，如果直接注入，那么注入的是普通Bean而<strong>非代理Bean</strong>，所以<strong>第三级缓存就是为了提前创建及暴露代理对象</strong>。</p> <p>（当然，如果将代理对象的创建过程提前，则可以不需要第三级缓存，直接将创建的代理对象半成品放入二级缓存即可）</p></blockquote> <h3 id="ioc"><a href="#ioc" class="header-anchor">#</a> IOC</h3> <p>什么是IOC？</p> <blockquote><p>IOC翻译过来就是”控制反转“，IOC容器的特点就是：</p> <ul><li>能让对象依赖解耦：没有IOC容器的时候，对象间的引用需要直接通过new创建，这导致对象间的引用十分严重，而有了IOC容器后，对象创建后注入到IOC容器中，需要时从容器中获取并注入（DI），从而对象间实现了解耦。</li> <li>单例减少对象内存：IOC默认采用单例模式创建对象，单实例对象供多对象调用，减少直接new带来的内容消耗。</li></ul> <p>目前Spring对Bean的管理即用到了IOC容器。</p></blockquote> <p>BeanFactory和ApplicationContext的区别？</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images/image-20220919180037194.png" alt="image-20220919180037194"></p> <blockquote><p><strong>功能上</strong>：BeanFactory即Bena的工厂类，用于Bean的创建，其定义了基本的Bean操作方法，包括获取、添加、判断是否存在、是否为单例等，ApplicationContext又称为上下文信息（企业级Bean管理），其继承自BeanFactory，并且添加了其他的功能增强，例如国际化、消息资源处理、与AOP的整合。</p> <p><strong>Bean的管理上</strong>：BeanFactory采用懒汉式加载的方式，等到getBean的时候才实例化Bean，而ApplcationContext采用饿汉式加载，在创建的时候就会实例化所有Bean，通常我们会使用ApplicationContext多一些，对于安卓应用，如果内存比较小，则采用BeanFactory可以减少内存的消耗。</p></blockquote> <p>FactoryBean和BeanFactory的区别？</p> <ul><li><a href="https://juejin.cn/post/6844903967600836621" target="_blank" rel="noopener noreferrer">*参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>FactoryBean是用于创建Bean的工厂Bean，本质上仍然是个Bean，由BeanFactory管理。通过该实例可以创建Bean实例，典型的应用是用于创建AOP的代理对象，例如三级缓存中第三级缓存存放的就是一个Bean的创建工厂。</p> <p>BeanFactory是用于管理Bean的Bean容器，Bean的添加和获取都是从该工厂中获取。</p></blockquote> <h3 id="aop"><a href="#aop" class="header-anchor">#</a> AOP</h3> <blockquote><p>什么是AOP、Spring声明AOP的方式、AOP的核心概念、AspectJ和AOP和CGLib的区别</p></blockquote> <p>什么是AOP？</p> <blockquote><p>AOP即面向切面编程，Spring AOP采用代理模式的设计方法，底层通过反射创建匿名代理类，并且在目标方法前后做方法增强。常见的应用场景有权限校验、日志打印、统一异常处理等。</p></blockquote> <p>Spring实现AOP的方式有哪些？核心概念有哪些（对应的注解）</p> <blockquote><p>Spring中AOP的声明主要有两种，分别是xml和注解。</p> <p>其核心概念主要有：</p> <p><strong>切点</strong>：即具体的在哪个方法或者包调用时进行代理。</p> <p><strong>切面</strong>：多个切点即形成一个切面</p> <p><strong>通知/增强</strong>：</p> <ul><li>Before：前置通知（方法调用前）</li> <li>After：后置通知（方法调用后，无论是否成功，相当于<code>Finally</code>代码块）</li> <li>Around：环绕通知（可以在目标方法前或方法后执行，即可以在环绕方法里调用目标方法）</li> <li>After-throwing：异常通知（在方法抛出异常后调用通知）</li></ul> <p><strong>织入（Weaving）</strong>：可以认为是创建代理对象进行代理的过程，例如Java中的织入分为两种：</p> <ul><li>运行时织入：Spring AOP</li> <li>编译时织入：AspectJ、CGLib</li></ul></blockquote> <p>AspectJ和AOP和CGLib的区别？</p> <blockquote><p>Java中的代理的实现主要分为两种：</p> <ul><li>编译时代理：通过修改字节码文件实现代理（AspectJ和CGLib）</li> <li>运行时代理：通过反射机制实现代理（Spring AOP）</li></ul> <p>在功能上：</p> <ul><li>CGLib：通过创建子类进行代理</li> <li>Spring AOP：通过实现接口进行代理</li></ul></blockquote> <h2 id="项目经历"><a href="#项目经历" class="header-anchor">#</a> 项目经历</h2> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220925234241528.png" alt="image-20220925234241528"></p> <h3 id="项目通用"><a href="#项目通用" class="header-anchor">#</a> 项目通用</h3> <p>*<strong>项目遇到什么难点？如何解决的（如何优化的）</strong> - ？ * 3</p> <p>PCM</p> <ol><li><strong>服务拆分</strong></li> <li><strong>旧数据的迁移</strong>（数据一致性，分布式事务）</li> <li><strong>单体-&gt;分布式</strong>：分布式定时任务、分布式锁、最终一致性（当MQ重试次数到了之后，会将其提交到Exception Queue，而不是丢弃，在Exception Queue中又会进行多次重试，如果仍然失败，则需要人工进行处理）</li> <li><strong>规则编排</strong>：类似于Java线程的状态转化，订单也有其生命周期，状态与Java线程状态类型，而往往航运中的订单状态的转换比较复杂，影响状态的因素又比较多，我们很难通过编写硬代码去实现“某个变量变化了，去链式的更新其状态”（即变化本身也会作为变量去影响其他），drools则封装了底层的链路，我们只需要编写好规则：【变量、行为】即可</li></ol> <p>智慧服务区</p> <blockquote><p>项目经验大纲：</p> <ul><li>卡口数据接收：幂等性、剩余车位计算（共享变量 -&gt; 数据库表存储当前车辆信息）</li> <li>情报板发送：有序性、柔性事务（本地消息表）、原子性（分布式锁并发处理情报板发送，分为四步骤：1. 删除旧情报板文件、2. 发送创建新的文件、3. 发送文件内容、4. 播放文件）</li> <li>基础设备数据采集：Netty NIO模型/零拷贝/Reactor线程模型</li> <li>设计模式：工厂模式、单例模式、适配器模式 + 模板模式</li></ul></blockquote> <ul><li>剩余停车位计算：
<ul><li>思考并发停车位计算问题：如果多线程下去读取车位信息、修改后保存，这种会出现线程安全问题（数据覆盖）
<ul><li>解决方案：不通过共享变量去计算剩余停车位，而是通过独立一张数据库表存储当前停车信息，那么剩余停车位的发布就不需要经过并发计算，而是用（总停车位 - 当前停车数量）即可。</li></ul></li> <li>思考幂等性问题：卡口可能会发送重复车辆抓拍信息，导致出现车辆重复驶入，进而导致车位计算有误
<ul><li>解决方案：
<ul><li>采用Redis做车辆幂等处理，驶入时车辆车牌信息，做第一层幂等过滤。</li> <li>当前车辆停车信息保存在cur-parking表中，所以数据库中车牌做唯一键处理，做第二层幂等过滤。</li></ul></li></ul></li> <li>思考卡口数据丢失问题：Kafka默认是消费者接收到消息后自动提交offet的机制，如果此时消息消费异常，那么将导致消息丢失。
<ul><li>解决方案：关闭auto commit，改用手动commit ack，保证数据被正确处理后才提交，而手动提交又分为同步提交和异步提交两种方式，同步提交会阻塞当前线程不断重试直到成功。以下情况会做ack提交
<ul><li>不符合业务的数据或者格式有误的数据（如无法确定卡口位置）</li> <li>重复消费的数据</li> <li>业务正常执行</li></ul></li></ul></li> <li>思考分布式事务：接收到卡口信息后，需要做以下业务处理
<ul><li>更新事件服务</li> <li>更新停车服务停车信息</li> <li>计算剩余停车位并发送情报板</li> <li>发送ws事件弹窗</li></ul></li></ul></li> <li>基础设备通信：Netty
<ul><li>情报板（手动、自动发布）
<ul><li>思考如何保证情报板最终能够成功发布（<strong>柔性事务</strong>）：情报板为异步发送，即先返回发送成功再异步发送，但是这个过程可能出现消息丢失。
<ul><li>解决方案：采用本地消息表的实现思路，保存情报板发送的消息并添加发布结果的字段到数据库，当情报板正常发布后会有发布成功的结果反馈更新该字段，定时器每隔十秒扫描一次，如果没有收到发布结果，则重新发送消息直到消息收到反馈成功，此种采用了柔性事务，保证数据的最终一致性。</li></ul></li> <li>出现情报板发布失败的问题，检查后发送对接人员开启多线程修改静态socket做发送（线程安全问题），并且情报板的发送分为四步，清除-创建-添加-播放，没有做原子性处理，导致并发问题的出现，解决方案，每次请求新建socket，并对同个设备的四步操作做加锁处理。</li> <li>思考采用Netty NIO框架替换原始的BIO，提高并发性能。</li></ul></li> <li>水电设备</li></ul></li></ul> <p><strong>单点登录的实现：JWT</strong></p> <p><strong>项目介绍 * 2</strong></p> <p><strong>项目用到了什么技术栈？ * 2</strong></p> <h3 id="pcm-分布式事务、数据库、分布式锁"><a href="#pcm-分布式事务、数据库、分布式锁" class="header-anchor">#</a> PCM：分布式事务、数据库、分布式锁</h3> <p><strong>微服务：DDD微服务拆分、Swift方法论</strong></p> <ul><li>*旧系统为什么要进行拆分？
<ul><li>公司方向为上云</li> <li>项目本身存在问题
<ul><li>OOM</li> <li>框架老旧、维护困难</li> <li>服务耦合，相互影响，版本难以控制</li></ul></li></ul></li> <li>服务拆分成了几个？部署了多少实例？单表量最大多大？</li></ul> <blockquote><p>旧系统是单体系统，主要分为两个项目，BE和BW，BE作为规则引擎，提供规则计算，其是基于内存进行存储的，采用分布式内存，并且会将数据持久化到oracle中，这涉及到缓存与数据库数据的一致性解决，以及分布式缓存间的通信机制。例如Redis采用的是gossip协议，采用分布式共享的方式。</p> <p>服务拆分成了二三十个，实例主要看业务量，对于复杂的微服务会开启3-4个实例，其他的基本为1-2个实例。</p></blockquote> <p><strong>Drools相关问题</strong></p> <ul><li>Drools的内存模型是怎么样的？
<ul><li><a href="https://docs.gigaspaces.com/solution-hub/xap-drools-integration.html" target="_blank" rel="noopener noreferrer">Drools分布式管理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li>Drools OOM解决
<ul><li><a href="https://blog.csdn.net/zkn_CS_DN_2013/article/details/49094575" target="_blank" rel="noopener noreferrer">参考一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/dreamwbt/article/details/121861568" target="_blank" rel="noopener noreferrer">参考二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li>规则编排：Drools原理，好处？</li></ul> <blockquote><p>Drools是一个规则引擎，它提供了一种基于规则的方式来实现业务逻辑，<strong>将业务逻辑与应用程序代码分离</strong>（我的理解是采用Drools之后，我们只需要关注输入和输出是什么就行，而对于If-Else的条件控制，则交给规则引擎处理），实现了更好的灵活性和可维护性。底层采用Rete算法实现，该算法根据我们编写的rule规则，解析并构建了一个有向无环图，并且分为以下几种类型的节点</p> <ul><li><strong>Root Node</strong>：根节点，是所有对象进入网络的入口，它可以让所有的事实通过，然后传播给Type节点。</li> <li><strong>Type Node</strong>：Fact对象，也就是我们规则所用到的POJO，针对事实进行类型检查，引擎只让匹配该类型的对象到达后续节点，将符合本节点类型的事实向后继的Alpha节点进行传播，一个Fact对应一个Type节点。</li> <li><strong>Alpha Node</strong>：用于进行同一个对象类型内属性的约束或常量测试，即一个字面条件对应一个Alpha节点。</li> <li><strong>Beta Node</strong>：在同一个规则中根据不同对象(pet、cat)之间的约束，进行连接操作，如<code>(“pet.name==cat.name”，“pet.age&gt;cat.age”）</code>。Beta节点保存了所有到达过的语义，即类似于缓存（个人认为key可以为条件+相关的Fate属性，value为结果），所以对于Fate集合变化不大的场景，Drools可以避免很多的重复规则配对。</li> <li><strong>Terminal Node</strong>：这是这条规则的末尾节点，它代表一个规则匹配结束，当事实或元组传递到Terminal节点时，表示该Terminal节点对应的规则已被激活。</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/images2327818848a44152b630859c3a8f51a7.jpg" alt="Rete网络"></p> <p>Rete算法的特性：</p> <ol><li><strong>状态保存（缓存）</strong>：事实集合中的每次变化，其匹配后的状态都被保存再Alpha和Beta节点中，在下一次事实集合发生变化时，绝大多数的结果都不需要变化，避免了大量的重复计算。</li> <li><strong>节点共享</strong>：不同规则之间含有相同的字面条件（相同的模式），从而可以共享同一个节点，Rete网络的各个部分包含各种不同的节点共享，如果某个BetaNode 被 N 条规则共享，则算法在此节点上效率会提高 N 倍。</li> <li><strong>节点索引</strong>：添加哈希索引，例如对于Alpha节点，用Fate的属性为key，Alpha节点为value，可以快速找到该节点，而不需要遍历。</li></ol></blockquote> <p><strong>Quartz相关问题</strong></p> <ul><li><p>分布式定时任务：Quartz-分布式锁</p></li> <li><p>分布式锁：Redis、Zookeeper、数据库</p></li></ul> <blockquote><p>Redis的演化过程：</p> <ul><li>setnt：宕机导致锁无法被释放</li> <li>setnt + px：非原子性命令，宕机仍然导致锁无法释放</li> <li>lua脚本执行<code>setnt + px</code>原子性命令：锁可以正常创建，并且定时删除锁，但是如果业务执行时间比较长，还没执行完锁就超时被释放，导致多个线程进入同步代码块</li> <li>Redisson看门狗（watch dog）机制：定时检查当前线程是否还在执行业务，并为锁续命</li></ul> <p>zookeeper：</p> <ul><li>原子发号器（小号则获取到锁）</li> <li>watch机制：后面的节点会监听前一个节点，前一个节点释放锁后则后一个拿到</li> <li>临时节点：当客户端断开连接后自动删除，防止由于客户端宕机导致锁无法被释放</li></ul> <p>数据库：</p> <p>隐式加锁：</p> <ul><li>基于行锁：往数据表中插入唯一键值的数据，插入成功则说明获取锁成功</li></ul> <p>显式加锁：</p> <ul><li>（悲观锁）基于for update：显式加排他锁</li> <li>（乐观锁）基于版本号判断：显式加乐观锁</li></ul></blockquote> <ul><li><a href="https://www.nowcoder.com/discuss/1002718?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1661303270552" target="_blank" rel="noopener noreferrer">*牛客面试参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="智慧服务区-kafka、redis、netty、设计模式、restful"><a href="#智慧服务区-kafka、redis、netty、设计模式、restful" class="header-anchor">#</a> 智慧服务区：Kafka、Redis、Netty、设计模式、Restful</h3> <ul><li><p>Redis：基础数据缓存、幂等性处理</p></li> <li><p>Kafka：有序性处理、可靠性处理（手动ACK）</p></li> <li><p>Netty：NIO开发、TCP协议</p> <ul><li>情报板协议对接</li> <li>水电表协议对接</li></ul></li> <li><p>设计模式：</p> <ul><li><strong>工厂模式</strong>：统计图Echart采用工厂模式进行业务和通用代码的抽象分离</li></ul> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220926000336599.png" alt="image-20220926000336599"></p> <ul><li><p><strong>适配器+模版方法</strong>：在对接设备的过程中，存在多个厂家的事件传入，而事件区别在于数据结构的不同，其事件的执行过程都基本一致，那么通过适配器模式，在接入不同厂家的时候通过适配器进行数据格式的转化，接入我们系统的事件处理流程中。</p> <p><img src="https://raw.githubusercontent.com/PI-KA-CHU/Image-OSS/main/imagesimage-20220926004235159.png" alt="image-20220926004235159"></p></li> <li><p>其他的了解到如单例、模板、责任链、观察者模式等</p></li></ul></li> <li><p>Restful：请求方法、URI命名、HTTP</p></li> <li><p>Spring AOP</p> <ul><li>广播对接：心跳机制、定时线程池（自动关闭）、切面保证每次调用前检查注册的服务是否存活</li></ul></li></ul> <h3 id="场景题"><a href="#场景题" class="header-anchor">#</a> 场景题*</h3> <ul><li>服务器被一个客户端的进程创建大量连接，怎么排查 - ？</li> <li>多读的场景是怎么优化的，感觉讲的不够好 - ？</li></ul> <blockquote><ul><li>Redis
<ul><li>缓存：提升并发读</li> <li>主从模式：提升并发读</li></ul></li> <li>读写锁：CopyOnWriteArrayList</li> <li>数据库：
<ul><li>加索引</li> <li>主从模式</li></ul></li></ul></blockquote> <ul><li>并发场景解决方案 - ？</li></ul> <blockquote><p>Java中并发场景最主要有以下处理手段：</p> <ul><li>原子性：锁（乐观锁、悲观锁【Synchorized，ReentrantLock】）</li> <li>可见性：volatile（内存屏障）</li> <li>其他：
<ul><li>多线程开发：线程池（六大线程池）</li> <li>并发容器：ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue</li> <li>栈封闭：ThreadLocal、局部变量</li></ul></li></ul></blockquote> <ul><li>云文档，共同协作输入内容，如何保证不冲突 - ？</li></ul> <blockquote><p>云在线文档我认为主要有以下几个问题：</p> <ol><li>在线查看：多人在线并且修改要被其他用户看到，所以需要服务器主动推送数据到客户端，可以用到websocket、http 2.0</li> <li>多人协作编辑（并发写）：
<ol><li>直接加锁：简单粗暴，但是用户体验较差，而且如果一个客户端将鼠标放在框中后走开，则会导致死锁，其他用户无法编辑</li> <li>不加锁，而是通过版本号控制（目前的腾讯文档似乎就是这样）：用户可以同时编辑同一个框，并且编辑的时候会生成一个递增的版本号，只更新最新的版本号。
<ul><li>优化：
<ol><li>显示当前框有人在编辑的标识，由用户去避免冲突</li> <li>数据的提交时间优化：如果用户编辑的内容比较长，那么需要定时尽快的上传数据到服务端并尽快到展示给其他用户，尽量避免其他用户覆盖数据，否则用户A编辑很长时间，而用户B看不到在最后几秒中把用户A的数据给覆盖了</li></ol></li></ul></li></ol></li></ol></blockquote> <ul><li><p>*top K * 2</p> <ul><li>RGB颜色存在一个文件中，取出出现频率前十数量的RGB颜色 - ？</li> <li>给定全国各地的城市以及各个城市的用户数量，利用spark统计下topk，说下具体思路 ？</li></ul></li> <li><p>给一个六面骰子，如何做出一个1~10的等概率随机方法？</p></li> <li><p>MySQL 查询前 100 条数据, 以及如何分组</p></li> <li><p>如何存不重复数据（答了用set存，问map不可以吗）</p></li> <li><p>部署环境 * 3</p> <ul><li>项目怎么部署的</li> <li>Docker 相关</li> <li>CI / CD 发布流程 - ？</li></ul></li> <li><p>开发环境 * 2</p> <ul><li>Git 相关</li> <li>开发环境（Windows、Linux）</li></ul></li></ul> <p>测试覆盖：单元测试（单方法）、组件测试（单服务）、E2E测试（多服务）</p> <h3 id="海量数据处理"><a href="#海量数据处理" class="header-anchor">#</a> 海量数据处理</h3> <ul><li><a href="https://juejin.cn/post/6844903519640616967" target="_blank" rel="noopener noreferrer">参考*<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <blockquote><p>密匙一：分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序</p></blockquote> <ul><li>0 - 10亿元素插入（bitmap位图）</li></ul> <h2 id="我要问的"><a href="#我要问的" class="header-anchor">#</a> 我要问的</h2> <ol><li>请问是外包吗？</li> <li>请问一共有几轮面试？多久会有结果通知？</li> <li>请问部门做的项目主要是什么类型的？</li> <li>福利待遇</li></ol> <p>剑心：（文化：梦想、专注、快乐）</p> <ul><li>公司福利待遇怎么样呢？金山相关福利剑心也会有？</li> <li>公司跟金山的关系？我了解到是西山居持股的子公司，但是看到的介绍又说是创业公司</li> <li>这是最后一面了吗？大概多久会有通知</li></ul> <h2 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h2> <h3 id="cvte"><a href="#cvte" class="header-anchor">#</a> CVTE</h3> <ul><li><a href="https://www.nowcoder.com/discuss/917826?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1654668824810" target="_blank" rel="noopener noreferrer">资料一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/857854?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1654668824810" target="_blank" rel="noopener noreferrer">资料二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/917826?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">资料三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/827803?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">资料四<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/786302?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">资料五<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/779334?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">资料六<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/627151?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">资料七<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="金山"><a href="#金山" class="header-anchor">#</a> 金山</h3> <ul><li><p>WPS：<a href="https://www.nowcoder.com/discuss/experience/company?tagId=1046" target="_blank" rel="noopener noreferrer">资料一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><a href="https://www.nowcoder.com/discuss/73974" target="_blank" rel="noopener noreferrer">资料二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/659778?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/657896?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料四<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/635511?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料五<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/634811?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料六<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/584694?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料七<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/546327?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料八<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/540803?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料九<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/797239?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料十<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>金山云：<a href="https://www.nowcoder.com/discuss/experience/company?tagId=1003" target="_blank" rel="noopener noreferrer">资料一<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><a href="https://www.nowcoder.com/discuss/98899?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料二<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/94884?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料三<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.nowcoder.com/discuss/93663?source_id=&amp;channel=" target="_blank" rel="noopener noreferrer">资料四<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul> <h2 id="欢聚时代"><a href="#欢聚时代" class="header-anchor">#</a> 欢聚时代</h2> <ul><li><a href="https://www.nowcoder.com/discuss/1002718?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=9B179C1C22CC722DBBC116E475A9AFD2-1661303270552" target="_blank" rel="noopener noreferrer">参考-牛客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="牛客网其他"><a href="#牛客网其他" class="header-anchor">#</a> 牛客网其他</h3> <ul><li>*<a href="https://www.nowcoder.com/discuss/855750?source_id=profile_create_nctrack&amp;" target="_blank" rel="noopener noreferrer">资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2023-2-16 12:49:48 ├F10: PM┤</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1c337853.js" defer></script><script src="/assets/js/3.b02e7092.js" defer></script><script src="/assets/js/53.78d19eef.js" defer></script>
  </body>
</html>
